<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"specification.js.html":{"id":"specification.js.html","title":"Source: specification.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: specification.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const crypto = require('crypto'); const sprintf = require('sprintf-js').sprintf; const extend = require('./extend'); const I18N = require('./i18n'); const _ = require('./lodash'); const SpecificationFile = require('./specification-file'); const { deepFreezeObjectTree, roundNumber, } = require('./utils'); const globalSpecificationFile = SpecificationFile.getDefaultSpecificationFile(); let globalSpecificationData = null; if (globalSpecificationFile) { globalSpecificationData = deepFreezeObjectTree(globalSpecificationFile.getSpecificationData()); } let globalSpecification = undefined; const conversionFactors = { BtusPerWattHour: 3.412128, GramsCO2OilPerWattHour: 0.568, GramsCO2GasPerWattHour: 0.2536, GallonsPerLiter: 0.264172, PoundsForcePerSquareInchPerBar: 14.5037738, }; const optionKeys = [ 'language' ]; const numberFormatCache = {}; /** * @typedef UnitSpecification * @type {object} * @property {String} unitId Unit identifier * @property {String} unitCode Unit code * @property {String} unitFamily Unit family * @property {String} unitText Unit text */ /** * @typedef TypeSpecification * @type {object} * @property {String} typeId Type identifier * @property {String} rootTypeId Root type identifier * @property {number} precision Precision for numeral values * @property {UnitSpecification} unit Unit object */ /** * @typedef DeviceSpecification * @type {object} * @property {string} deviceId Device identifier * @property {number} channel VBus channel * @property {number} selfAddress VBus address of the device itself * @property {number} peerAddress VBus address of the device's peer * @property {string} name Name of the device * @property {string} fullName Name of the device optionally prefixed with VBus channel (if it is not 0) */ /** * @typedef PacketSpecification * @type {object} * @property {string} packetId Packet identifier * @property {number} channel VBus channel * @property {number} destinationAddress VBus address of the destination device * @property {number} sourceAddress VBus address of the source device * @property {number} protocolVersion VBus protocol version * @property {number} command VBus command * @property {number} info Additional info for sorting purposes * @property {DeviceSpecification} destinationDevice DeviceSpecification object of the destination device * @property {DeviceSpecification} sourceDevice DeviceSpecification object of the source device * @property {PacketFieldSpecification[]} packetFields Array of PacketFieldSpecification objects */ /** * @typedef packetFieldGetRawValue * @type {function} * @param {Buffer} buffer Buffer object * @param {number} start Start index in the buffer * @param {number} end End index in the buffer */ /** * @typedef PacketFieldSpecification * @type {object} * @property {string} fieldId Field identifier * @property {object} name Object containing names by language code * @property {TypeSpecification} type TypeSpecification object * @property {packetFieldGetRawValue} getRawValue Function to get raw value from a buffer */ /** * @typedef PacketField * @type {object} * @property {string} id Packet field identifier * @property {Packet} packet Packet * @property {PacketSpecification} packetSpec * @property {PacketFieldSpecification} packetFieldSpec * @property {PacketFieldSpecification} origPacketFieldSpec * @property {string} name * @property {number} rawValue Raw value * @property {function} formatTextValue Function to format this packet field's raw value into textual form */ /** * @typedef FilteredPacketFieldSpecification * @type {object} * @property {string} filteredPacketFieldId * @property {string} packetId * @property {string} fieldId * @property {string} name * @property {string} type * @property {string} getRawValue */ /** * @typedef BlockTypeSection * @type {object} * @property {string} sectionId Section identifier * @property {string} surrogatePacketId Surrogate packet identifier * @property {Packet} packet Packet object * @property {PacketSpecification} packetSpec PacketSpecification object * @property {number} startOffset Offset of section start within Packet frame data * @property {number} endOffset Offset of section end within Packet frame data * @property {number} type Section type * @property {number} payloadCount Count of payload elements * @property {number} frameCount Count of frames * @property {Buffer} frameData Frame data */ const Specification = extend(null, /** @lends Specification# */ { /** * Language code (ISO 639-1) * @type {string} */ language: 'en', deviceSpecCache: null, packetSpecCache: null, blockTypePacketSpecCache: null, /** * I18N instance * @type {I18N} */ i18n: null, /** * Custom specification data to be mixed-in to built-in specification. * @type {object} */ specificationData: null, /** * Creates a new Specification instance and optionally initializes its members with the given values. * * @constructs * @param {object} options Initialization values for this instance's members * @param {string} options.language {@link Specification#language} * @param {string} options.specificationData {@link Specification#specificationData} */ constructor(options) { _.extend(this, _.pick(options, optionKeys)); this.i18n = new I18N(this.language); this.deviceSpecCache = {}; this.packetSpecCache = {}; this.blockTypePacketSpecCache = {}; const loadSpecificationDataOptions = {}; let rawSpecificationData; if (!options) { // nop } else if (options.specificationData) { rawSpecificationData = options.specificationData; } else if (options.specificationFile) { loadSpecificationDataOptions.specificationData = options.specificationFile.getSpecificationData(); } this.specificationData = Specification.loadSpecificationData(rawSpecificationData, loadSpecificationDataOptions); }, /** * Gets the UnitSpecification object matching the given identifier. * * @param {string} id Unit identifier * @returns {UnitSpecification} Unit object * * @example * &gt; console.log(spec.getUnitById('DegreesCelsius')); * { unitId: 'DegreesCelsius', * unitCode: 'DegreesCelsius', * unitText: ' °C' } * undefined * &gt; */ getUnitById(id) { return this.specificationData.units [id]; }, /** * Gets the TypeSpecification object matching the given identifier. * * @param {string} id Type identifier * @returns {TypeSpecification} Type object * * @example * &gt; console.log(spec.getTypeById('Number_0_1_DegreesCelsius')); * { typeId: 'Number_0_1_DegreesCelsius', * rootTypeId: 'Number', * precision: 1, * unit: * { unitId: 'DegreesCelsius', * unitCode: 'DegreesCelsius', * unitText: ' °C' } } * undefined * &gt; */ getTypeById(id) { return this.specificationData.types [id]; }, /** * Gets the DeviceSpecification object matching the given arguments. * * @memberof Specification# * @name getDeviceSpecification * @method * * @param {number} selfAddress VBus address of the device itself * @param {number} peerAddress VBus address of the device's peer * @param {number} [channel=0] VBus channel of the device * @returns {DeviceSpecification} DeviceSpecification object * * @example * &gt; console.log(spec.getDeviceSpecification(0x7E11, 0x0000, 1)); * { name: 'DeltaSol MX [Regler]', * deviceId: '01_7E11_0000', * channel: 1, * selfAddress: 32273, * peerAddress: 0, * fullName: 'VBus #1: DeltaSol MX [Regler]' } * undefined * &gt; */ /** * Gets the DeviceSpecification object matching the given header and direction. * * @param {Header} header Header instance * @param {string} which Either `'source'` or `'destination'` * @returns {DeviceSpecification} DeviceSpecification object */ getDeviceSpecification(selfAddress, peerAddress, channel) { if (typeof selfAddress === 'object') { if (peerAddress === 'source') { channel = selfAddress.channel; peerAddress = selfAddress.destinationAddress; selfAddress = selfAddress.sourceAddress; } else if (peerAddress === 'destination') { channel = selfAddress.channel; peerAddress = selfAddress.sourceAddress; selfAddress = selfAddress.destinationAddress; } else { throw new Error('Invalid arguments'); } } else if (typeof selfAddress === 'string') { const md = selfAddress.match(/^(?:([0-9a-f]{2})_)?([0-9a-f]{4})(?:_([0-9a-f]{4})(?:_.*)?)?$/i); if (!md) { throw new Error('Invalid device ID'); } selfAddress = parseInt(md [2], 16); peerAddress = parseInt(md [3], 16); channel = parseInt(md [1], 16); } if (channel === undefined) { channel = 0; } const deviceId = sprintf('%02X_%04X_%04X', channel, selfAddress, peerAddress); if (!_.has(this.deviceSpecCache, deviceId)) { let origDeviceSpec; if (!origDeviceSpec &amp;&amp; this.specificationData.getDeviceSpecification) { origDeviceSpec = this.specificationData.getDeviceSpecification(selfAddress, peerAddress); } if (!origDeviceSpec &amp;&amp; this.specificationData.deviceSpecs) { origDeviceSpec = this.specificationData.deviceSpecs ['_' + deviceId]; } const deviceSpec = _.extend({}, origDeviceSpec, { deviceId, channel, selfAddress, peerAddress, }); if (!_.has(deviceSpec, 'name')) { deviceSpec.name = this.i18n.t('specification.unknownDevice', selfAddress); } if (!_.has(deviceSpec, 'fullName')) { let fullNameFormatter; if (channel) { fullNameFormatter = 'specification.fullNameWithChannel'; } else { fullNameFormatter = 'specification.fullNameWithoutChannel'; } deviceSpec.fullName = this.i18n.t(fullNameFormatter, channel, deviceSpec.name); } this.deviceSpecCache [deviceId] = Object.freeze(deviceSpec); } return this.deviceSpecCache [deviceId]; }, /** * Gets the PacketSpecification object matching the given arguments. * * @memberof Specification# * @name getPacketSpecification * @method * * @param {number} channel VBus channel * @param {number} destinationAddress VBus address of destination device * @param {number} sourceAddress VBus address of source device * @param {number} command VBus command * @returns {PacketSpecification} PacketSpecification object * * @example * &gt; console.log(spec.getPacketSpecification(1, 0x0010, 0x7E21, 0x0100)); * { packetId: '01_0010_7E21_10_0100', * packetFields: * [ { fieldId: '000_2_0', * name: [Object], * type: [Object], * getRawValue: [Function] }, * { fieldId: '002_1_0', * name: [Object], * type: [Object], * getRawValue: [Function] } ], * channel: 1, * destinationAddress: 16, * sourceAddress: 32289, * protocolVersion: 16, * command: 256, * info: 0, * destinationDevice: * { name: 'DFA', * deviceId: '01_0010_7E21', * channel: 1, * selfAddress: 16, * peerAddress: 32289, * fullName: 'VBus #1: DFA' }, * sourceDevice: * { name: 'DeltaSol MX [Heizkreis #1]', * deviceId: '01_7E21_0010', * channel: 1, * selfAddress: 32289, * peerAddress: 16, * fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' }, * fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' } * undefined * &gt; */ /** * Gets the PacketSpecification object matching the given arguments. * * @memberof Specification# * @name getPacketSpecification * @method * * @param {string} packetSpecId PacketSpecification identifier * @returns {PacketSpecification} PacketSpecification object * * @example * &gt; console.log(spec.getPacketSpecification('01_0010_7E21_10_0100')); * { packetId: '01_0010_7E21_10_0100', * packetFields: * [ { fieldId: '000_2_0', * name: [Object], * type: [Object], * getRawValue: [Function] }, * { fieldId: '002_1_0', * name: [Object], * type: [Object], * getRawValue: [Function] } ], * channel: 1, * destinationAddress: 16, * sourceAddress: 32289, * protocolVersion: 16, * command: 256, * info: 0, * destinationDevice: * { name: 'DFA', * deviceId: '01_0010_7E21', * channel: 1, * selfAddress: 16, * peerAddress: 32289, * fullName: 'VBus #1: DFA' }, * sourceDevice: * { name: 'DeltaSol MX [Heizkreis #1]', * deviceId: '01_7E21_0010', * channel: 1, * selfAddress: 32289, * peerAddress: 16, * fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' }, * fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' } * undefined * &gt; */ /** * Gets the PacketSpecification object matching the given packet. * * @param {Packet} packet VBus packet * @returns {PacketSpecification} PacketSpecification object */ getPacketSpecification(headerOrChannel, destinationAddress, sourceAddress, command) { if (typeof headerOrChannel === 'object') { command = headerOrChannel.command; sourceAddress = headerOrChannel.sourceAddress; destinationAddress = headerOrChannel.destinationAddress; headerOrChannel = headerOrChannel.channel; } else if (typeof headerOrChannel === 'string') { const md = headerOrChannel.match(/^([0-9a-f]{2})_([0-9a-f]{4})_([0-9a-f]{4})(?:_10)?_([0-9a-f]{4})/i); if (!md) { throw new Error('Invalid packet ID'); } command = parseInt(md [4], 16); sourceAddress = parseInt(md [3], 16); destinationAddress = parseInt(md [2], 16); headerOrChannel = parseInt(md [1], 16); } const packetId = sprintf('%02X_%04X_%04X_10_%04X', headerOrChannel, destinationAddress, sourceAddress, command); if (!_.has(this.packetSpecCache, packetId)) { let origPacketSpec; if (!origPacketSpec &amp;&amp; this.specificationData.getPacketSpecification) { origPacketSpec = this.specificationData.getPacketSpecification(destinationAddress, sourceAddress, command); } if (!origPacketSpec &amp;&amp; this.specificationData.packetSpecs) { origPacketSpec = this.specificationData.packetSpecs ['_' + packetId]; } const destinationDeviceSpec = this.getDeviceSpecification(destinationAddress, sourceAddress, headerOrChannel); const sourceDeviceSpec = this.getDeviceSpecification(sourceAddress, destinationAddress, headerOrChannel); let fullName = sourceDeviceSpec.fullName; if (destinationAddress !== 0x0010) { fullName += ' =&gt; ' + destinationDeviceSpec.name; } const packetSpec = _.extend({}, origPacketSpec, { packetId, channel: headerOrChannel, destinationAddress, sourceAddress, protocolVersion: 0x10, command, info: 0, destinationDevice: destinationDeviceSpec, sourceDevice: sourceDeviceSpec, fullName, }); if (!_.has(packetSpec, 'packetFields')) { packetSpec.packetFields = []; } this.packetSpecCache [packetId] = Object.freeze(packetSpec); } return this.packetSpecCache [packetId]; }, /** * Gets the PacketFieldSpecification object matching the given arguments. * * @memberof Specification# * @name getPacketFieldSpecification * @method * * @param {PacketSpecification} packetSpec PacketSpecification object * @param {string} fieldId Field identifier * @returns {PacketFieldSpecification} PacketFieldSpecification object * * @example * &gt; var packetSpec = spec.getPacketSpecification('01_0010_7E21_10_0100'); * undefined * &gt; console.log(spec.getPacketFieldSpecification(packetSpec, '000_2_0')); * { fieldId: '000_2_0', * name: * { ref: 'Flow set temperature', * en: 'Flow set temperature', * de: 'Vorlauf-Soll-Temperatur', * fr: 'Température nominale départ' }, * type: * { typeId: 'Number_0_1_DegreesCelsius', * rootTypeId: 'Number', * precision: 1, * unit: * { unitId: 'DegreesCelsius', * unitCode: 'DegreesCelsius', * unitText: ' °C' } }, * getRawValue: [Function] } * undefined * &gt; */ /** * Gets the PacketFieldSpecification object matching the given arguments. * * @param {string} packetFieldId Packet field identifier * @returns {PacketFieldSpecification} PacketFieldSpecification object * * @example * &gt; console.log(spec.getPacketFieldSpecification('01_0010_7E21_10_0100_000_2_0')); * { fieldId: '000_2_0', * name: * { ref: 'Flow set temperature', * en: 'Flow set temperature', * de: 'Vorlauf-Soll-Temperatur', * fr: 'Température nominale départ' }, * type: * { typeId: 'Number_0_1_DegreesCelsius', * rootTypeId: 'Number', * precision: 1, * unit: * { unitId: 'DegreesCelsius', * unitCode: 'DegreesCelsius', * unitText: ' °C' } }, * getRawValue: [Function] } * undefined * &gt; */ getPacketFieldSpecification(packetSpecOrId, fieldId) { let packetFieldSpec; if (typeof packetSpecOrId === 'string') { if (this.specificationData.filteredPacketFieldSpecs) { packetFieldSpec = _.find(this.specificationData.filteredPacketFieldSpecs, { filteredPacketFieldId: packetSpecOrId }); } if (!packetFieldSpec) { const md = packetSpecOrId.match(/^([0-9a-f]{2}_[0-9a-f]{4}_[0-9a-f]{4}(?:_10)?_[0-9a-f]{4})_(.*)$/i); if (!md) { throw new Error('Invalid packet field ID'); } fieldId = md [2]; packetSpecOrId = this.getPacketSpecification(md [1]); } } if (!packetFieldSpec &amp;&amp; packetSpecOrId) { packetFieldSpec = _.find(packetSpecOrId.packetFields, { fieldId }); } return packetFieldSpec; }, /** * Gets the raw value of a packet field from a buffer. * * @param {PacketFieldSpecification} packetField PacketFieldSpecification object * @param {Buffer} buffer Buffer object * @param {number} [start=0] Start index in the buffer * @param {number} [end=buffer.length] End index in the buffer * @returns {number} Raw value * * @example * &gt; var packetFieldSpec = spec.getPacketFieldSpecification('01_0010_7721_10_0100_000_2_0'); * undefined * &gt; var buffer = Buffer.from('b822', 'hex'); * undefined * &gt; console.log(spec.getRawValue(packetFieldSpec, buffer)); * 888.8000000000001 * undefined * &gt; */ getRawValue(packetField, buffer, start, end) { if (start === undefined) { start = 0; } if (end === undefined) { end = buffer ? buffer.length : 0; } let rawValue; if (packetField &amp;&amp; packetField.getRawValue) { rawValue = packetField.getRawValue(buffer, start, end); } else if (packetField &amp;&amp; packetField.packetFieldSpec) { rawValue = this.getRawValue(packetField.packetFieldSpec, buffer, start, end); if (_.isNumber(rawValue)) { if (packetField.conversions) { rawValue = this.convertRawValue(rawValue, packetField.conversions).rawValue; } else { rawValue = this.convertRawValue(rawValue, packetField.packetFieldSpec.type.unit, packetField.type.unit).rawValue; } } } else { rawValue = null; } return rawValue; }, getRoundedRawValue(packetField, buffer, start, end) { const rawValue = this.getRawValue(packetField, buffer, start, end); const precision = (packetField &amp;&amp; packetField.type &amp;&amp; packetField.type.precision) || 0; const roundedRawValue = roundNumber(rawValue, -precision); return roundedRawValue; }, invertConversions(conversions) { if (!_.isArray(conversions)) { return conversions; } return _.map(conversions.reverse(), (conversion) =&gt; { const invertedConversion = {}; if (_.isNumber(conversion.offset)) { invertedConversion.offset = conversion.offset * -1; } if (_.isNumber(conversion.factor)) { invertedConversion.factor = 1 / conversion.factor; } if (_.isNumber(conversion.power)) { if (conversion.power !== 0) { invertedConversion.power = 1 / conversion.power; } else { invertedConversion.power = conversion.power; } } if (conversion.sourceUnit) { invertedConversion.targetUnit = conversion.sourceUnit; } if (conversion.targetUnit) { invertedConversion.sourceUnit = conversion.targetUnit; } return invertedConversion; }); }, setRawValue(packetField, rawValue, buffer, start, end) { if (start === undefined) { start = 0; } if (end === undefined) { end = buffer ? buffer.length : 0; } if (packetField &amp;&amp; packetField.setRawValue) { packetField.setRawValue(rawValue, buffer, start, end); } else if (packetField &amp;&amp; packetField.packetFieldSpec) { if (_.isNumber(rawValue)) { if (packetField.conversions) { rawValue = this.convertRawValue(rawValue, this.invertConversions(packetField.conversions)).rawValue; } else { rawValue = this.convertRawValue(rawValue, packetField.type.unit, packetField.packetFieldSpec.type.unit).rawValue; } } this.setRawValue(packetField.packetFieldSpec, rawValue, buffer, start, end); } }, /** * Converts a raw number value from one unit to another. The units must be in the same unit family. * * @param {number} rawValue Raw number value to convert from * @param {Unit} sourceUnit Unit to convert from * @param {Unit} targetUnit Unit to convert to * @return {object} Result containing a `rawValue` property with the conversion result and a `unit` property with the associated unit. */ convertRawValue(rawValue_, sourceUnit_, targetUnit_) { const that = this; let conversions; if (_.isArray(sourceUnit_)) { conversions = sourceUnit_; } else { conversions = [{ power: null, factor: null, offset: null, sourceUnit: sourceUnit_, targetUnit: targetUnit_, }]; } const result = _.reduce(conversions, (valueInfo, conversion) =&gt; { let rawValue = valueInfo.rawValue; const sourceUnit = conversion.sourceUnit; const targetUnit = conversion.targetUnit; const unitFamily = sourceUnit &amp;&amp; sourceUnit.unitFamily; const hasPower = _.isNumber(conversion.power); const hasFactor = _.isNumber(conversion.factor); const hasOffset = _.isNumber(conversion.offset); const autoConvert = !hasFactor &amp;&amp; !hasOffset &amp;&amp; !hasPower; if (hasPower) { if (rawValue === 0 &amp;&amp; conversion.power &lt; 0) { rawValue = 0; // Infinity } else { rawValue = Math.pow(rawValue, conversion.power); } } if (hasFactor) { rawValue = rawValue * conversion.factor; } if (hasOffset) { rawValue = rawValue + conversion.offset; } if (autoConvert &amp;&amp; !sourceUnit) { throw new Error('Must provide a source unit'); } else if (!targetUnit) { // nop, no conversion requested } else if (sourceUnit.unitCode === targetUnit.unitCode) { // nop, no conversion for same unit } else if (targetUnit.unitCode === 'None') { // nop, just ignore the unit suffix } else if (!autoConvert) { // nop, already multiplied by factor above and allows to change unit family } else if (unitFamily !== targetUnit.unitFamily) { throw new Error('Unit families of source and target unit must match'); } else if (!unitFamily) { // nop, no conversion for unknown unit family } else if (unitFamily === 'Temperature') { rawValue = that._convertTemperatureRawValue(rawValue, sourceUnit.unitCode, targetUnit.unitCode); } else if (unitFamily === 'Volume') { rawValue = that._convertVolumeRawValue(rawValue, sourceUnit.unitCode, targetUnit.unitCode); } else if (unitFamily === 'VolumeFlow') { rawValue = that._convertVolumeFlowRawValue(rawValue, sourceUnit.unitCode, targetUnit.unitCode); } else if (unitFamily === 'Pressure') { rawValue = that._convertPressureRawValue(rawValue, sourceUnit.unitCode, targetUnit.unitCode); } else if (unitFamily === 'Energy') { rawValue = that._convertEnergyRawValue(rawValue, sourceUnit.unitCode, targetUnit.unitCode); } else if (unitFamily === 'Power') { rawValue = that._convertPowerRawValue(rawValue, sourceUnit.unitCode, targetUnit.unitCode); } else if (unitFamily === 'Time') { rawValue = that._convertTimeRawValue(rawValue, sourceUnit.unitCode, targetUnit.unitCode); } else { throw new Error('Unsupported unit family ' + JSON.stringify(sourceUnit.unitFamily)); } return { rawValue, unit: targetUnit || sourceUnit, }; }, { rawValue: rawValue_, unit: sourceUnit_, }); return result; }, _convertTemperatureRawValue(rawValue, sourceUnitCode, targetUnitCode) { switch (sourceUnitCode) { case 'DegreesCelsius': // nop break; case 'DegreesFahrenheit': rawValue = (rawValue - 32) / 1.8; break; default: throw new Error('Unsupported source unit ' + JSON.stringify(sourceUnitCode)); } switch (targetUnitCode) { case 'DegreesCelsius': // nop break; case 'DegreesFahrenheit': rawValue = (rawValue * 1.8) + 32; break; default: throw new Error('Unsupported target unit ' + JSON.stringify(targetUnitCode)); } return rawValue; }, _convertVolumeRawValue(rawValue, sourceUnitCode, targetUnitCode) { switch (sourceUnitCode) { case 'Liters': // nop break; case 'CubicMeters': rawValue = rawValue * 1000; break; case 'Gallons': rawValue = rawValue / conversionFactors.GallonsPerLiter; break; default: throw new Error('Unsupported source unit ' + JSON.stringify(sourceUnitCode)); } switch (targetUnitCode) { case 'Liters': // nop break; case 'CubicMeters': rawValue = rawValue / 1000; break; case 'Gallons': rawValue = rawValue * conversionFactors.GallonsPerLiter; break; default: throw new Error('Unsupported target unit ' + JSON.stringify(targetUnitCode)); } return rawValue; }, _convertVolumeFlowRawValue(rawValue, sourceUnitCode, targetUnitCode) { switch (sourceUnitCode) { case 'LitersPerHour': // nop break; case 'LitersPerMinute': rawValue = rawValue * 60; break; case 'CubicMetersPerHour': rawValue = rawValue * 1000; break; case 'GallonsPerHour': rawValue = rawValue / conversionFactors.GallonsPerLiter; break; case 'GallonsPerMinute': rawValue = rawValue * 60 / conversionFactors.GallonsPerLiter; break; default: throw new Error('Unsupported source unit ' + JSON.stringify(sourceUnitCode)); } switch (targetUnitCode) { case 'LitersPerHour': // nop break; case 'LitersPerMinute': rawValue = rawValue / 60; break; case 'CubicMetersPerHour': rawValue = rawValue / 1000; break; case 'GallonsPerHour': rawValue = rawValue * conversionFactors.GallonsPerLiter; break; case 'GallonsPerMinute': rawValue = rawValue / 60 * conversionFactors.GallonsPerLiter; break; default: throw new Error('Unsupported target unit ' + JSON.stringify(targetUnitCode)); } return rawValue; }, _convertPressureRawValue(rawValue, sourceUnitCode, targetUnitCode) { switch (sourceUnitCode) { case 'Bars': // nop break; case 'PoundsForcePerSquareInch': rawValue = rawValue / conversionFactors.PoundsForcePerSquareInchPerBar; break; default: throw new Error('Unsupported source unit ' + JSON.stringify(sourceUnitCode)); } switch (targetUnitCode) { case 'Bars': // nop break; case 'PoundsForcePerSquareInch': rawValue = rawValue * conversionFactors.PoundsForcePerSquareInchPerBar; break; default: throw new Error('Unsupported target unit ' + JSON.stringify(targetUnitCode)); } return rawValue; }, _convertEnergyRawValue(rawValue, sourceUnitCode, targetUnitCode) { switch (sourceUnitCode) { case 'WattHours': // nop break; case 'KilowattHours': rawValue = rawValue * 1000; break; case 'MegawattHours': rawValue = rawValue * 1000000; break; case 'Btus': rawValue = rawValue / conversionFactors.BtusPerWattHour; break; case 'KiloBtus': rawValue = rawValue * 1000 / conversionFactors.BtusPerWattHour; break; case 'MegaBtus': rawValue = rawValue * 1000000 / conversionFactors.BtusPerWattHour; break; case 'GramsCO2Gas': rawValue = rawValue / conversionFactors.GramsCO2GasPerWattHour; break; case 'KilogramsCO2Gas': rawValue = rawValue * 1000 / conversionFactors.GramsCO2GasPerWattHour; break; case 'TonsCO2Gas': rawValue = rawValue * 1000000 / conversionFactors.GramsCO2GasPerWattHour; break; case 'GramsCO2Oil': rawValue = rawValue / conversionFactors.GramsCO2OilPerWattHour; break; case 'KilogramsCO2Oil': rawValue = rawValue * 1000 / conversionFactors.GramsCO2OilPerWattHour; break; case 'TonsCO2Oil': rawValue = rawValue * 1000000 / conversionFactors.GramsCO2OilPerWattHour; break; default: throw new Error('Unsupported source unit ' + JSON.stringify(sourceUnitCode)); } switch (targetUnitCode) { case 'WattHours': // nop break; case 'KilowattHours': rawValue = rawValue / 1000; break; case 'MegawattHours': rawValue = rawValue / 1000000; break; case 'Btus': rawValue = rawValue * conversionFactors.BtusPerWattHour; break; case 'KiloBtus': rawValue = rawValue / 1000 * conversionFactors.BtusPerWattHour; break; case 'MegaBtus': rawValue = rawValue / 1000000 * conversionFactors.BtusPerWattHour; break; case 'GramsCO2Gas': rawValue = rawValue * conversionFactors.GramsCO2GasPerWattHour; break; case 'KilogramsCO2Gas': rawValue = rawValue / 1000 * conversionFactors.GramsCO2GasPerWattHour; break; case 'TonsCO2Gas': rawValue = rawValue / 1000000 * conversionFactors.GramsCO2GasPerWattHour; break; case 'GramsCO2Oil': rawValue = rawValue * conversionFactors.GramsCO2OilPerWattHour; break; case 'KilogramsCO2Oil': rawValue = rawValue / 1000 * conversionFactors.GramsCO2OilPerWattHour; break; case 'TonsCO2Oil': rawValue = rawValue / 1000000 * conversionFactors.GramsCO2OilPerWattHour; break; default: throw new Error('Unsupported target unit ' + JSON.stringify(targetUnitCode)); } return rawValue; }, _convertPowerRawValue(rawValue, sourceUnitCode, targetUnitCode) { switch (sourceUnitCode) { case 'Watts': // nop break; case 'Kilowatts': rawValue = rawValue * 1000; break; default: throw new Error('Unsupported source unit ' + JSON.stringify(sourceUnitCode)); } switch (targetUnitCode) { case 'Watts': // nop break; case 'Kilowatts': rawValue = rawValue / 1000; break; default: throw new Error('Unsupported target unit ' + JSON.stringify(targetUnitCode)); } return rawValue; }, _convertTimeRawValue(rawValue, sourceUnitCode, targetUnitCode) { switch (sourceUnitCode) { case 'Seconds': // nop break; case 'Minutes': rawValue = rawValue * 60; break; case 'Hours': rawValue = rawValue * 3600; break; case 'Days': rawValue = rawValue * 86400; break; default: throw new Error('Unsupported source unit ' + JSON.stringify(sourceUnitCode)); } switch (targetUnitCode) { case 'Seconds': // nop break; case 'Minutes': rawValue = rawValue / 60; break; case 'Hours': rawValue = rawValue / 3600; break; case 'Days': rawValue = rawValue / 86400; break; default: throw new Error('Unsupported target unit ' + JSON.stringify(targetUnitCode)); } return rawValue; }, /** * Formats a raw value into its textual representation. * * @param {PacketFieldSpecification} packetField PacketFieldSpecification object * @param {number} rawValue Raw value * @param {string|UnitSpecification|null} [unit] Unit to format to * @returns {string} Textual representation of the raw value * * @example * &gt; var packetFieldSpec = spec.getPacketFieldSpecification('01_0010_7721_10_0100_000_2_0'); * undefined * &gt; var rawValue = 888.8000000000001; * undefined * &gt; console.log(spec.formatTextValueFromRawValue(packetFieldSpec, rawValue, 'DegreesCelsius')); * 888.8 °C * undefined * &gt; */ formatTextValueFromRawValue(packetField, rawValue, unit) { let textValue; if ((rawValue !== undefined) &amp;&amp; (rawValue !== null)) { if (typeof unit === 'string') { if (_.has(this.specificationData.units, unit)) { unit = this.specificationData.units [unit]; } else { throw new Error('Unknown unit named \"' + unit + '\"'); } } if (packetField &amp;&amp; packetField.type) { const type = packetField.type; if (type.formatTextValue) { textValue = type.formatTextValue(rawValue, unit); } else { textValue = this.formatTextValueFromRawValueInternal(rawValue, unit, type.rootTypeId, type.precision, type.unit); } } else { textValue = rawValue.toString(); if (unit &amp;&amp; unit.unitText) { textValue += unit.unitText; } } } else { textValue = ''; } return textValue; }, formatTextValueFromRawValueInternal(rawValue, unit, rootType, precision, defaultUnit) { const unitText = unit ? unit.unitText : defaultUnit ? defaultUnit.unitText : ''; let result, textValue, format; if ((rawValue === undefined) || (rawValue === null)) { result = ''; } else if (rootType === 'Time') { textValue = this.i18n.moment(rawValue * 60000).utc().format('HH:mm'); result = textValue + unitText; } else if (rootType === 'Weektime') { textValue = this.i18n.moment((rawValue + 5760) * 60000).utc().format('dd,HH:mm'); result = textValue + unitText; } else if (rootType === 'DateTime') { textValue = this.i18n.moment((rawValue + 978307200) * 1000).utc().format('L HH:mm:ss'); result = textValue + unitText; } else if (precision === 0) { textValue = this.i18n.numeral(rawValue).format('0'); result = textValue + unitText; } else if (precision === 1) { textValue = this.i18n.numeral(rawValue).format('0.0'); result = textValue + unitText; } else if (precision === 2) { textValue = this.i18n.numeral(rawValue).format('0.00'); result = textValue + unitText; } else if (precision === 3) { textValue = this.i18n.numeral(rawValue).format('0.000'); result = textValue + unitText; } else if (precision === 4) { textValue = this.i18n.numeral(rawValue).format('0.0000'); result = textValue + unitText; } else { if (!_.has(numberFormatCache, precision)) { format = '0.'; for (let i = 0; i &lt; precision; i++) { format = format + '0'; } numberFormatCache [precision] = format; } textValue = this.i18n.numeral(rawValue).format(numberFormatCache [precision]); result = textValue + unitText; } return result; }, /** * Gets an array of PacketField objects for the provided Packet objects. * * @param {Header[]} headers Array of Header objects * @returns {PacketField[]} Array of PacketField objects */ getPacketFieldsForHeaders(headers) { const _this = this; // filter out all packets const packets = _.reduce(headers, (memo, header) =&gt; { if ((header.getProtocolVersion() &amp; 0xF0) === 0x10) { memo.push(header); } return memo; }, []); const packetFields = []; const filteredPacketFieldSpecs = this.specificationData.filteredPacketFieldSpecs; if (filteredPacketFieldSpecs) { const packetById = _.reduce(packets, (memo, packet) =&gt; { const packetSpec = _this.getPacketSpecification(packet); memo [packetSpec.packetId] = packet; return memo; }, {}); _.forEach(filteredPacketFieldSpecs, (fpfs) =&gt; { const packetField = _.extend({}, { id: fpfs.filteredPacketFieldId, packet: packetById [fpfs.packetId], packetSpec: fpfs.packetSpec, packetFieldSpec: fpfs, origPacketFieldSpec: fpfs.packetFieldSpec, }); packetFields.push(packetField); }); } else { _.forEach(packets, (packet) =&gt; { const packetSpec = _this.getPacketSpecification(packet); if (packetSpec) { _.forEach(packetSpec.packetFields, (packetFieldSpec) =&gt; { const packetField = { id: packetSpec.packetId + '_' + packetFieldSpec.fieldId, packet, packetSpec, packetFieldSpec, origPacketFieldSpec: packetFieldSpec, }; packetFields.push(packetField); }); } }); } const language = this.language; _.forEach(packetFields, (packetField) =&gt; { const pfsName = packetField.packetFieldSpec.name; let name; if (_.isString(pfsName)) { name = pfsName; } else if (_.isObject(pfsName)) { name = pfsName [language] || pfsName.en || pfsName.de || pfsName.ref; } let rawValue; if (packetField.packetFieldSpec &amp;&amp; packetField.packet) { const frameData = packetField.packet.frameData.slice(0, packetField.packet.frameCount * 4); rawValue = _this.getRawValue(packetField.packetFieldSpec, frameData); } let precision; if (packetField.packetFieldSpec &amp;&amp; packetField.packetFieldSpec.type) { precision = packetField.packetFieldSpec.type.precision || 0; } _.extend(packetField, { name, rawValue, formatTextValue(unit) { return _this.formatTextValueFromRawValue(packetField.packetFieldSpec, rawValue, unit); }, getRoundedRawValue() { return roundNumber(rawValue, -precision); }, }); }); return packetFields; }, setPacketFieldRawValues(packetFields, rawValues) { const _this = this; const packetFieldById = _.reduce(packetFields, (memo, packetField) =&gt; { memo [packetField.id] = packetField; const fieldId = packetField.packetFieldSpec.fieldId; if (memo [fieldId] === undefined) { memo [fieldId] = packetField; } else { memo [fieldId] = null; } return memo; }, {}); _.forEach(rawValues, (rawValue, key) =&gt; { const packetField = packetFieldById [key]; if (packetField === undefined) { throw new Error('Unknown raw value ID ' + JSON.stringify(key)); } else if (packetField === null) { throw new Error('Non-unique raw value ID ' + JSON.stringify(key)); } else { const frameData = packetField.packet.frameData.slice(0, packetField.packet.frameCount * 4); _this.setRawValue(packetField.packetFieldSpec, rawValue, frameData); } }); }, getFilteredPacketFieldSpecificationsForHeaders(headers) { const filteredPacketFieldSpecs = []; const packetFields = this.getPacketFieldsForHeaders(headers); _.forEach(packetFields, (packetField) =&gt; { const packetSpec = packetField.packetSpec; const packetFieldSpec = packetField.packetFieldSpec; if (packetSpec &amp;&amp; packetFieldSpec) { const filteredPacketFieldSpec = _.extend({}, packetFieldSpec, { filteredPacketFieldId: packetSpec.packetId + '_' + packetFieldSpec.fieldId, packetId: packetSpec.packetId, name: packetField.name, }); filteredPacketFieldSpecs.push(filteredPacketFieldSpec); } }); return filteredPacketFieldSpecs; }, /** * Gets an array of BlockType sections from a collection of headers. * * @param {Header[]} headers Array of Header objects * @return {BlockTypeSection[]} Array of BlockTypeSection objects */ getBlockTypeSectionsForHeaders(headers) { const _this = this; return _.reduce(headers, (memo, header) =&gt; { if (((header.getProtocolVersion() &amp; 0xF0) === 0x10) &amp;&amp; (header.destinationAddress === 0x0015) &amp;&amp; (header.command === 0x0100)) { const packetSpec = _this.getPacketSpecification(header); const length = header.frameCount * 4, frameData = header.frameData; let startOffset = 0; while (startOffset + 4 &lt;= length) { const frameCount = frameData [startOffset] &amp; 255; const endOffset = startOffset + 4 + 4 * frameCount; if (endOffset &lt;= length) { const type = frameData [startOffset + 1] &amp; 255; let payloadSize = null, payloadCount = null; // TODO(daniel): refine the payload count based on the type if (type === 1) { payloadSize = 2; } else if (type === 5) { payloadSize = 4; } else if (type === 8) { payloadSize = 1; } else if (type === 10) { payloadSize = 8; } else if (type === 11) { payloadSize = 4; } else if (type === 12) { payloadSize = 4; } else if (type === 13) { payloadSize = 4; } else if (type === 14) { payloadSize = 1; } else { payloadSize = 1; } if (!payloadCount &amp;&amp; payloadSize) { payloadCount = Math.floor((endOffset - startOffset - 4) / payloadSize); } const sectionId = sprintf('%s_%02X_%02X_%d', packetSpec.packetId, frameCount, type, payloadCount); const shasum = crypto.createHash('sha1'); shasum.update(Buffer.from(sectionId, 'utf8')); const surrogatePacketIdHash = shasum.digest('hex').toUpperCase(); const surrogatePacketIdHashPart1 = surrogatePacketIdHash.slice(0, 4); const surrogatePacketIdHashPart2 = surrogatePacketIdHash.slice(4, 8); const surrogatePacketId = sprintf('%02X_%04X_%s_%02X_%s', header.channel, header.destinationAddress | 0x8000, surrogatePacketIdHashPart1, 0x10, surrogatePacketIdHashPart2); memo.push({ sectionId, surrogatePacketId, packet: header, packetSpec, startOffset, endOffset, type, payloadCount, frameCount, frameData: frameData.slice(startOffset, endOffset), }); } startOffset = endOffset; } if (startOffset !== length) { throw new Error('Malformed block type packet, ending prematurely at offset ' + startOffset); } } return memo; }, []); }, _createUInt8BlockTypeFieldSpecification(fieldIdPrefix, offset, name, typeId, factor) { return { fieldId: sprintf('%s_%03d_1_0', fieldIdPrefix, offset), name, type: this.getTypeById(typeId), factor, parts: [{ offset, mask: 255, isSigned: false, factor: 1, }], getRawValue(buffer, start, end) { let rawValue = 0, valid = false; if (start + offset &lt; end) { rawValue += buffer.readUInt8(start + offset); valid = true; } if (valid) { rawValue = rawValue * factor; } else { rawValue = null; } return rawValue; }, setRawValue(newValue, buffer, start, end) { newValue = Math.round(newValue / factor); let rawValue; if (start + offset &lt; end) { rawValue = newValue &amp; 255; buffer.writeUInt8(rawValue, start + offset); } }, }; }, _createInt16BlockTypeFieldSpecification(fieldIdPrefix, offset, name, typeId, factor) { return { fieldId: sprintf('%s_%03d_2_0', fieldIdPrefix, offset), name, type: this.getTypeById(typeId), factor, parts: [{ offset, mask: 255, isSigned: false, factor: 1, }, { offset: offset + 1, mask: 255, isSigned: true, factor: 256, }], getRawValue(buffer, start, end) { let rawValue = 0, valid = false; if (start + offset &lt; end) { rawValue += buffer.readUInt8(start + offset); valid = true; } if (start + offset + 1 &lt; end) { rawValue += buffer.readInt8(start + offset + 1) * 256; valid = true; } if (valid) { rawValue = rawValue * factor; } else { rawValue = null; } return rawValue; }, setRawValue(newValue, buffer, start, end) { newValue = Math.round(newValue / factor); let rawValue; if (start + offset &lt; end) { rawValue = newValue &amp; 255; buffer.writeUInt8(rawValue, start + offset); } if (start + offset + 1 &lt; end) { rawValue = (newValue / 256) &amp; 255; buffer.writeUInt8(rawValue, start + offset + 1); } }, }; }, _createUInt32BlockTypeFieldSpecification(fieldIdPrefix, offset, name, typeId, factor) { return { fieldId: sprintf('%s_%03d_4_0', fieldIdPrefix, offset), name, type: this.getTypeById(typeId), factor, parts: [{ offset, mask: 255, isSigned: false, factor: 1, }, { offset: offset + 1, mask: 255, isSigned: false, factor: 256, }, { offset: offset + 2, mask: 255, isSigned: false, factor: 65536, }, { offset: offset + 3, mask: 255, isSigned: false, factor: 16777216, }], getRawValue(buffer, start, end) { let rawValue = 0, valid = false; if (start + offset &lt; end) { rawValue += buffer.readUInt8(start + offset); valid = true; } if (start + offset + 1 &lt; end) { rawValue += buffer.readUInt8(start + offset + 1) * 256; valid = true; } if (start + offset + 2 &lt; end) { rawValue += buffer.readUInt8(start + offset + 2) * 65536; valid = true; } if (start + offset + 3 &lt; end) { rawValue += buffer.readUInt8(start + offset + 3) * 16777216; valid = true; } if (valid) { rawValue = rawValue * factor; } else { rawValue = null; } return rawValue; }, setRawValue(newValue, buffer, start, end) { newValue = Math.round(newValue / factor); let rawValue; if (start + offset &lt; end) { rawValue = newValue &amp; 255; buffer.writeUInt8(rawValue, start + offset); } if (start + offset + 1 &lt; end) { rawValue = (newValue / 256) &amp; 255; buffer.writeUInt8(rawValue, start + offset + 1); } if (start + offset + 2 &lt; end) { rawValue = (newValue / 65536) &amp; 255; buffer.writeUInt8(rawValue, start + offset + 2); } if (start + offset + 3 &lt; end) { rawValue = (newValue / 16777216) &amp; 255; buffer.writeUInt8(rawValue, start + offset + 3); } }, }; }, /** * Gets the PacketSpecification objects matching the given BlockTypeSection objects. * * @param {BlockTypeSection[]} sections Array of BlockTypeSection objects * @return {PacketSpecification[]} Array of PacketSpecificationObjects */ getBlockTypePacketSpecificationsForSections(sections) { const _this = this; return _.reduce(sections, (memo, section) =&gt; { const sectionId = section.sectionId; if (!_.has(_this.blockTypePacketSpecCache, sectionId)) { const fieldIdPrefix = section.sectionId; const forEachPayload = function(iterator) { const count = section.payloadCount; for (let i = 0; i &lt; count; i++) { const suffix = (count &gt; 1) ? (' ' + (i + 1)) : ''; iterator(i, suffix); } }; const packetFieldSpecs = []; if (section.type === 1) { // temperatures forEachPayload((index, suffix) =&gt; { packetFieldSpecs.push(_this._createInt16BlockTypeFieldSpecification(fieldIdPrefix, 4 + index * 2, 'Temperatur Sensor' + suffix, 'Number_0_1_DegreesCelsius', 0.1)); }); } else if (section.type === 5) { forEachPayload((index, suffix) =&gt; { packetFieldSpecs.push(_this._createUInt32BlockTypeFieldSpecification(fieldIdPrefix, 4 + index * 4, 'Wärmemenge' + suffix, 'Number_1_WattHours', 1)); }); } else if (section.type === 8) { // Relais speeds forEachPayload((index, suffix) =&gt; { packetFieldSpecs.push(_this._createUInt8BlockTypeFieldSpecification(fieldIdPrefix, 4 + index, 'Drehzahl Relais' + suffix, 'Number_1_Percent', 1)); }); } else if (section.type === 10) { // SmartDisplay forEachPayload((index, suffix) =&gt; { packetFieldSpecs.push(_this._createInt16BlockTypeFieldSpecification(fieldIdPrefix, 4 + index * 8, 'Temperatur Kollektor' + suffix, 'Number_0_1_DegreesCelsius', 0.1)); packetFieldSpecs.push(_this._createInt16BlockTypeFieldSpecification(fieldIdPrefix, 6 + index * 8, 'Temperatur Speicher' + suffix, 'Number_0_1_DegreesCelsius', 0.1)); packetFieldSpecs.push(_this._createUInt32BlockTypeFieldSpecification(fieldIdPrefix, 8 + index * 8, 'Wärmemenge' + suffix, 'Number_1_WattHours', 1)); }); } else if (section.type === 11) { forEachPayload((index, suffix) =&gt; { packetFieldSpecs.push(_this._createUInt32BlockTypeFieldSpecification(fieldIdPrefix, 4 + index * 4, 'Fehlermaske' + suffix, 'Number_1_None', 1)); }); } else if (section.type === 12) { forEachPayload((index, suffix) =&gt; { packetFieldSpecs.push(_this._createUInt32BlockTypeFieldSpecification(fieldIdPrefix, 4 + index * 4, 'Warnungsmaske' + suffix, 'Number_1_None', 1)); }); } else if (section.type === 13) { forEachPayload((index, suffix) =&gt; { packetFieldSpecs.push(_this._createUInt32BlockTypeFieldSpecification(fieldIdPrefix, 4 + index * 4, 'Statusmaske' + suffix, 'Number_1_None', 1)); }); } else if (section.type === 14) { forEachPayload((index, suffix) =&gt; { packetFieldSpecs.push(_this._createUInt8BlockTypeFieldSpecification(fieldIdPrefix, 4 + index, 'Segmentmaske' + suffix, 'Number_1_None', 1)); }); } _this.blockTypePacketSpecCache [sectionId] = _.extend({}, section.packetSpec, { packetId: section.surrogatePacketId, sectionId, packetFields: packetFieldSpecs, }); } const packetSpec = _this.blockTypePacketSpecCache [sectionId]; memo.push(packetSpec); return memo; }, []); }, /** * Gets an array of PacketField objects for the provided BlockTypeSection objects. * * @param {BlockTypeSection[]} sections Array of BlockTypeSection objects. * @return {PacketField[]} Array of PacketField objects */ getBlockTypeFieldsForSections(sections) { const _this = this; const sectionByBlockTypeId = _.reduce(sections, (memo, section) =&gt; { memo [section.sectionId] = section; return memo; }, {}); const packetSpecs = this.getBlockTypePacketSpecificationsForSections(sections); const packetFields = []; _.forEach(packetSpecs, (packetSpec) =&gt; { _.forEach(packetSpec.packetFields, (packetFieldSpec) =&gt; { const section = sectionByBlockTypeId [packetSpec.sectionId]; const packetField = { id: packetSpec.packetId + '_' + packetFieldSpec.fieldId, section, packet: section.packet, packetSpec, packetFieldSpec, origPacketFieldSpec: packetFieldSpec, }; packetFields.push(packetField); }); }); const language = this.language; _.forEach(packetFields, (packetField) =&gt; { const pfsName = packetField.packetFieldSpec.name; let name; if (_.isString(pfsName)) { const key = 'specificationData.packetFieldName.' + pfsName; name = _this.i18n.t(key); if (name === key) { name = pfsName; } } else if (_.isObject(pfsName)) { name = pfsName [language] || pfsName.en || pfsName.de || pfsName.ref; } let rawValue; if (packetField.packetFieldSpec &amp;&amp; packetField.section) { const frameData = packetField.section.frameData; rawValue = _this.getRawValue(packetField.packetFieldSpec, frameData); } _.extend(packetField, { name, rawValue, formatTextValue(unit) { return _this.formatTextValueFromRawValue(packetField.packetFieldSpec, rawValue, unit); }, }); }); return packetFields; }, }, { loadSpecificationData(rawSpecificationData, options) { if (rawSpecificationData === undefined) { rawSpecificationData = {}; } if (options === undefined) { options = {}; } const rawFilteredPacketFieldSpecs = rawSpecificationData.filteredPacketFieldSpecs; const specification = options.specification || globalSpecification || {}; const specificationData = options.specificationData || specification.specificationData || globalSpecificationData || {}; let filteredPacketFieldSpecs; if (rawFilteredPacketFieldSpecs) { const resolve = function(value, collectionKey) { const collection = specificationData [collectionKey]; if (_.has(collection, value)) { value = collection [value]; } return value; }; filteredPacketFieldSpecs = _.map(rawFilteredPacketFieldSpecs, (rfpfs) =&gt; { const packetSpec = specification.getPacketSpecification(rfpfs.packetId); const packetFieldSpec = specification.getPacketFieldSpecification(packetSpec, rfpfs.fieldId); let name = rfpfs.name; if (typeof name === 'string') { name = { ref: name }; } return _.extend({}, rfpfs, { packetSpec, packetFieldSpec, name, type: resolve(rfpfs.type, 'types'), conversions: rfpfs.conversions &amp;&amp; _.map(rfpfs.conversions, (rawConversion) =&gt; { return { factor: rawConversion.factor, offset: rawConversion.offset, sourceUnit: rawConversion.sourceUnit &amp;&amp; resolve(rawConversion.sourceUnit, 'units'), targetUnit: rawConversion.targetUnit &amp;&amp; resolve(rawConversion.targetUnit, 'units'), }; }), getRawValue: resolve(rfpfs.getRawValue, 'getRawValueFunctions'), setRawValue: resolve(rfpfs.setRawValue, 'setRawValueFunctions'), }); }); } const result = _.extend({}, specificationData, { filteredPacketFieldSpecs, }); return result; }, storeSpecificationData(options) { if (options === undefined) { options = {}; } if (options instanceof Specification) { options = { specification: options }; } const specification = options.specification || globalSpecification || {}; const specificationData = options.specificationData || specification.specificationData || globalSpecificationData || {}; const filteredPacketFieldSpecs = options.filteredPacketFieldSpecs || specificationData.filteredPacketFieldSpecs; let rawFilteredPacketFieldSpecs; if (filteredPacketFieldSpecs) { const link = function(value, valueIdKey, collectionKey) { const collection = specificationData [collectionKey]; let valueId; if (valueIdKey) { valueId = value [valueIdKey]; } if (!valueId) { valueId = _.findKey(collection, (refValue) =&gt; { return (value === refValue); }); } if (valueId &amp;&amp; _.has(collection, valueId) &amp;&amp; (collection [valueId] === value)) { value = valueId; } return value; }; rawFilteredPacketFieldSpecs = _.map(filteredPacketFieldSpecs, (fpfs) =&gt; { const rfpfs = { filteredPacketFieldId: fpfs.filteredPacketFieldId, packetId: fpfs.packetId, fieldId: fpfs.fieldId, name: fpfs.name, type: link(fpfs.type, 'typeId', 'types'), getRawValue: link(fpfs.getRawValue, null, 'getRawValueFunctions'), setRawValue: link(fpfs.setRawValue, null, 'setRawValueFunctions'), }; if (fpfs.conversions) { rfpfs.conversions = _.map(fpfs.conversions, (conversion) =&gt; { const rawConversion = {}; if (_.isNumber(conversion.factor)) { rawConversion.factor = conversion.factor; } if (_.isNumber(conversion.offset)) { rawConversion.offset = conversion.offset; } if (conversion.sourceUnit) { rawConversion.sourceUnit = link(conversion.sourceUnit, 'unitId', 'units'); } if (conversion.targetUnit) { rawConversion.targetUnit = link(conversion.targetUnit, 'unitId', 'units'); } return rawConversion; }); } return rfpfs; }); } const rawSpecificationData = { filteredPacketFieldSpecs: rawFilteredPacketFieldSpecs, }; return rawSpecificationData; }, getDefaultSpecification() { return globalSpecification; }, }); globalSpecification = new Specification(); module.exports = Specification; × Search results Close "},"configuration-optimizer.js.html":{"id":"configuration-optimizer.js.html","title":"Source: configuration-optimizer.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: configuration-optimizer.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const extend = require('./extend'); /** * @typedef ConfigurationValue * @type {object} * @property {String} valueId Value ID * @property {number} valueIndex Value Index * @property {number} value Value * @property {number} priority Priority (higher numbers mean higher priority) * @property {boolean} pending Indicates that this value has to be tranceived. * @property {boolean} transceived Indicates that this value has been tranceived. */ /** * @typedef Configuration * @type {ConfigurationValue[]} */ const ConfigurationOptimizer = extend(null, /** @lends ConfigurationOptimizer# */ { constructor(options) { // nop }, /** * Converts the configurations provided into an array of {@see ConfigurationValue} objects. * The provided configurations can be either an array of partially initialized ConfigurationValue * objects or an object mapping value IDs as keys to values. * If no configuration is given a complete configuration set is returned. * * @param {array|object} configs... Configurations to complete. * @returns {Promise} A Promise that resolves to the completed array of values. */ completeConfiguration(config) { throw new Error('Must be implemented by sub-class'); }, /** * Gets the optimized array of values based on what values are already loaded. * * @param {array} config The array of values that has already been loaded. * @returns {Promise} A Promise that resolves to the array of values to load next. */ optimizeLoadConfiguration(config) { throw new Error('Must be implemented by sub-class'); }, /** * Gets the optimzed array of values to save to the controller. * * @param {array} newConfig The array of values to transfer. * @param {array} oldConfig The array of values that are assumed to be currently stored in the device. * @returns {Promise} A Promise that resolves to the array of values to save. */ optimizeSaveConfiguration(newConfig, oldConfig) { throw new Error('Must be implemented by sub-class'); }, /** * Get the array of `ConfigurationValue` objects to set the current date / time to the controller. * * @param {string} timezone Timezone the controller is in * @return {Promise} A Promise that resolves to the array of values to set the clock. */ generateClockConfiguration(timezone) { throw new Error('Must be implemented by sub-class'); }, }, { deviceAddress: null, /** * Get an array of possible options for calling this `ConfigurationOptimizer`'s constructor. * * @return {Promise} A promise that resolves to an array of constructor options. */ async getOptimizerOptions() { if (this.deviceAddress !== null) { return [ null ]; } else { throw new Error('Must be implemented by sub-class'); } }, /** * Find settings for this `ConfigurationOptimizer`'s constructor that matches the given options best. * * @param {object} options Options to look for while searching a matching configuration optimizer. * @param {string} options.id The identifier for the `ConfigurationOptimizer`. * @param {number} options.deviceAddress The VBus address of the controller. * @param {string} options.version The version of the controller. * @param {Customizer} options.customizer A `Customizer` instance to query additional information with. * @return {Promise} A Promise that resolves to the best matching optimizer result or `null` if no match was found. */ async matchOptimizer(options) { if (this.deviceAddress !== null) { const match = (options.deviceAddress === this.deviceAddress) ? 1 : 0; return { match, Optimizer: this, options: null, }; } else { throw new Error('Must be implemented by sub-class'); } }, }); module.exports = ConfigurationOptimizer; × Search results Close "},"configuration-optimizer-factory.js.html":{"id":"configuration-optimizer-factory.js.html","title":"Source: configuration-optimizer-factory.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: configuration-optimizer-factory.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const _ = require('./lodash'); const optimizerClasses = [ // ====================================================================== // RESOL // ====================================================================== // DeltaSol BS4 v2 require('./configuration-optimizers/resol-deltasol-bs4v2-103-configuration-optimizer'), // DeltaSol BX Plus require('./configuration-optimizers/resol-deltasol-bx-plus-xxx-configuration-optimizer'), // DeltaSol C require('./configuration-optimizers/resol-deltasol-c-104-configuration-optimizer'), // DeltaSol CS Plus require('./configuration-optimizers/resol-deltasol-cs-plus-xxx-configuration-optimizer'), // DeltaSol MX require('./configuration-optimizers/resol-deltasol-mx-112-configuration-optimizer'), // DeltaSol SLT require('./configuration-optimizers/resol-deltasol-slt-102-configuration-optimizer'), // DeltaTherm HC require('./configuration-optimizers/resol-deltatherm-hc-xxx-configuration-optimizer'), ]; const ConfigurationOptimizerFactory = { /** * Find a `ConfigurationOptimizer` sub-class that matches the given options best. * * @param {object} options Options to look for while searching a matching configuration optimizer. * @param {number} options.deviceAddress The VBus address of the controller. * @param {string} options.version The version of the controller. * @param {Customizer} options.customizer A `Customizer` instance to query additional information with. * @return {Promise} A Promise that resolves to the best matching optimizer result or `null` if no match was found. */ async matchOptimizer(options) { options = _.defaults({}, options); let result = { match: 0, Optimizer: null, options: null, }; const cache = { masterAddress: null, masterConfiguration: [], }; for (const Optimizer of optimizerClasses) { const refResult = await Optimizer.matchOptimizer(options, cache); if ((refResult.match &gt; 0) &amp;&amp; (refResult.match &gt; result.match)) { result = refResult; } } if (result.match &gt; 0) { return result; } else { return null; } }, /** * Find and create an instance of a `ConfigurationOptimizer` sub-class that matches the given options best. * * @param {object} options See {@link ConfigurationOptimizerFactory.matchOptimizer} for details. * @return {Promise} A promise that resolves to the `ConfigurationOptimizer` instance or `null` if no matching optimizer was found. */ async createOptimizer(options) { const result = await ConfigurationOptimizerFactory.matchOptimizer(options); let optimizer; if (result) { optimizer = new result.Optimizer(result.options); } else { optimizer = null; } return optimizer; }, /** * Get the configuration optimizer for the given device (identified by its address). * * @param {number} deviceAddress VBus address of the device * @returns {Promise} A Promise that resolvs to the optimizer for the given device or `null` if no optimizer was found. */ createOptimizerByDeviceAddress(deviceAddress) { return ConfigurationOptimizerFactory.createOptimizer({ deviceAddress, }); }, _optimizerClasses: optimizerClasses, }; module.exports = ConfigurationOptimizerFactory; × Search results Close "},"connection.js.html":{"id":"connection.js.html","title":"Source: connection.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: connection.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const Duplex = require('stream').Duplex; const extend = require('./extend'); const _ = require('./lodash'); const Header = require('./header'); const Packet = require('./packet'); const Datagram = require('./datagram'); const Telegram = require('./telegram'); const states = _.reduce([ 'DISCONNECTED', 'CONNECTING', 'CONNECTED', 'INTERRUPTED', 'RECONNECTING', 'DISCONNECTING', ], (memo, state) =&gt; { memo ['STATE_' + state] = state; return memo; }, {}); const optionKeys = [ 'channel', 'selfAddress', ]; const Connection = extend(Duplex, /** @lends Connection# */ { /** * Creates a new Connection instance and optionally initializes its member with the given values. * * @constructs * @augments Duplex * @param {object} options Initialization values for this instance's members * @param {number} options.channel See {@link Connection#channel} * @param {number} options.selfAddress See {@link Connection#selfAddress} * * @classdesc * The `Connection` class is the abstract base class for all VBus live data connections. * It extends the `Duplex` stream class. Any data written to a `Connection` instance is * parsed according to the VBus Protocol Specification. Once a valid instance of one of the * `Header` sub-classes (`Packet`, `Datagram` or `Telegram`) * is created from the binary data stream, the respective event is emitted on * the `Connection` instance. * * In addition to receiving incoming data the `Connection` class * offers several helper methods e.g. to send data to the underlying VBus connection. * * The `Connection` class itself has no knowledge about the underlying VBus connection. * Several sub-classes exist that know how to contact different types of VBus live streams. * * See `SerialConnection` or `TcpConnection` for concrete implementations. * * @example * var connection = new SerialConnection({ path: '/dev/tty.usbserial' }); * connection.on('connectionState', function(state) { * console.log(state); * }); * connection.on('packet', function(packet) { * console.log(packet.getId()); * }); * connection.on('datagram', function(datagram) { * console.log(datagram.getId()); * }); * connection.connect(); */ constructor(options) { Duplex.call(this); _.extend(this, _.pick(options, optionKeys)); }, /** * Reference to this instance's DataSource. * @type {DataSource} */ dataSource: null, /** * The VBus channel that this connection is established to. * All `Header` instances created by this `Connection` instance will be assigned * this VBus channel. * @type {number} */ channel: 0, /** * The VBus address used for sending information over this connection. * @type {number} */ selfAddress: 0x0020, /** * The current connection state. * @type {string} */ connectionState: states.STATE_DISCONNECTED, /** * The internal receive buffer of this conneciton. * @type {Buffer} */ rxBuffer: null, /** * Establish underlying connection and start streaming data to the writable side * of this `Connection` instance's stream. * * @abstract * @returns {Promise} A promise that resolves once the connection has been established. */ connect(force) { throw new Error('Must be implemented by sub-class'); }, /** * Diconnect this instance. * @abstract */ disconnect() { throw new Error('Must be implemented by sub-class'); }, _write(chunk, encoding, callback) { this.receive(new Date(), chunk); if (callback) { callback(null); } }, receive(timestamp, chunk) { const _this = this; if (this.listenerCount('rawData') &gt; 0) { this.emit('rawData', chunk, timestamp); } let buffer; if (this.rxBuffer) { buffer = Buffer.concat([ this.rxBuffer, chunk ]); } else { buffer = chunk; } let processed = 0; const reportJunk = function(index) { if (index &gt; processed) { if (_this.listenerCount('junkData') &gt; 0) { const junkData = buffer.slice(processed, index); _this.emit('junkData', junkData, timestamp); } } }; // console.log('_write (start):', this.rxBuffer, chunk); let index = 0, start = null; while (index &lt; buffer.length) { const b = buffer [index] &amp; 255; if (b === 0xAA) { reportJunk(index); start = index; processed = index; } else if (b &gt;= 0x80) { start = null; } else if (start === null) { // skip junk } else if (index &gt;= start + 5) { const version = buffer [start + 5] &amp; 255; const majorVersion = version &gt;&gt; 4; let length; if (majorVersion === 1) { if (index &gt;= start + 8) { length = 10 + buffer [start + 8] * 6; } else { length = 10; } } else if (majorVersion === 2) { length = 16; } else if (majorVersion === 3) { if (index &gt;= start + 6) { length = 8 + Telegram.getFrameCountForCommand(buffer [start + 6]) * 9; } else { length = 8; } } else { length = 0; } if (index === start + length - 1) { let valid = true; if (version === 0x10) { if (!Header.calcAndCompareChecksumV0(buffer, start + 1, start + 9)) { // console.log('checksum error in header'); valid = false; } let frameIndex = start + 10; while (valid &amp;&amp; (frameIndex &lt; start + length)) { if (!Header.calcAndCompareChecksumV0(buffer, frameIndex, frameIndex + 5)) { // console.log('checksum error in frame index ' + frameIndex); valid = false; } frameIndex += 6; } } else if (version === 0x20) { if (!Header.calcAndCompareChecksumV0(buffer, start + 1, start + 15)) { valid = false; } } else if (version === 0x30) { if (!Header.calcAndCompareChecksumV0(buffer, start + 1, start + 7)) { valid = false; } let frameIndex = start + 8; while (valid &amp;&amp; (frameIndex &lt; start + length)) { if (!Header.calcAndCompareChecksumV0(buffer, frameIndex, frameIndex + 8)) { valid = false; } frameIndex += 9; } } else { valid = false; } if (valid) { if (majorVersion === 1) { if (this.listenerCount('packet') &gt; 0) { const packet = Packet.fromLiveBuffer(buffer, start, index); packet.timestamp = new Date(timestamp); packet.channel = this.channel; this.emit('packet', packet); } } else if (majorVersion === 2) { if (this.listenerCount('datagram') &gt; 0) { const datagram = Datagram.fromLiveBuffer(buffer, start, index); datagram.timestamp = new Date(timestamp); datagram.channel = this.channel; this.emit('datagram', datagram); } } else if (majorVersion === 3) { if (this.listenerCount('telegram') &gt; 0) { const telegram = Telegram.fromLiveBuffer(buffer, start, index); telegram.timestamp = new Date(timestamp); telegram.channel = this.channel; this.emit('telegram', telegram); } } } else { reportJunk(index + 1); } start = null; processed = index + 1; } } index++; } const minProcessed = buffer.length - 1024; if (processed &lt; minProcessed) { reportJunk(minProcessed); processed = minProcessed; } if (processed &lt; buffer.length) { this.rxBuffer = buffer.slice(processed); } else { this.rxBuffer = null; } }, _read() { // nop }, _setConnectionState(newState) { if (this.connectionState !== newState) { this.connectionState = newState; this.rxBuffer = null; if (this.listenerCount('connectionState') &gt; 0) { this.emit('connectionState', newState); } } }, /** * Send raw data over this Connection instance. * * @param {Header|Buffer} data The Header or Buffer instance to be sent. */ send(data) { if (data instanceof Header) { data = data.toLiveBuffer(); } return this.push(data); }, /** * Sends and / or receives a VBus data. * * @param {Header|Buffer} txData The Header or Buffer instance to be sent. * @param {object} options * @param {number} options.timeout Timeout in milliseconds after which the `txData` will be sent again * @param {number} options.timeoutIncr After each timeout retransmission the timeout value for the next try is increment by this value. * @param {number} options.tries After this number of tries the returned Promise will resolve with value `null`. * @param {?function} options.filterPacket Will be called when a Packet has been received with the Packet and a callback as arguments. * @param {?function} options.filterDatagram Will be called when a Datagram has been received with the Datagram and a callback as arguments. * @returns {Promise} A Promise that either resolves to the VBus data selected by one of the filter callbacks or `null` on timeout. */ transceive(txData, options) { const _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 0, tries: 1, }); return new Promise((resolve, reject) =&gt; { let timer, onPacket, onDatagram; const done = function(err, result) { if (timer) { clearTimeout(timer); timer = null; } if (onPacket) { _this.removeListener('packet', onPacket); onPacket = null; } if (onDatagram) { _this.removeListener('datagram', onDatagram); onDatagram = null; } if (err) { reject(err); } else { resolve(result); } }; if (options.filterPacket) { onPacket = function(rxPacket) { options.filterPacket(rxPacket, done); }; this.on('packet', onPacket); } if (options.filterDatagram) { onDatagram = function(rxDatagram) { options.filterDatagram(rxDatagram, done); }; this.on('datagram', onDatagram); } let tries = options.tries, timeout = options.timeout; const nextTry = function() { if (tries &gt; 0) { tries--; timer = setTimeout(nextTry, timeout); timeout += options.timeoutIncr; if (txData) { _this.send(txData); } } else { done(null, null); } }; process.nextTick(nextTry); }); }, /** * Waits for a VBus bus offering datagram (Command 0x0500). * * Returns a Promise that resolves with the Datagram or `null` if the method timed out. * @param {number} timeout=20000 Timeout in milliseconds * @returns {Promise} A Promise that resolves to the bus offering Datagram or `null` on timeout. */ waitForFreeBus(timeout) { const options = { tries: 1, timeout: timeout || 20000, }; options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.command === 0x0500) { done(null, rxDatagram); } }; return this.transceive(null, options); }, /** * Sends a VBus bus release datagram (Command 0x0600). * Returns a Promise that resolves with the first VBus packet received after the release or `null` on timeout. * * @param {number} address The VBus address of the master device to give the bus ownership back to. * @param {object} options * @param {number} options.tries=2 Number of tries to give the bus ownership back. * @param {number} options.timeout=1500 Time in milliseconds to wait between tries. */ releaseBus(address, options) { options = _.defaults({}, options, { tries: 2, timeout: 1500 }); const txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: 0x0600, valueId: 0, value: 0 }).toLiveBuffer(); options.filterPacket = function(rxPacket, done) { done(null, rxPacket); }; return this.transceive(txDatagram, options); }, /** * Sends a Datagram to get a value from a device. * Returns a Promise that resolves to the answer Datagram or `null` on timeout. * * @param {number} address The VBus address of the device to get the value from * @param {number} valueId The ID of the value to read from the device. * @param {object} options * @param {number} options.timeout=500 Time in milliseconds between tries. * @param {number} options.timeoutIncr=500 Additional time in milliseconds to increase the timeout per try. * @param {number} options.tries=3 Number of tries to get the value. * @returns {Promise} A promise that resolves to the received Datagram or `null` on timeout. */ getValueById(address, valueId, options) { const _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 500, tries: 3, }); const subIndex = (valueId &gt;&gt; 16) &amp; 0x7F; valueId = valueId &amp; 0xFFFF; const txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: 0x0300 | subIndex, valueId, value: 0 }).toLiveBuffer(); options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.destinationAddress !== _this.selfAddress) { // nop } else if (rxDatagram.sourceAddress !== address) { // nop } else if (rxDatagram.command !== (0x0100 | subIndex)) { // nop } else if (rxDatagram.valueId !== valueId) { // nop } else { done(null, rxDatagram); } }; return this.transceive(txDatagram, options); }, /** * Sends a Datagram to set a value in a device. * Returns a Promise that resolves to the answer Datagram or `null` on timeout. * * @param {number} address The VBus address of the device to set the value in * @param {number} valueId The ID of the value to write to the device. * @param {number} value The value to write to the device. * @param {object} options * @param {number} options.timeout=500 Time in milliseconds between tries. * @param {number} options.timeoutIncr=500 Additional time in milliseconds to increase the timeout per try. * @param {number} options.tries=3 Number of tries to get the value. * @returns {Promise} A promise that resolves to the received Datagram or `null` on timeout. */ setValueById(address, valueId, value, options) { const _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 500, tries: 3, save: false, }); const subIndex = (valueId &gt;&gt; 16) &amp; 0x7F; valueId = valueId &amp; 0xFFFF; const txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: (options.save ? 0x0400 : 0x0200) | subIndex, valueId, value }).toLiveBuffer(); options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.destinationAddress !== _this.selfAddress) { // nop } else if (rxDatagram.sourceAddress !== address) { // nop } else if (rxDatagram.command !== (0x0100 | subIndex)) { // nop } else if (rxDatagram.valueId !== valueId) { // nop } else { done(null, rxDatagram); } }; return this.transceive(txDatagram, options); }, /** * Sends a Datagram to lookup a value ID hash in a device. * Returns a Promise that resolves to the answer Datagram or `null` on timeout. * * @param {number} address The VBus address of the device to lookup the value in. * @param {number} valueId The ID of the value to lookup in the device. * @param {object} options * @param {number} options.timeout=500 Time in milliseconds between tries. * @param {number} options.timeoutIncr=500 Additional time in milliseconds to increase the timeout per try. * @param {number} options.tries=3 Number of tries to lookup the value. * @return {Promise} A Promise the resolves to the received Datagram or `null` on timeout. */ getValueIdHashById(address, valueId, options) { const _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 500, tries: 3, }); const txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: 0x1000, valueId, value: 0 }).toLiveBuffer(); options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.destinationAddress !== _this.selfAddress) { // nop } else if (rxDatagram.sourceAddress !== address) { // nop } else if (rxDatagram.command !== 0x0100) { // nop } else if (rxDatagram.valueId !== valueId) { // nop } else { done(null, rxDatagram); } }; return this.transceive(txDatagram, options); }, /** * Sends a Datagram to lookup a value ID in a device. * Returns a Promise that resolves to the answer Datagram or `null` on timeout. * * @param {number} address The VBus address of the device to lookup the value in. * @param {number} valueIdHash The ID hash of the value to lookup in the device. * @param {object} options * @param {number} options.timeout=500 Time in milliseconds between tries. * @param {number} options.timeoutIncr=500 Additional time in milliseconds to increase the timeout per try. * @param {number} options.tries=3 Number of tries to lookup the value. * @return {Promise} A Promise the resolves to the received Datagram or `null` on timeout. */ getValueIdByIdHash(address, valueIdHash, options) { const _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 500, tries: 3, }); const txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: 0x1100, valueId: 0, value: valueIdHash }).toLiveBuffer(); options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.destinationAddress !== _this.selfAddress) { // nop } else if (rxDatagram.sourceAddress !== address) { // nop } else if (rxDatagram.command !== 0x0100) { // nop } else if (rxDatagram.value !== valueIdHash) { // nop } else { done(null, rxDatagram); } }; return this.transceive(txDatagram, options); }, /** * Sends a Datagram to lookup the controller's capabilities (part 1). * Returns a Promise that resolves to the answer Datagram or `null` on timeout. * * @param {number} address The VBus address of the device to get the capabilities from. * @param {object} options * @param {number} options.timeout=500 Time in milliseconds between tries. * @param {number} options.timeoutIncr=500 Additional time in milliseconds to increase the timeout per try. * @param {number} options.tries=3 Number of tries to lookup the value. * @return {Promise} A Promise the resolves to the received Datagram or `null` on timeout. */ getCaps1(address, options) { const _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 500, tries: 3, }); const txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: 0x1300, valueId: 0, value: 0, }).toLiveBuffer(); options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.destinationAddress !== _this.selfAddress) { // nop } else if (rxDatagram.sourceAddress !== address) { // nop } else if (rxDatagram.command !== 0x1301) { // nop } else { done(null, rxDatagram); } }; return this.transceive(txDatagram, options); }, /** * Sends a Datagram to begin a bulk valke transaction. * Returns a Promise that resolves to the answer Datagram or `null` on timeout. * * @param {number} address The VBus address of the device to begin the transaction on. * @param {number} txTimeout The number of seconds of inactivity after which the transaction is rolled back. * @param {object} options * @param {number} options.timeout=500 Time in milliseconds between tries. * @param {number} options.timeoutIncr=500 Additional time in milliseconds to increase the timeout per try. * @param {number} options.tries=3 Number of tries to lookup the value. * @return {Promise} A Promise the resolves to the received Datagram or `null` on timeout. */ beginBulkValueTransaction(address, txTimeout, options) { const _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 500, tries: 3, }); const txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: 0x1400, valueId: 0, value: txTimeout }).toLiveBuffer(); options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.destinationAddress !== _this.selfAddress) { // nop } else if (rxDatagram.sourceAddress !== address) { // nop } else if (rxDatagram.command !== 0x1401) { // nop } else { done(null, rxDatagram); } }; return this.transceive(txDatagram, options); }, /** * Sends a Datagram to commit a bulk valke transaction. * Returns a Promise that resolves to the answer Datagram or `null` on timeout. * * @param {number} address The VBus address of the device to commit the transaction on. * @param {object} options * @param {number} options.timeout=500 Time in milliseconds between tries. * @param {number} options.timeoutIncr=500 Additional time in milliseconds to increase the timeout per try. * @param {number} options.tries=3 Number of tries to lookup the value. * @return {Promise} A Promise the resolves to the received Datagram or `null` on timeout. */ commitBulkValueTransaction(address, options) { const _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 500, tries: 3, }); const txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: 0x1402, valueId: 0, value: 0 }).toLiveBuffer(); options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.destinationAddress !== _this.selfAddress) { // nop } else if (rxDatagram.sourceAddress !== address) { // nop } else if (rxDatagram.command !== 0x1403) { // nop } else { done(null, rxDatagram); } }; return this.transceive(txDatagram, options); }, /** * Sends a Datagram to rollback a bulk valke transaction. * Returns a Promise that resolves to the answer Datagram or `null` on timeout. * * @param {number} address The VBus address of the device to perform the rollback on. * @param {object} options * @param {number} options.timeout=500 Time in milliseconds between tries. * @param {number} options.timeoutIncr=500 Additional time in milliseconds to increase the timeout per try. * @param {number} options.tries=3 Number of tries to lookup the value. * @return {Promise} A Promise the resolves to the received Datagram or `null` on timeout. */ rollbackBulkValueTransaction(address, options) { const _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 500, tries: 3, }); const txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: 0x1404, valueId: 0, value: 0 }).toLiveBuffer(); options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.destinationAddress !== _this.selfAddress) { // nop } else if (rxDatagram.sourceAddress !== address) { // nop } else if (rxDatagram.command !== 0x1405) { // nop } else { done(null, rxDatagram); } }; return this.transceive(txDatagram, options); }, /** * Sends a Datagram to set a value during a bulk value transaction. * Returns a Promise that resolves to the answer Datagram or `null` on timeout. * * @param {number} address The VBus address of the device to set the value on. * @param {number} valueId The ID of the value to write to the device. * @param {number} value The value to write to the device. * @param {object} options * @param {number} options.timeout=500 Time in milliseconds between tries. * @param {number} options.timeoutIncr=500 Additional time in milliseconds to increase the timeout per try. * @param {number} options.tries=3 Number of tries to lookup the value. * @return {Promise} A Promise the resolves to the received Datagram or `null` on timeout. */ setBulkValueById(address, valueId, value, options) { const _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 500, tries: 3, }); const subIndex = (valueId &gt;&gt; 16) &amp; 0x7F; valueId = valueId &amp; 0xFFFF; const txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: 0x1500 | subIndex, valueId, value }).toLiveBuffer(); options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.destinationAddress !== _this.selfAddress) { // nop } else if (rxDatagram.sourceAddress !== address) { // nop } else if (rxDatagram.command !== (0x1600 | subIndex)) { // nop } else if (rxDatagram.valueId !== valueId) { // nop } else { done(null, rxDatagram); } }; return this.transceive(txDatagram, options); }, /** * Creates a promise that resolves when this Connection * instance is connected and rejects if it is disconnected. * If it is neither connected nor disconnected the promise * will stay pending until one of the states is entered. * * @returns {Promise} */ createConnectedPromise() { const _this = this; return new Promise((resolve, reject) =&gt; { const checkConnectionState = function(state) { if (state === Connection.STATE_DISCONNECTED) { reject(new Error(state)); return true; } else if (state === Connection.STATE_CONNECTED) { resolve(); return true; } else { return false; } }; if (!checkConnectionState(_this.connectionState)) { const onConnectionState = function(state) { if (checkConnectionState(state)) { _this.removeListener('connectionState', onConnectionState); } }; _this.on('connectionState', onConnectionState); } }); }, }, states); module.exports = Connection; × Search results Close "},"connection-customizer.js.html":{"id":"connection-customizer.js.html","title":"Source: connection-customizer.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: connection-customizer.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const Customizer = require('./customizer'); const _ = require('./lodash'); const optionKeys = [ 'connection', 'maxRounds', 'triesPerValue', 'timeoutPerValue', 'masterTimeout', ]; const ConnectionCustomizer = Customizer.extend(/** @lends ConnectionCustomizer# */ { /** * The connection to use for transfer of the configuration values. * @type {Connection} */ connection: null, /** * Maximum number of optimization rounds for {@link transceiveConfiguration}. * @type {number} * @default 10 */ maxRounds: 10, /** * Amount of retries to transceive one value. * Between two tries the VBus is released and then re-acquired. * @type {number} * @default 2 */ triesPerValue: 2, /** * Timeout in milliseconds after which the transceive times out. * @type {number} * @default 30000 */ timeoutPerValue: 30000, /** * Interval in milliseconds in which * the VBus master is contacted to reissue the VBus clearance. * @type {number} * @default 8000 */ masterTimeout: 8000, /** * Constructs a new ConnectionCustomizer instance and optionally initializes its * members with the given values. * * @constructs * @augments Customizer * @param {object} [options] Initialization values for this instance's members * @param {number} [options.connection] {@link ConnectionCustomizer#connection} * @param {number} [options.maxRounds] {@link ConnectionCustomizer#maxRounds} * @param {number} [options.triesPerValue] {@link ConnectionCustomizer#triesPerValue} * @param {number} [options.timeoutPerValue] {@link ConnectionCustomizer#timeoutPerValue} * @param {number} [options.masterTimeout] {@link ConnectionCustomizer#masterTimeout} * * @classdesc * A ConnectionCustomizer uses an established connection to a device * to transfer sets of configuration values over it. */ constructor(options) { Customizer.apply(this, arguments); _.extend(this, _.pick(options, optionKeys)); }, /** * Load a set of configuration values from a device. * * See {@link Customizer#loadConfiguration} for details. */ async _loadConfiguration(configuration, options) { options = _.defaults({}, options, { action: 'get', }); const callback = (config, round) =&gt; { if (options.optimize) { return this._optimizeLoadConfiguration(config); } else { if (round === 1) { _.forEach(configuration, (value) =&gt; { value.pending = true; }); return configuration; } else { return config; } } }; return this.transceiveConfiguration(options, callback); }, /** * Save a set of configuration values to a device. * * See {@link Customizer#saveConfiguration} for details. */ async _saveConfiguration(newConfiguration, oldConfigurstion, options) { options = _.defaults({}, options, { action: 'set', actionOptions: { save: true, }, }); const callback = (config, round) =&gt; { if (options.optimize) { if (round === 1) { return this._optimizeSaveConfiguration(newConfiguration, oldConfigurstion); } else { return this._optimizeSaveConfiguration(newConfiguration, config); } } else { if (round === 1) { _.forEach(newConfiguration, (value) =&gt; { value.pending = true; }); return newConfiguration; } else { return config; } } }; return this.transceiveConfiguration(options, callback); }, /** * Transceives a controller configuration set, handling timeouts, retries etc. * * @param {object} options Options * @param {number} [options.maxRounds] {@link ConnectionCustomizer#maxRounds} * @param {number} [options.triesPerValue] {@link ConnectionCustomizer#triesPerValue} * @param {number} [options.timeoutPerValue] {@link ConnectionCustomizer#timeoutPerValue} * @param {number} [options.masterTimeout] {@link ConnectionCustomizer#masterTimeout} * @param {string} options.action Action to perform, can be `'get'` or `'set'`. * @param {object} [options.actionOptions] Options object to forward to the action to perform. * @param {function} [options.reportProgress] Callback to inform about progress. * @param {function} [options.checkCanceled] Callback to check whether the operation should be canceled. * @param {function} optimizerCallback Callback to optimize configuration between rounds. * @return {object} Promise that resolves to the configuration or `null` on timeout. */ async transceiveConfiguration(options, optimizerCallback) { if (_.isFunction(options)) { optimizerCallback = options; options = null; } options = _.defaults({}, options, { maxRounds: this.maxRounds, triesPerValue: this.triesPerValue, timeoutPerValue: this.timeoutPerValue, masterTimeout: this.masterTimeout, action: null, actionOptions: null, reportProgress: null, checkCanceled: null, }); const connection = this.connection; const address = this.deviceAddress; async function check() { if (options.checkCanceled) { if (await options.checkCanceled()) { throw new Error('Canceled'); } } await connection.createConnectedPromise(); } let config = null; const state = { masterAddress: null, masterLastContacted: null, }; const reportProgress = function(progress) { if (options.reportProgress) { options.reportProgress(progress); } }; for (let round = 1; round &lt;= options.maxRounds; round++) { await check(); reportProgress({ message: 'OPTIMIZING_VALUES', round, }); config = await optimizerCallback(config, round); await check(); const pendingValues = config.filter((value) =&gt; { return value.pending; }); if (pendingValues.length &gt; 0) { for (let index = 0; index &lt; pendingValues.length; index++) { const valueInfo = pendingValues [index++]; let reportProgress; if (options.reportProgress) { reportProgress = (progress) =&gt; { progress = _.extend({}, progress, { valueId: valueInfo.valueId, valueIndex: valueInfo.valueIndex, valueIdHash: valueInfo.valueIdHash, valueNr: index, valueCount: pendingValues.length, }); return options.reportProgress(progress); }; } await check(); const datagram = await this.transceiveValue(valueInfo, valueInfo.value, { triesPerValue: options.triesPerValue, timeoutPerValue: options.timeoutPerValue, action: options.action, actionOptions: options.actionOptions, reportProgress, }, state); valueInfo.pending = false; valueInfo.transceived = !!datagram; if (datagram) { valueInfo.value = datagram.value; } } } else { break; } } if (state.masterLastContacted !== null) { reportProgress({ message: 'RELEASING_BUS', }); await connection.releaseBus(address); } return config; }, /** * Transceive a controller value over this connection, handling * timeouts, retries etc. * * @param {object|number} valueInfoOrIndex Value info object or value index * @param {number} valueInfo.valueIndex Value index * @param {number} valueInfo.valueIdHash Value ID hash * @param {number} value Value * @param {object} options Options * @param {number} options.triesPerValue {@link ConnectionCustomizer#triesPerValue} * @param {number} options.timeoutPerValue {@link ConnectionCustomizer#timeoutPerValue} * @param {number} options.masterTimeout {@link ConnectionCustomizer#masterTimeout} * @param {string} options.action Action to perform, can be `'get'` or `'set'`. * @param {object} [options.actionOptions] Options object to forward to the action to perform. * @param {function} [options.reportProgress] Callback to inform about progress. * @param {function} [options.checkCanceled] Callback to check whether the operation should be canceled. * @param {object} state State to share between multiple calls to this method. * @returns {object} Promise that resolves with the datagram received or `null` on timeout. */ async transceiveValue(valueInfo, value, options, state) { const doWork = async (resolve, reject) =&gt; { let timer; const done = function(err, result) { if (timer) { clearTimeout(timer); timer = null; } if (err) { reject(err); } else { resolve(result); } }; if (!_.isObject(valueInfo)) { valueInfo = { valueIndex: valueInfo, }; } if (state === undefined) { state = {}; } options = _.defaults({}, options, { triesPerValue: this.triesPerValue, timeoutPerValue: this.timeoutPerValue, masterTimeout: this.masterTimeout, action: null, actionOptions: null, reportProgress: null, checkCanceled: null, }); state = _.defaults(state, { masterAddress: this.deviceAddress, masterLastContacted: Date.now(), }); const connection = this.connection; const address = this.deviceAddress; async function check() { if (options.checkCanceled) { if (await options.checkCanceled()) { reject(new Error('Canceled')); } } await connection.createConnectedPromise(); } const onTimeout = function() { done(null, null); }; timer = setTimeout(onTimeout, options.timeoutPerValue); let result; for (let tries = 1; tries &lt;= options.triesPerValue; tries++) { const reportProgress = function(message) { if (options.reportProgress) { options.reportProgress({ message, tries, valueIndex: valueInfo.valueIndex, valueInfo, }); } }; await check(); if ((tries &gt; 1) &amp;&amp; (state.masterLastContacted !== null)) { reportProgress('RELEASING_BUS'); state.masterLastContacted = null; await connection.releaseBus(state.masterAddress); } await check(); if ((state.masterLastContacted === null) &amp;&amp; (options.masterTimeout !== null)) { reportProgress('WAITING_FOR_FREE_BUS'); const datagram = await connection.waitForFreeBus(); // TODO: optional timeout? if (datagram) { state.masterAddress = datagram.sourceAddress; } else { state.masterAddress = null; } } await check(); let contactMaster; if (state.masterAddress === null) { contactMaster = false; } else if (state.masterAddress === address) { contactMaster = false; } else if (state.masterLastContacted === null) { contactMaster = true; } else if ((Date.now() - state.masterLastContacted) &gt;= options.masterTimeout) { contactMaster = true; } else { contactMaster = false; } if (contactMaster) { reportProgress('CONTACTING_MASTER'); state.masterLastContacted = Date.now(); await connection.getValueById(state.masterAddress, 0, { timeout: 500, tries: 1, }); } await check(); if (state.masterAddress === address) { state.masterLastContacted = Date.now(); } if (_.isNumber(valueInfo.valueIndex)) { // nop } else if (_.isNumber(valueInfo.valueIdHash)) { reportProgress('LOOKING_UP_VALUE'); const datagram = await connection.getValueIdByIdHash(address, valueInfo.valueIdHash, options.actionOptions); if (datagram &amp;&amp; datagram.valueId) { valueInfo.valueIndex = datagram.valueId; } } await check(); if (state.masterAddress === address) { state.masterLastContacted = Date.now(); } if (!_.isNumber(valueInfo.valueIndex)) { result = null; } else if (options.action === 'get') { reportProgress('GETTING_VALUE'); result = await connection.getValueById(address, valueInfo.valueIndex, options.actionOptions); } else if (options.action === 'set') { reportProgress('SETTING_VALUE'); result = await connection.setValueById(address, valueInfo.valueIndex, value, options.actionOptions); } else { throw new Error('Unknown action \"' + options.action + '\"'); } if (result) { break; } } return result; }; return new Promise((resolve, reject) =&gt; { doWork(resolve, reject).then(resolve, reject); }); } }); module.exports = ConnectionCustomizer; × Search results Close "},"customizer.js.html":{"id":"customizer.js.html","title":"Source: customizer.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: customizer.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const EventEmitter = require('events').EventEmitter; const extend = require('./extend'); const _ = require('./lodash'); const optionKeys = [ 'id', 'deviceAddress', 'optimizer', ]; const Customizer = extend(EventEmitter, /** @lends Customizer# */ { /** * An identifier for this customizer. * @type {string} */ id: null, /** * The VBus address of the device to customize. * @type {number} */ deviceAddress: 0, /** * A configuration optimizer. * @type {ConfigurationOptimizer} */ optimizer: null, /** * Creates a new Customizer instance and optionally initializes its members * with the given values. * * @constructs * @param {object} [options] Initialization values for this instance's members * @param {string} [options.id] {@link Customizer#id} * @param {string} [options.deviceAddress] {@link Customizer#deviceAddress} * @param {string} [options.optimizer] {@link Customizer#optimizer} * * @classdesc * A Customizer provides functionality to transfer a set of configuration * values from or to a device. */ constructor(options) { EventEmitter.call(this); _.extend(this, _.pick(options, optionKeys)); }, /** * Load a set of configuration values from a device. * * If the `Customizer` has an `optimizer` set, the `configuration` parameter * is passed to the optimizer's `completeConfiguration` method. Otherwise it must be an * array of `ConfigurationValue` objects. * * If `options.optimize` is \"truthy\" the list of `ConfigurationValue` objects is passed * into the optimizer's `optimizeLoadConfiguration` method to determine the minimal * set of values to transfer. If `options.optimize` is \"falsy\" all of the * `ConfigurationValue` objects will be loaded. * * @param {array} configuration The set of values to transfer. * @param {object} options * @returns {Promise} A Promise that resolves to the set of values transfered. */ async loadConfiguration(configuration, options) { options = _.defaults({}, options, { optimize: true, }); configuration = await this._completeConfiguration(configuration); return this._loadConfiguration(configuration, options); }, _loadConfiguration(configuration, options) { throw new Error('Must be implemented by sub-class'); }, /** * Save a set of configuration values to a device. * * If the `Customizer` has an `optimizer` set, the `newConfiguration` parameter * is passed to the optimizer's `completeConfiguration` method. Otherwise it must be an * array of `ConfigurationValue` objects. * * If a `oldConfiguration` parameter is given, the same procedure as for the * `newConfiguration` is applied to it as well. * * If `options.optimize` is \"truthy\" the list of `ConfigurationValue` objects is passed * into the optimizer's `optimizeLoadConfiguration` method to determine the minimal * set of values to transfer. If `options.optimize` is \"falsy\" all of the * `ConfigurationValue` objects will be loaded. * * @param {array} newConfiguration The set of values to transfer. * @param {array} oldConfiguration The set of values to assume to be stored in the device. * @param {object} options * @returns {Promise} A Promise that resolves to the set of values transfered. */ async saveConfiguration(newConfiguration, oldConfiguration, options) { options = _.defaults({}, options, { optimize: true, }); newConfiguration = await this._completeConfiguration(newConfiguration); if (oldConfiguration) { oldConfiguration = await this._completeConfiguration(oldConfiguration); } return this._saveConfiguration(newConfiguration, oldConfiguration, options); }, _saveConfiguration(newConfiguration, oldConfiguration, options) { throw new Error('Must be implemented by sub-class'); }, /** * Converts the configuration provided into an array of {@see ConfigurationValue} objects. * The provided configuration can be either an array of partially initialized ConfigurationValue * objects or an object mapping value IDs as keys to values. * If no configuration is given a complete configuration set is returned. * * @param {undefined|null|array|object} config Configuration to complete. * @returns {Promise} A Promise that resolves to the completed array of values. */ _completeConfiguration(config) { if (this.optimizer) { return this.optimizer.completeConfiguration(config); } else { return Promise.resolve(config); } }, /** * Gets the optimized array of values based on what values are already loaded. * * @param {array} config The array of values that has already been loaded. * @returns {Promise} A Promise that resolves to the array of values to load next. */ _optimizeLoadConfiguration(config) { return this.optimizer.optimizeLoadConfiguration(config); }, /** * Gets the optimzed array of values to save to the controller. * * @param {array} newConfig The array of values to transfer. * @param {array} oldConfig The array of values that are assumed to be currently stored in the device. * @returns {Promise} A Promise that resolves to the array of values to save. */ _optimizeSaveConfiguration(newConfig, oldConfig) { return this.optimizer.optimizeSaveConfiguration(newConfig, oldConfig); }, }); module.exports = Customizer; × Search results Close "},"converter.js.html":{"id":"converter.js.html","title":"Source: converter.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: converter.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const util = require('util'); const Duplex = require('stream').Duplex; const Header = require('./header'); const HeaderSet = require('./header-set'); const _ = require('./lodash'); const extend = require('./extend'); const optionKeys = [ 'objectMode', ]; /** * @typedef RawData * @type {object} * @property {Number} channel VBus Channel number * @property {Date} startTimestamp Timestamp of the start of reception of this data * @property {Date} endTimestamp Timestamp of the end of reception of this data * @property {Buffer} buffer The VBus raw data buffer */ const Converter = extend(Duplex, /** @lends Converter# */ { /** * Specifies whether the underlying stream operates in object mode. * @type {boolean} */ objectMode: false, finishedPromise: null, /** * Creates a new Converter instance and optionally initializes its members with the given values. * * @constructs * @augments Duplex * @param {object} options Initialization values * @param {boolean} options.objectMode See {@link Converter#objectMode} * * @classdesc * Converter instances are streams that convert VBus models (Packet, Datagram and Telegram instances) and / or * Headerset instances to another representation. Optionally some Converter sub-classes support parsing that * representation back to the model instances. Converter sub-classes include VBusRecordingConverter (for * parsing and generating according to the VBus Recording File Format) and TextConverter that creates * character-separated text representations. */ constructor(options) { const _this = this; options = _.defaults({}, options); Duplex.call(this, { objectMode: options.objectMode, }); _.extend(this, _.pick(options, optionKeys)); this.finishedPromise = new Promise((resolve) =&gt; { // we have to add a data event handler to enable getting end event const onData = function() {}; _this.on('data', onData); _this.once('end', () =&gt; { _this.removeListener('data', onData); resolve(); }); }); }, /** * This method resets the converter. It should be used e.g. if the converter output switches between files (allows * some Converter sub-classes to correctly write a header). */ reset() { // nop }, /** * This method signals that no additional VBus Header or HeaderSet models will * be converted. It returns a promise that resolves when all data has been * consumed. * * @return {Promise} A Promise that resolves when all data has been consumed. */ async finish() { this.push(null); return this.finishedPromise; }, /** * This method queues a VBus raw data chunk from conversion. * Not all Converter sub-classes support this method. * * @param {RawData} rawData The VBus raw data chunk to queue for conversion. */ convertRawData(rawData) { if (this.objectMode) { this.push(rawData); } else { throw new Error('Must be implemented by sub-class'); } }, /** * This method queues a VBus Header model (Packet, Datagram or Telegram) for conversion. * Not all Converter sub-classes support this method. * * @param {Header} header The Header to queue for conversion. */ convertHeader(header) { if (this.objectMode) { this.push(header); } else { throw new Error('Must be implemented by sub-class'); } }, /** * This method queues a VBus HeaderSet instance for conversion. * Not all Converter sub-classes support this method. * * @param {HeaderSet} headerSet The HeaderSet to queue for conversion. */ convertHeaderSet(headerSet) { if (this.objectMode) { this.push(headerSet); } else { throw new Error('Must be implemented by sub-class'); } }, _read() { if (this.objectMode) { // nop } else { throw new Error('Must be implemented by sub-class'); } }, _write(chunk, encoding, callback) { if (this.objectMode) { if (chunk instanceof HeaderSet) { this.emit('headerSet', chunk); } else if (chunk instanceof Header) { this.emit('header', chunk); } else { throw new Error('Unsupported object found: ' + util.inspect(chunk)); } callback(); } else { throw new Error('Must be implemented by sub-class'); } }, }); module.exports = Converter; × Search results Close "},"datagram.js.html":{"id":"datagram.js.html","title":"Source: datagram.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: datagram.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const sprintf = require('sprintf-js').sprintf; const Header = require('./header'); const _ = require('./lodash'); const optionKeys = [ 'command', 'valueId', 'value', ]; const Datagram = Header.extend(/** @lends Datagram# */ { /** * The command field of this VBus datagram. See the VBus Protocol Specification for details. * @type {number} */ command: 0, /** * The value ID field of this VBus datagram. * @type {number} */ valueId: 0, /** * The value field of this VBus datagram. * @type {number} */ value: 0, /** * Creates a new Datagram instance and optionally initializes its members with the given values. * * @constructs * @augments Header * @param {object} options Initialization values for this instance's members * @param {number} options.command {@link Datagram#command} * @param {number} options.valueId {@link Datagram#valueId} * @param {Buffer} options.value {@link Datagram#value} * @see Header#constructor * * @classdesc * The Datagram sub-class provides access to all properties and methods applicable for VBus version 2 datagrams. * In addition to the packet header it may contain a command, a value ID and a value. * The value ID is a device-specific reference to one of the values presented in the device's menu interface. */ constructor(options) { Header.call(this, options); _.extend(this, _.pick(options, optionKeys)); }, toLiveBuffer(origBuffer, start, end) { const length = 16; let buffer; if (origBuffer === undefined) { buffer = Buffer.alloc(length); } else { buffer = origBuffer.slice(start, end); } if (buffer.length &lt; length) { throw new Error('Buffer too small'); } buffer [0] = 0xAA; buffer.writeUInt16LE(this.destinationAddress &amp; 0x7F7F, 1); buffer.writeUInt16LE(this.sourceAddress &amp; 0x7F7F, 3); buffer [5] = 0x20; buffer.writeUInt16LE(this.command &amp; 0x7F7F, 6); const frameData = Buffer.alloc(6); frameData.writeUInt16LE(this.valueId, 0); frameData.writeInt32LE(this.value, 2); Datagram.extractSeptett(frameData, 0, 6, buffer, 8); Datagram.calcAndSetChecksumV0(buffer, 1, 15); return buffer; }, getProtocolVersion() { return 0x20; }, getInfo() { let info; if (this.command === 0x0900) { info = this.valueId; } else { info = 0; } return info; }, getId() { const baseId = Header.prototype.getId.call(this); const info = this.getInfo(); return sprintf('%s_%04X_%04X', baseId, this.command, info); }, compareTo(that) { let result = Header.prototype.compareTo.apply(this, arguments); if (result === 0) { result = this.command - that.command; } if (result === 0) { result = this.getInfo() - that.getInfo(); } return result; }, }, { fromLiveBuffer(buffer, start, end) { const frameData = Buffer.alloc(6); Header.injectSeptett(buffer, start + 8, start + 14, frameData, 0); return new Datagram({ destinationAddress: buffer.readUInt16LE(start + 1), sourceAddress: buffer.readUInt16LE(start + 3), command: buffer.readUInt16LE(start + 6), valueId: frameData.readUInt16LE(0), value: frameData.readInt32LE(2) }); } }); module.exports = Datagram; × Search results Close "},"header.js.html":{"id":"header.js.html","title":"Source: header.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: header.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const sprintf = require('sprintf-js').sprintf; const extend = require('./extend'); const _ = require('./lodash'); const optionKeys = [ 'timestamp', 'channel', 'destinationAddress', 'sourceAddress', ]; const Header = extend(null, /** @lends Header# */ { /** * Timestamp of this header * @type {Date} * @default now */ timestamp: null, /** * VBus channel of this header * @type {number} * @default 0 */ channel: 0, /** * VBus address of this header's destination * @type {number} * @default 0 */ destinationAddress: 0, /** * VBus address of this header's source * @type {number} * @default */ sourceAddress: 0, /** * Creates a new Header instance and optionally initializes its members * with the given values * * @constructs * @param {object} [options] Initialization values for this instance's members * @param {Date} [options.timestamp] {@link Header#timestamp} * @param {number} [options.channel] {@link Header#channel} * @param {number} [options.destinationAddress] {@link Header#destinationAddress} * @param {number} [options.sourceAddress] {@link Header#sourceAddress} * * @classdesc * All VBus models are sub-classes of this Header class. The Header class provides * a generic interface and the common properties that all (currently three) * different types of VBus models can use. * * Header instances can either be created by calling the constructor function or * by passing a Buffer object containing the binary VBus data to the class method * `HeaderSubClass.fromLiveBuffer`. * * @see Packet * @see Datagram * @see Telegram */ constructor(options) { _.extend(this, _.pick(options, optionKeys)); if (!this.timestamp) { this.timestamp = new Date(); } }, /** * Creates a representation of this Header instance that can be * transmitted over a Connection. If no buffer is given as an * arguments, it creates a new one that is big enough to hold * the representation. * * Must be implemented by sub-class. * * @abstract * @param {Buffer} [buffer] Buffer object to store data in * @param {number} [start] Start index in the buffer * @param {number} [end] End index in the buffer * @returns {Buffer} Buffer object containing the data */ toLiveBuffer(/* buffer, start, end */) { throw new Error('Must be implemented by sub-class'); }, /** * Returns the protocol version of this Header instance as a 8-bit * number. The high nibble is used for the major version, the low * nibble for the minor version. For example: a header with protocol * version 2.0 would return `0x20`. * * Must be implemented by sub-class. * * @abstract * @returns {number} Protocol version */ getProtocolVersion() { throw new Error('Must be implemented by sub-class'); }, /** * Returns an info number about this Header instance. It can be used * for sorting purposes (to distinguish Header objects that would * otherwise compare as equal). * * @returns {number} Info value */ getInfo() { return 0; }, /** * Returns a string identifier describing this Header instance. * It contains at least: * * - channel * - destination address * - source address * - protocol version * * Sub-classes can extend that information. The structure of this * identifier is implementation specific, do not rely on it! * * @returns {string} Identifier */ getId() { return sprintf('%02X_%04X_%04X_%02X', this.channel, this.destinationAddress, this.sourceAddress, this.getProtocolVersion()); }, /** * Compares this Header instance to another one. * * Sub-classes can extend the comparison to include specific * information. * * @param {Header} that Another Header instance to compare to. * @returns {number} Returns a number * * - less than 0 if `this &lt; that` * - greater than 0 if `this &gt; that` * - equal to to if `this == that` */ compareTo(that) { let result = this.channel - that.channel; if (result === 0) { result = this.destinationAddress - that.destinationAddress; } if (result === 0) { result = this.sourceAddress - that.sourceAddress; } if (result === 0) { result = this.getProtocolVersion() - that.getProtocolVersion(); } return result; }, }, /** @lends Header */ { /** * Creates a Header instance from a representation that was * received over a Connection. * * Must be implemented by sub-class. * * @abstract * @param {Buffer} buffer Buffer that contains the representation * @param {number} start Start index in the buffer * @param {number} end End index in the buffer * @returns {Header} Header instance created from the representation */ fromLiveBuffer(/* buffer, start, end */) { throw new Error('Must be implemented by sub-class'); }, /** * Calculates the VBus checksum (according to version x.0 specification) * over a part of a Buffer instance. * * @param {Buffer} buffer Buffer to calc checksum for * @param {number} start Start index in the buffer * @param {number} end End index in the buffer * @returns {number} Calculated checksum */ calcChecksumV0(buffer, start, end) { let checksum = 0; for (let index = start; index &lt; end; index++) { checksum = (checksum + buffer [index]) &amp; 0x7F; } checksum = (0x7F - checksum); return checksum; }, /** * Calculates the VBus checksum (according to version x.0 specification) * over a part of a Buffer instance and compares it the checksum byte * stored at the `end` position. * * @param {Buffer} buffer Buffer to calc and compare checksum for * @param {number} start Start index in the buffer * @param {number} end End index in the buffer * @returns {boolean} Result whether calculated and stored checksum match */ calcAndCompareChecksumV0(buffer, start, end) { const checksum = this.calcChecksumV0(buffer, start, end); return (buffer [end] === checksum); }, /** * Calculates the VBus checksum (according to version x.0 specification) * over a part of the Buffer instance and stores it at the `end` position. * * @param {Buffer} buffer Buffer to calc and store checksum for * @param {number} start Start index in the buffer * @param {number} end End index in the buffer * @returns {number} Calculated checksum */ calcAndSetChecksumV0(buffer, start, end) { const checksum = this.calcChecksumV0(buffer, start, end); buffer [end] = checksum; return checksum; }, /** * Copies a part of the source Buffer instance to the destination Buffer * instance, injecting the MSBs stored in the septett byte during the process. * * @param {Buffer} srcBuffer Buffer to copy from * @param {number} srcStart Start index in the source buffer * @param {number} srcEnd End index in the source buffer * @param {Buffer} dstBuffer Buffer to copy to * @param {number} dstStart Start index in the destination buffer */ injectSeptett(srcBuffer, srcStart, srcEnd, dstBuffer, dstStart) { const septett = srcBuffer [srcEnd]; let srcIndex = srcStart, dstIndex = dstStart, mask = 1; while (srcIndex &lt; srcEnd) { let b = srcBuffer [srcIndex]; if (septett &amp; mask) { b |= 0x80; } dstBuffer [dstIndex] = b; srcIndex++; dstIndex++; mask = mask &lt;&lt; 1; } }, /** * Copies a part of the source Buffer instance to the destination Buffer * instance, extracting the MSBs during the process and storing the septett * byte to the destination buffer's end position. * * @param {Buffer} srcBuffer Buffer to copy from * @param {number} srcStart Start index in the source buffer * @param {number} srcEnd End index in the source buffer * @param {Buffer} dstBuffer Buffer to copy to * @param {number} dstStart Start index in the destination buffer */ extractSeptett(srcBuffer, srcStart, srcEnd, dstBuffer, dstStart) { let srcIndex = srcStart, dstIndex = dstStart, mask = 1, septett = 0; while (srcIndex &lt; srcEnd) { let b = srcBuffer [srcIndex]; if (b &amp; 0x80) { b &amp;= 0x7F; septett |= mask; } dstBuffer [dstIndex] = b; srcIndex++; dstIndex++; mask = mask &lt;&lt; 1; } dstBuffer [dstIndex] = septett; } }); module.exports = Header; × Search results Close "},"dlx-json-converter.js.html":{"id":"dlx-json-converter.js.html","title":"Source: dlx-json-converter.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: dlx-json-converter.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const HeaderSet = require('./header-set'); const _ = require('./lodash'); const Specification = require('./specification'); const Converter = require('./converter'); const optionKeys = [ 'specification', 'statsOnly', ]; const DLxJsonConverter = Converter.extend(/** @lends DLxJsonConverter# */ { /** * Reference to the Specification instance that is used for the binary -&gt; text conversion. * @type {Specification} */ specification: null, statsOnly: false, allHeaderSet: null, emittedStart: false, stats: null, /** * Creates a new DLxJsonConverter instance and optionally initializes its members with the given values. * * @constructs * @augments Converter * @param {object} options Initialization values * @param {object} options.specification See {@link DLxJsonConverter#specification} * * @classdesc * The DLxJsonConverter class takes HeaderSet instances, converts them into JSON * representation and then publishes that on the readable stream side * of itself. The format of the JSON data is similar to the one that is generated * by the Dataloggers DL2 and DL3. * * It does not support parsing JSON content back into HeaderSet instances (the * writable stream side). */ constructor(options) { Converter.call(this, options); _.extend(this, _.pick(options, optionKeys)); if (!this.specification) { this.specification = new Specification({ language: (options &amp;&amp; options.language) || 'en' }); } this.allHeaderSet = new HeaderSet(); this.reset(); }, reset() { this.allHeaderSet.removeAllHeaders(); this.emittedStart = false; this.stats = { headerSetCount: 0, minTimestamp: null, maxTimestamp: null, }; }, finish() { this._emitEnd(); return Converter.prototype.finish.apply(this, arguments); }, convertHeaderSet(headerSet) { const headers = headerSet.getHeaders(); this.allHeaderSet.addHeaders(headers); if (!this.statsOnly) { this._convertHeaderSetToJson(headerSet); } const spec = this.specification; const i18n = spec.i18n; const now = i18n.moment(headerSet.timestamp); const timestamp = now.valueOf(); this.stats.headerSetCount++; if ((this.stats.minTimestamp === null) || (this.stats.minTimestamp &gt; timestamp)) { this.stats.minTimestamp = timestamp; } if ((this.stats.maxTimestamp === null) || (this.stats.maxTimestamp &lt; timestamp)) { this.stats.maxTimestamp = timestamp; } }, _convertHeaderSetToJson(headerSet) { const spec = this.specification; const i18n = spec.i18n; const headers = headerSet.getHeaders(); const packetFields = spec.getPacketFieldsForHeaders(headers); const now = i18n.moment(headerSet.timestamp); const allHeaders = this.allHeaderSet.getHeaders(); const packetInfoList = _.map(allHeaders, (header, headerIndex) =&gt; { return { header, headerIndex, packetFields: [], }; }); _.forEach(packetFields, (packetField) =&gt; { const headerIndex = allHeaders.indexOf(packetField.packet); if (headerIndex &gt;= 0) { const packetInfo = packetInfoList [headerIndex]; packetInfo.packetFields.push(packetField); } }); const noneUnit = spec.getUnitById('None'); const numberType = spec.getTypeById('Number'); const packetData = _.reduce(packetInfoList, (memo, packetInfo) =&gt; { if (packetInfo.packetFields.length &gt;= 0) { const fieldData = _.map(packetInfo.packetFields, (packetField, packetFieldIndex) =&gt; { let rawValue = packetField.rawValue; const precision = packetField.packetFieldSpec.type.precision; const numberValue = spec.formatTextValueFromRawValueInternal(rawValue, noneUnit, numberType, precision, noneUnit); rawValue = +numberValue; return { field_index: packetFieldIndex, raw_value: rawValue, value: packetField.formatTextValue('None'), }; }); memo.push({ header_index: packetInfo.headerIndex, timestamp: packetInfo.header.timestamp / 1000.0, field_values: fieldData, }); } return memo; }, []); const timestamp = now.valueOf(); const headerSetData = { timestamp: timestamp / 1000.0, packets: packetData, }; this._emitStart(); const content = [ (this.stats.headerSetCount &gt; 0) ? ',' : '', JSON.stringify(headerSetData), ].join(''); this.push(content); }, _emitStart() { if (!this.emittedStart) { this.emittedStart = true; this.push('{\"headersets\":['); } }, _emitEnd() { const spec = this.specification; const allHeaders = this.allHeaderSet.getHeaders(); const allPacketFields = spec.getPacketFieldsForHeaders(allHeaders); const packetInfoList = _.map(allHeaders, (header, headerIndex) =&gt; { return { header, headerIndex, packetSpec: spec.getPacketSpecification(header), packetFields: [], }; }); _.forEach(allPacketFields, (packetField) =&gt; { const headerIndex = allHeaders.indexOf(packetField.packet); if (headerIndex &gt;= 0) { const packetInfo = packetInfoList [headerIndex]; packetInfo.packetFields.push(packetField); } }); const headersData = _.reduce(packetInfoList, (memo, packetInfo, packetInfoIndex) =&gt; { if (packetInfo.packetFields.length &gt;= 0) { const fieldsData = _.map(packetInfo.packetFields, (packetField, packetFieldIndex) =&gt; { return { id: packetField.packetFieldSpec.fieldId, filteredId: packetField.packetFieldSpec.filteredPacketFieldId, name: packetField.name, unit: packetField.packetFieldSpec.type.unit.unitText, unit_code: packetField.packetFieldSpec.type.unit.unitCode, }; }); let md; const packetSpec = packetInfo.packetSpec; let id = packetSpec.packetId; if ((md = /^(.._...._....)_10(_....)$/.exec(id)) !== null) { id = md [1] + md [2]; } let description = packetSpec.fullName; if ((md = /^(VBus )#([0-9]+:.*)$/.exec(description)) !== null) { description = md[1] + md [2]; } else { description = 'VBus 0: ' + description; } memo.push({ id, description, channel: packetSpec.channel, destination_address: packetSpec.destinationAddress, source_address: packetSpec.sourceAddress, protocol_version: packetSpec.protocolVersion, command: packetSpec.command, info: packetSpec.info, destination_name: packetSpec.destinationDevice.name, source_name: packetSpec.sourceDevice.name, fields: fieldsData, }); } return memo; }, []); const statsData = { headerset_count: this.stats.headerSetCount, min_timestamp : this.stats.minTimestamp / 1000.0, max_timestamp: this.stats.maxTimestamp / 1000.0, }; this._emitStart(); const content = [ '],\"headerset_stats\":', JSON.stringify(statsData), ',\"headers\":', JSON.stringify(headersData), ',\"language\":\"', spec.i18n.language, '\"}' ].join(''); this.push(content); this.push(null); }, _read() { // nop }, }); module.exports = DLxJsonConverter; × Search results Close "},"dlx-recorder.js.html":{"id":"dlx-recorder.js.html","title":"Source: dlx-recorder.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: dlx-recorder.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const moment = require('moment'); const request = require('request'); const _ = require('./lodash'); const VBusRecordingConverter = require('./vbus-recording-converter'); const Recorder = require('./recorder'); const optionKeys = [ 'urlPrefix', 'username', 'password', ]; const DLxRecorder = Recorder.extend(/** @lends DLxRecorder# */ { /** * The root URL to access the DLx. * @type {string} */ urlPrefix: null, /** * The username to login to the web interface. * @type {string} */ username: 'admin', /** * The password to login to the web interface. * @type {string} */ password: 'admin', /** * Creates a new DLxRecorder instance. * @constructs * @augments Recorder * * @classdesc * DLxRecorder is a recorder that can play back data recorded by a Datalogger. */ constructor(options) { Recorder.call(this, options); _.extend(this, _.pick(options, optionKeys)); }, _getOptions() { const options = Recorder.prototype._getOptions.call(this); return _.extend(options, _.pick(this, optionKeys)); }, async _playback(headerSetConsolidator, options) { const _this = this; const converter = new VBusRecordingConverter(); converter.on('headerSet', (headerSet) =&gt; { headerSetConsolidator.processHeaderSet(headerSet); }); if (options.apiAccess) { await _this._playbackApi(converter, options); } else { await _this._playbackRaw(converter, options); } converter.end(); }, async _playbackRaw(converter, options) { const _this = this; const minFilename = moment.utc(options.minTimestamp).format('[/log/]YYYYMMDD'); const maxFilename = moment.utc(options.maxTimestamp).format('[/log/]YYYYMMDD'); const filenames = await _this.getRecordingFilenames(options); const matchingFilenames = filenames.reduce((memo, filename) =&gt; { const filenamePrefix = filename.slice(0, minFilename.length); if ((filenamePrefix &gt;= minFilename) &amp;&amp; (filenamePrefix &lt;= maxFilename)) { memo.push(filename); } return memo; }, []); for (const filename of matchingFilenames) { const urlString = options.urlPrefix + filename; const urlOptions = { auth: { username: options.username, password: options.password, }, }; await _this.downloadToStream(urlString, urlOptions, converter); } }, async _playbackApi(converter, options) { const urlString = options.urlPrefix + '/dlx/download/download'; const urlOptions = { qs: { sessionAuthUsername: options.username, sessionAuthPassword: options.password, source: 'log', inputType: 'packets', outputType: 'vbus', sieveInterval: Math.round(options.interval / 1000) || 1, startDate: moment(options.minTimestamp).format('MM/DD/YYYY'), endDate: moment(options.maxTimestamp).format('MM/DD/YYYY'), dataLanguage: 'en', }, auth: { username: options.username, password: options.password, }, }; return this.downloadToStream(urlString, urlOptions, converter); }, async _playbackSyncJob(stream, syncJob) { const _this = this; if (!stream.objectMode) { throw new Error('Stream must be in object mode'); } /* var syncState = */ this._getSyncState(syncJob, 'source', 'DLxRecorder'); const availableRanges = await _this.getLazyRecordingRanges(); const ranges = Recorder.performRangeSetOperation(availableRanges, syncJob.syncStateDiffs, syncJob.interval, 'intersection'); let playedBackRanges = []; for (const range of ranges) { const options = _.extend({}, syncJob, { minTimestamp: range.minTimestamp, maxTimestamp: range.maxTimestamp, end: false, }); const newRanges = await _this.playback(stream, options); playedBackRanges = Recorder.performRangeSetOperation(playedBackRanges, newRanges, syncJob.interval, 'union'); } let handledRanges = playedBackRanges; if (handledRanges.length &gt; 0) { let maxTimestamp; if (syncJob.markGapsAsUnsynced) { maxTimestamp = handledRanges [0].minTimestamp; } else { maxTimestamp = handledRanges [handledRanges.length - 1].minTimestamp; } const notAvailableRanges = [{ minTimestamp: new Date(Date.UTC(2001, 0)), maxTimestamp, }]; handledRanges = Recorder.performRangeSetOperation(handledRanges, notAvailableRanges, syncJob.interval, 'union'); } _this._markSourceSyncRanges(handledRanges, syncJob); return playedBackRanges; }, async getLazyRecordingRanges() { const _this = this; const filenames = await _this.getRecordingFilenames(); let ranges = _.map(filenames, (filename) =&gt; { const minTimestamp = moment.utc(filename.slice(5, 13), 'YYYYMMDD'); const maxTimestamp = moment.utc(minTimestamp).add({ hours: 24 }); return { minTimestamp: minTimestamp.toDate(), maxTimestamp: maxTimestamp.toDate(), }; }); ranges = Recorder.performRangeSetOperation(ranges, [], 86400000, 'union'); return ranges; }, getRecordingFilenames() { return new Promise((resolve, reject) =&gt; { let rxBuffer = null; const filenames = []; const onResponse = function(res) { }; const onData = function(chunk) { let buffer; if (rxBuffer) { buffer = Buffer.concat([ rxBuffer, chunk ]); } else { buffer = chunk; } let string = buffer.toString('utf8'); const re = /&lt;a href=\"([0-9]{8}_[a-z]+.vbus)\"&gt;/g; let md, index; while ((md = re.exec(string)) !== null) { filenames.push('/log/' + md [1]); index = re.lastIndex; } string = string.slice(index); rxBuffer = Buffer.from(string, 'utf8'); }; const onEnd = function() { resolve(filenames.sort()); }; const onError = function(err) { reject(err); }; const urlOptions = { auth: { username: this.username, password: this.password, }, }; const stream = this._request(this.urlPrefix + '/log/', urlOptions); stream.on('response', onResponse); stream.on('data', onData); stream.on('end', onEnd); stream.on('error', onError); }); }, getRecordingInfo(filename) { return new Promise((resolve, reject) =&gt; { const info = {}; const onResponse = function(res) { info.size = res.headers ['content-length'] | 0; info.etag = res.headers.etag; }; const onEnd = function() { resolve(info); }; const onError = function(err) { reject(err); }; const urlOptions = { method: 'HEAD', auth: { username: this.username, password: this.password, }, }; const stream = this._request(this.urlPrefix + filename, urlOptions); stream.resume(); stream.on('response', onResponse); stream.on('end', onEnd); stream.on('error', onError); }); }, downloadToStream(urlString, urlOptions, stream) { return new Promise((resolve, reject) =&gt; { const onEnd = function() { resolve(); }; const onError = function(err) { reject(err); }; const req = this._request(urlString, urlOptions); req.pipe(stream, { end: false }); req.on('end', onEnd); req.on('error', onError); }); }, _request() { return request.apply(undefined, arguments); }, }); module.exports = DLxRecorder; × Search results Close "},"recorder.js.html":{"id":"recorder.js.html","title":"Source: recorder.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: recorder.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const EventEmitter = require('events').EventEmitter; const extend = require('./extend'); const Header = require('./header'); const HeaderSet = require('./header-set'); const HeaderSetConsolidator = require('./header-set-consolidator'); const _ = require('./lodash'); const { generateGUID } = require('./utils'); const optionKeys = [ 'id', 'minTimestamp', 'maxTimestamp', 'interval', 'timeToLive', ]; const Recorder = extend(EventEmitter, /** @lends Recorder# */ { /** * Identifier for this recorder instance. It may be used to reference * recorders, for example in sync data storage. * @type {string} */ id: null, /** * Minimum timestamp to use as a default during playback and * synchronization. * @type {Date} * @default '2001-01-01T00:00:00.000Z' */ minTimestamp: null, /** * Maximum timestamp to use as a default during playback and * synchronization. * @type {Date} * @default '2038-01-01T00:00:00.000Z' */ maxTimestamp: null, /** * Interval to be used as a default during playback and * synchronization. * @type {number} * @default 0 */ interval: 0, /** * Creates a new Recorder instance and optionally initializes * its members with the given values. * * @constructs * @param {object} options Initialization values for this instance's members * @param {string} options.id {@link Recorder#id} * @param {Date} options.minTimestamp {@link Recorder#minTimestamp} * @param {Date} options.maxTimestamp {@link Recorder#maxTimestamp} * @param {number} options.interval {@link Recorder#interval} * * @classdesc * A Recorder provides access to HeaderSet stores (e.g. dataloggers) by * allowing to either playback the HeaderSets in the store, record * HeaderSets to the store or synchronize two Recorders. * * The playback and record operation both use the VBusRecordingConverter * to serialize the HeaderSets to and from Node.js streams. * * The synchronization operation builds on top of this two operations * and is able to find unsynced HeaderSets in the source Recorder. * Thoses unsynced HeaderSets are then played back from the source Recorder * and recorded in the destination Recorder. * * The storage mechanism and format of the Recorder sub-classes is * implementation-specific to this class. */ constructor(options) { EventEmitter.call(this); _.extend(this, _.pick(options, optionKeys)); if (!this.id) { this.id = generateGUID(); } if (!this.minTimestamp) { this.minTimestamp = new Date(Date.UTC(2001, 0)); } if (!this.maxTimestamp) { this.maxTimestamp = new Date(Date.UTC(2038, 0)); } }, _getOptions() { return _.extend({}, _.pick(this, optionKeys)); }, /** * Plays back a given range of HeaderSets. The stream must be in object mode. * * @param {Writable} stream A writable stream * @param {object} options Options to select and filter HeaderSets * @param {Date} [options.minTimestamp] {@link Recorder#minTimestamp} * @param {Date} [options.maxTimestamp] {@link Recorder#maxTimestamp} * @param {number} [options.interval] {@link Recorder#interval} * @param {boolean} [options.end=true] Whether the stream should be `end()`ed when the playback is complete */ async playback(stream, options) { const _this = this; options = _.defaults({}, options, this._getOptions(), { end: true }); if (!stream.objectMode) { throw new Error('Stream must be in object mode'); } const headerSetConsolidator = new HeaderSetConsolidator({ minTimestamp: options.minTimestamp, maxTimestamp: options.maxTimestamp, interval: options.interval, }); let playedBackRanges = []; headerSetConsolidator.on('headerSet', (headerSet) =&gt; { const timestamp = headerSet.timestamp; const headerSetRange = { minTimestamp: timestamp, maxTimestamp: timestamp, }; playedBackRanges = Recorder.performRangeSetOperation(playedBackRanges, [ headerSetRange ], options.interval, 'union'); stream.write(headerSet); }); await _this._playback(headerSetConsolidator, options); if (options.end) { await new Promise((resolve) =&gt; { stream.end(() =&gt; { resolve(); }); }); } return playedBackRanges; }, _playback(headerSetConsolidator, options) { throw new Error('Must be implemented by sub-class'); }, /** * Records a given range of HeaderSet instances. The stream must be in object mode. * * @param {Readable} stream A readable stream in object mode. * @param {object} options Options to select and filter HeaderSet instances. * @param {Date} [options.minTimestamp] See {@link Recorder#minTimestamp} * @param {Date} [options.maxTimestamp] See {@link Recorder#maxTimestamp} * @param {number} [options.interval] See {@link Recorder#interval} * @return {Promise} A Promise that resolves to the recorded ranges. */ async record(stream, options) { const _this = this; options = _.defaults({}, options, this._getOptions(), { }); if (!stream.objectMode) { throw new Error('Stream must be in object mode'); } const headerSetConsolidator = new HeaderSetConsolidator({ minTimestamp: options.minTimestamp, maxTimestamp: options.maxTimestamp, interval: options.interval, timeToLive: options.timeToLive, }); let recordedRanges = []; headerSetConsolidator.on('headerSet', (headerSet) =&gt; { const timestamp = headerSet.timestamp; const headerSetRange = { minTimestamp: timestamp, maxTimestamp: timestamp, }; recordedRanges = Recorder.performRangeSetOperation(recordedRanges, [ headerSetRange ], options.interval, 'union'); }); const recordingJob = _.defaults({}, options, { recordedRanges, }); const recording = await _this._startRecording(headerSetConsolidator, recordingJob); try { await new Promise((resolve, reject) =&gt; { let onData = undefined, onEnd = undefined, onError = undefined; const cleanup = function() { stream.removeListener('data', onData); stream.removeListener('end', onEnd); stream.removeListener('error', onError); }; onData = function(obj) { if (obj instanceof Header) { headerSetConsolidator.addHeader(obj); } else if (obj instanceof HeaderSet) { headerSetConsolidator.processHeaderSet(obj); } else { throw new Error('Unsupported object received by Recorder'); } }; onEnd = function() { cleanup(); resolve(); }; onError = function(err) { cleanup(); reject(err); }; stream.on('data', onData); stream.on('end', onEnd); stream.on('error', onError); stream.resume(); }); } finally { await _this._endRecording(headerSetConsolidator, recordingJob, recording); } return recordedRanges; }, _startRecording(headerSetConsolidator, recordingJob) { throw new Error('Must be implemented by sub-class'); }, _endRecording(headerSetConsolidator, recordingJob, recording) { throw new Error('Must be implemented by sub-class'); }, /** * Synchronize this Recorder's HeaderSets to another Recorder. * * @param {Recorder} recorder Destination Recorder * @param {object} options Options to select and filter HeaderSets * @param {Date} [options.minTimestamp] {@link Recorder#minTimestamp} * @param {Date} [options.maxTimestamp] {@link Recorder#maxTimestamp} * @param {number} [options.interval] {@link Recorder#interval} * @returns {Promise} Promise resolving with a list of ranges that were synchronized. */ async synchronizeTo(recorder, options) { const _this = this; options = _.extend({}, this._getOptions(), options); let oldSyncState = await recorder._getCurrentSyncState(options); oldSyncState = _.cloneDeep(oldSyncState); if (!oldSyncState.sourceSyncState) { oldSyncState.sourceSyncState = {}; } if (!oldSyncState.destinationSyncState) { oldSyncState.destinationSyncState = {}; } const syncJob = await _this._getSyncJob(oldSyncState, options); return recorder._recordSyncJob(_this, syncJob); }, _getCurrentSyncState(options) { throw new Error('Must be implemented by sub-class'); }, _getSyncJob(oldSyncState, options) { const syncJob = _.extend({}, options, { syncId: generateGUID(), syncState: oldSyncState, syncStateDiffs: [], }); const syncState = this._getSyncState(syncJob, 'source', 'Recorder'); // migrate let syncVersion = syncState.version || 0; if (syncVersion === 0) { syncVersion = 1; syncState.rangesByInterval = {}; } syncState.version = syncVersion; if (!syncState.rangesByInterval [options.interval]) { syncState.rangesByInterval [options.interval] = []; } // find diffs let syncStateDiffs = syncJob.syncStateDiffs; syncStateDiffs.push({ minTimestamp: options.minTimestamp, maxTimestamp: options.maxTimestamp, }); _.forEach(syncState.rangesByInterval, (ranges, rangesKey) =&gt; { const interval = rangesKey | 0; if ((options.interval % interval) === 0) { ranges = _.map(ranges, (range) =&gt; { return { minTimestamp: Recorder.alignTimestampToInterval(range.minTimestamp, interval), maxTimestamp: Recorder.alignTimestampToInterval(range.maxTimestamp, interval) + interval, }; }); syncStateDiffs = Recorder.performRangeSetOperation(syncStateDiffs, ranges, interval, 'difference'); } }); syncJob.syncStateDiffs = syncStateDiffs; return Promise.resolve(syncJob); }, /** * Starts a playback of the provided recorder, recording its data and returning a * Promise that resolves to the recorded ranges. * * @param {Recorder} recorder The recorder to use for playback * @param {RecorderSyncJob} syncJob The synchronization job to perform. * @returns {Promise} Promise resolving with a list of ranges that were synchronized. */ _recordSyncJob(recorder, syncJob) { throw new Error('Must be implemented by sub-class'); }, /** * Plays back the requested synchronization job, piping the resulting data into the * provided stream. Returns a Promise that resolves to the played back ranges. * * @param {Stream} stream The stream (in object mode) to pipe data into * @param {RecorderSyncJob} syncJob The synchronization job to perform. * @returns {Promise} Promise resolving with a list of ranges that were synchronized. */ _playbackSyncJob(stream, syncJob) { throw new Error('Must be implemented by sub-class'); }, _getSyncState(syncJobOrState, which, type) { let syncState; if (_.has(syncJobOrState, 'syncState') &amp;&amp; _.has(syncJobOrState, 'syncId')) { syncState = syncJobOrState.syncState; } else { syncState = syncJobOrState; } const syncStateKey = which + 'SyncState'; if (!_.has(syncState, syncStateKey)) { syncState [syncStateKey] = {}; } const syncStateRoot = syncState [syncStateKey]; if (!_.has(syncStateRoot, type)) { syncStateRoot [type] = {}; } return syncStateRoot [type]; }, _markSourceSyncRanges(ranges, syncJob) { const syncState = this._getSyncState(syncJob, 'source', 'Recorder'); let handledRanges = syncState.rangesByInterval [syncJob.interval]; handledRanges = Recorder.performRangeSetOperation(handledRanges, ranges, syncJob.interval, 'union'); syncState.rangesByInterval [syncJob.interval] = handledRanges; }, }, /** @lends Recorder. */ { alignTimestampToInterval(timestamp, interval) { if (typeof timestamp.getTime === 'function') { timestamp = timestamp.getTime(); } else if (typeof timestamp === 'string') { timestamp = new Date(timestamp).getTime(); } else if (typeof timestamp !== 'number') { throw new Error('Invalid timestamp \"' + timestamp + '\" (type \"' + typeof timestamp + '\"'); } if (_.isNumber(interval) &amp;&amp; (interval &gt; 0)) { return Math.floor(timestamp / interval) * interval; } else { return timestamp; } }, /** * Performs operations on two sets of timestamp ranges. * * Timestamp ranges are objects with two properties: `minTimestamp` and `maxTimestamp`. * * The operations correspond to the operations in mathematic's set theory. * Currently supported are union, difference and intersection. * * See [http://en.wikipedia.org/wiki/Set_theory]() for details. * * @param {Array} rangesA Set A containing timestamp ranges * @param {Array} rangesB Set B containing timestamp ranges * @param {number} interval Interval to allow between adjacent timestamp ranges * @param {string} operation Operation to perform, can be `'union'`, `'difference'` or `'intersection'` * @returns {Array} Set containing timestamp ranges after the operation */ performRangeSetOperation(rangesA, rangesB, interval, operation) { let newInfos = []; const calcBaseTimestamp = function(timestamp) { if (interval &gt; 0) { return Math.floor(timestamp / interval) * interval; } else { return timestamp; } }; const rangeToInfo = function(range) { let minTimestamp = range.minTimestamp; if (typeof minTimestamp.getTime === 'function') { minTimestamp = minTimestamp.getTime(); } else if (typeof minTimestamp === 'string') { minTimestamp = new Date(minTimestamp).getTime(); } else if (typeof minTimestamp !== 'number') { throw new Error('Invalid minTimestamp \"' + minTimestamp + '\" (type \"' + typeof minTimestamp + '\"'); } let maxTimestamp = range.maxTimestamp; if (typeof maxTimestamp.getTime === 'function') { maxTimestamp = maxTimestamp.getTime(); } else if (typeof maxTimestamp === 'string') { maxTimestamp = new Date(maxTimestamp).getTime(); } else if (typeof maxTimestamp !== 'number') { throw new Error('Invalid maxTimestamp \"' + maxTimestamp + '\" (type \"' + typeof maxTimestamp + '\"'); } const minBaseTimestamp = calcBaseTimestamp(minTimestamp); const maxBaseTimestamp = calcBaseTimestamp(maxTimestamp + interval); return { minTimestamp, maxTimestamp, minBaseTimestamp, maxBaseTimestamp, valid: true, }; }; const infoToRange = function(info) { let range; if (info &amp;&amp; info.valid) { range = { minTimestamp: new Date(info.minTimestamp), maxTimestamp: new Date(info.maxTimestamp), }; } return range; }; const processInfo = function(refInfo, operation) { if (!refInfo || !refInfo.valid || (refInfo.minTimestamp &gt; refInfo.maxTimestamp)) { return; } let nextInfo; for (let i = 0; i &lt;= newInfos.length; i++) { const newInfo = newInfos [i]; for (let j = i + 1; j &lt; newInfos.length; j++) { if (newInfos [j].valid) { nextInfo = newInfos [j]; break; } } let insert = false, deleteThis = false; if (newInfo &amp;&amp; !newInfo.valid) { // skip } else if (operation === 'union') { if (i === newInfos.length) { // append insert = true; } else if (refInfo.minBaseTimestamp &gt; newInfo.maxBaseTimestamp) { // skip } else if (refInfo.maxBaseTimestamp &lt; newInfo.minBaseTimestamp) { // insert insert = true; } else if (nextInfo &amp;&amp; (refInfo.maxBaseTimestamp &gt;= nextInfo.minBaseTimestamp)) { // union into next info if (refInfo.minTimestamp &gt; newInfo.minTimestamp) { refInfo.minTimestamp = newInfo.minTimestamp; } if (refInfo.minBaseTimestamp &gt; newInfo.minBaseTimestamp) { refInfo.minBaseTimestamp = newInfo.minBaseTimestamp; } newInfo.valid = false; } else { // union into this info if (newInfo.minTimestamp &gt; refInfo.minTimestamp) { newInfo.minTimestamp = refInfo.minTimestamp; } if (newInfo.maxTimestamp &lt; refInfo.maxTimestamp) { newInfo.maxTimestamp = refInfo.maxTimestamp; } if (newInfo.minBaseTimestamp &gt; refInfo.minBaseTimestamp) { newInfo.minBaseTimestamp = refInfo.minBaseTimestamp; } if (newInfo.maxBaseTimestamp &lt; refInfo.maxBaseTimestamp) { newInfo.maxBaseTimestamp = refInfo.maxBaseTimestamp; } break; } } else if (operation === 'difference') { if (i === newInfos.length) { // skip } else if (refInfo.minBaseTimestamp &gt; newInfo.maxBaseTimestamp) { // skip } else if (refInfo.maxBaseTimestamp &lt; newInfo.minBaseTimestamp) { // skip } else if (refInfo.minBaseTimestamp &lt;= newInfo.minBaseTimestamp) { if (refInfo.maxBaseTimestamp &gt;= newInfo.maxBaseTimestamp) { deleteThis = true; } else { if (newInfo.minTimestamp &lt; refInfo.maxTimestamp + 1) { newInfo.minTimestamp = refInfo.maxTimestamp + 1; } newInfo.minBaseTimestamp = refInfo.maxBaseTimestamp + 1; } } else if (refInfo.maxBaseTimestamp &gt;= newInfo.maxBaseTimestamp) { if (newInfo.maxTimestamp &gt; refInfo.minTimestamp - 1) { newInfo.maxTimestamp = refInfo.minTimestamp - 1; } newInfo.maxBaseTimestamp = refInfo.minBaseTimestamp - 1; } else { // split const splitInfo = { minTimestamp: newInfo.minTimestamp, maxTimestamp: refInfo.minTimestamp - 1, minBaseTimestamp: newInfo.minBaseTimestamp, maxBaseTimestamp: refInfo.minBaseTimestamp - 1, valid: true, }; newInfos.splice(i, 0, splitInfo); newInfo.minTimestamp = refInfo.maxBaseTimestamp + 1; newInfo.minBaseTimestamp = refInfo.maxBaseTimestamp + 1; break; } } else { throw new Error('Unknown set operation \"' + operation + '\"'); } if (insert) { newInfos.splice(i, 0, _.clone(refInfo)); break; } else if (deleteThis) { newInfo.valid = false; } } }; const processInfos = function(infos, operation) { _.forEach(_.clone(infos), (info, index) =&gt; { processInfo(info, operation); }); }; const infosA = _.map(rangesA, rangeToInfo); const infosB = _.map(rangesB, rangeToInfo); if (operation === 'intersection') { processInfos(infosA, 'union'); processInfos(infosB, 'difference'); const infosAMinusB = newInfos; newInfos = []; processInfos(infosB, 'union'); processInfos(infosA, 'difference'); const infosBMinusA = newInfos; newInfos = []; processInfos(infosA, 'union'); processInfos(infosB, 'union'); processInfos(infosAMinusB, 'difference'); processInfos(infosBMinusA, 'difference'); } else { _.forEach(infosA, (info) =&gt; { processInfo(info, 'union'); }); _.forEach(infosB, (info) =&gt; { processInfo(info, operation); }); } const newRanges = []; _.forEach(newInfos, (newInfo) =&gt; { const newRange = infoToRange(newInfo); if (newRange) { newRanges.push(newRange); } }); return newRanges; }, }); module.exports = Recorder; × Search results Close "},"extend.js.html":{"id":"extend.js.html","title":"Source: extend.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: extend.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const _ = require('./lodash'); /** * A helper method for classical inheritance. * * @param {?function} parent Parent class constructor * @param {?object} protoProps Properties to be mixed-in the prototype of * the child class * @param {?object} staticProps Properties to be mixed-in the constructor * function of the child class * @returns {function} Child class constructor */ const extend = function(parent, protoProps, staticProps) { let child; if (protoProps &amp;&amp; _.has(protoProps, 'constructor')) { child = function(...args) { return protoProps.constructor.apply(this, args); }; } else if (parent) { child = function(...args) { return parent.apply(this, args); }; } else { child = function() { // nop }; } _.extend(child, parent, staticProps); const Surrogate = function() { this.constructor = child; }; if (parent) { Surrogate.prototype = parent.prototype; } child.prototype = new Surrogate(); if (protoProps) { _.extend(child.prototype, protoProps); } if (parent) { child.__super__ = parent.prototype; } if (!_.has(child, 'extend')) { child.extend = function(protoProps, staticProps) { return extend(this, protoProps, staticProps); }; } return child; }; module.exports = extend; × Search results Close "},"header-set.js.html":{"id":"header-set.js.html","title":"Source: header-set.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: header-set.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const crypto = require('crypto'); const EventEmitter = require('events').EventEmitter; const extend = require('./extend'); const _ = require('./lodash'); const idHashes = {}; const optionKeys = [ 'timestamp', ]; const HeaderSet = extend(EventEmitter, /** @lends HeaderSet# */ { /** * Timestamp of the youngest Header instance added to this set. * @type {Date} */ timestamp: null, /** * Array of Header instances in this set. * @type {Header[]} */ headerList: null, /** * Creates a new header set instance and optionally initializes its members with the given values. * * @constructs * @augments EventEmitter * @param {object} options Initialization values for this instance's members * @param {Date} options.timestamp {@link HeaderSet#timestamp} * @param {Header[]} options.headers Array of Headers to add to this instance */ constructor(options) { EventEmitter.call(this); this.headerList = []; _.extend(this, _.pick(options, optionKeys)); if (!this.timestamp) { this.timestamp = new Date(); } if (_.has(options, 'headers')) { this.addHeaders(options.headers); } }, _findIndex(header) { return _.findIndex(this.headerList, (refHeader) =&gt; { return (refHeader.compareTo(header) === 0); }); }, /** * Returns `true` if a Header of the same kind is already added to the HeaderSet. * * @params {Header} header The Header instance to check for. * @returns {boolean} `true` if a Header of the same kind is already in the HeaderSet, `false` otherwise. */ containsHeader(header) { const index = this._findIndex(header); return (index &gt;= 0); }, /** * Adds a Header instance to this set, replacing a previously added Header of same kind. * * @param {Header} header The Header instance to add to this set. */ addHeader(header) { const index = this._findIndex(header); if (index &gt;= 0) { this.headerList [index] = header; } else { this.headerList.push(header); } if (this.timestamp.getTime() &lt; header.timestamp.getTime()) { this.timestamp = header.timestamp; } /** * This event is fired whenever a Header instance is added to this set. * * @event HeaderSet#addHeader * @type {Header} */ this.emit('addHeader', header); }, /** * Adds a list of Header instances to this set, replacing previously added Headers of same kind. * * @param {Header[]} headers The list of Header instances to add. */ addHeaders(headers) { const _this = this; _.forEach(headers, (header) =&gt; { _this.addHeader(header); }); }, _removeHeader(header) { const index = this._findIndex(header); if (index &gt;= 0) { /** * This event is fired whenever a Header is removed from this set. * * @event HeaderSet#removeHeader * @type {Header} */ this.emit('removeHeader', this.headerList [index]); this.headerList.splice(index, 1); } }, _removeHeaders(headers) { const _this = this; _.forEach(headers, (header) =&gt; { _this._removeHeader(header); }); }, /** * Removes all Header instances from this set. */ removeAllHeaders() { this._removeHeaders(this.headerList.slice(0)); }, /** * Removes all Header instances from this set which are older than the given timestamp. * * @param {number|Date} timestamp Timestamp to compare Header instances against. */ removeHeadersOlderThan(timestamp) { let time; if (typeof timestamp === 'number') { time = timestamp; } else { time = timestamp.getTime(); } const headers = []; _.forEach(this.headerList, (header) =&gt; { if (header.timestamp.getTime() &lt; time) { headers.push(header); } }); this._removeHeaders(headers); }, /** * Returns the count of Header instances currently stored in this set. * * @returns {number} Number of Header instances in this set. */ getHeaderCount() { return this.headerList.length; }, /** * Returns an unsorted list of Header instances stored in this set. * * @returns {Header[]} List of headers stored in this set. */ getHeaders() { return this.headerList.slice(0); }, /** * Returns a sorted list of Header instances stored in this set. * * @returns {Header[]} List of headers stored in this set. */ getSortedHeaders() { const sortedHeaders = this.headerList.slice(0).sort((left, right) =&gt; { return left.compareTo(right); }); return sortedHeaders; }, getSortedHeaderSet() { const headerSet = new HeaderSet({ headers: this.getSortedHeaders(), }); headerSet.timestamp = this.timestamp; return headerSet; }, /** * Returns an ID composed of the IDs of all headers stored in this set. * * @returns {string} ID of this HeaderSet. */ getId() { const sortedHeaders = this.getSortedHeaders(); const sortedIds = _.map(sortedHeaders, (header) =&gt; { return header.getId(); }); const id = sortedIds.join(','); return id; }, /** * Returns an ID hash for this HeaderSet instance. * * @returns {string} ID hash for this HeaderSet */ getIdHash() { const id = this.getId(); if (!_.has(idHashes, id)) { const shasum = crypto.createHash('sha256'); shasum.update(id); idHashes [id] = shasum.digest('hex'); } return idHashes [id]; }, }); module.exports = HeaderSet; × Search results Close "},"header-set-consolidator.js.html":{"id":"header-set-consolidator.js.html","title":"Source: header-set-consolidator.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: header-set-consolidator.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const HeaderSet = require('./header-set'); const _ = require('./lodash'); const optionKeys = [ 'interval', 'timeToLive', 'minTimestamp', 'maxTimestamp', ]; const HeaderSetConsolidator = HeaderSet.extend(/** @lends HeaderSetConsolidator# */ { /** * The interval in which the `headerSet` event should be emitted. * @type {number} */ interval: 0, /** * Header instances that are older then this duration are removed from the set. * @type {number} */ timeToLive: 0, /** * HeaderSet instances from a time before this Date are ignored. * @type {Date} */ minTimestamp: null, /** * HeaderSet instances from a time after this Date are ignored. * @type {Date} */ maxTimestamp: null, lastIntervalTime: 0, timer: null, /** * Creates a new instances and optionally initializes its members to the given values. * * @constructs * @augments HeaderSet * * @param {object} options * @param {number} options.interval See {@link HeaderSetConsolidator#interval} * @param {number} options.timeToLive See {@link HeaderSetConsolidator#timeToLive} * @param {number} options.minTimestamp See {@link HeaderSetConsolidator#minTimestamp} * @param {number} options.maxTimestamp See {@link HeaderSetConsolidator#maxTimestamp} * * @classdesc * The HeaderSetConsolidator extends the functionality of the HeaderSet class * by allowing to filter and organize the Header instances added to it. * * There are two common use cases for this class: * * The first use case is in combination with a Connection. As live Header instances * are reported by their corresponding event they are aded to the HeaderSetConsolidator * instance using `addHeader` or `addHeaders` methods. The `startTimer` method * is used to start a background timer that fires a `headerSet` event every * time the given interval has passed. * * The second use case is in combination with Recorders. In that case no timer * has to be started because the data is not received in real time. As recorded HeaderSet * instances are played back they are can be handed over to the `processHeaderSet` * method. This method will fire a `headerSet` event every time the recorded data * belong to a different interval. * * @example * * // --- use case 1: live data --- * var connection = createConnection(); * * // create a HeaderSetConsolidator that fires a headerSet event every minute * var hsc = new HeaderSetConsolidator({ interval: 1 * 60 * 1000 }); * * // add an event handlers to the connection that adds incoming headers to the consolidator * var onHeader = function(header) { * hsc.addHeader(header); * }; * * connection.on('packet', onHeader); * connection.on('datagram', onHeader); * connection.on('telegram', onHeader); * * // add an event handler to the consolidator * hsc.on('headerSet', function(headerSet) { * console.log(headerSet); * }); * * // start the timer * hsc.startTimer(); * * * * // --- use case 2: recorded data --- * var stream = getRecordedDataStream(); * * var converter = new VBusRecordingConverter(); * * // create a HeaderSetConsolidator that sieves incoming headers * var hsc = new HeaderSetConsolidator({ interval: 60 * 60 * 1000 }); * * // add an event handler to the converter that processes incoming header sets in the consolidator * converter.on('headerSet', function(headerSet) { * hsc.processHeaderSet(headerSet); * }); * * // add an event handler to the consolidator * hsc.on('headerSet', function(headerSet) { * console.log(headerSet); * }); * * // start the conversion * stream.pipe(converter); */ constructor(options) { HeaderSet.call(this, options); _.extend(this, _.pick(options, optionKeys)); }, /** * Starts a timer that processes live HeaderSets automatically. */ startTimer() { this.stopTimer(); this.lastIntervalTime = Date.now(); this._handleInterval(); }, /** * Stops the timer that was started by `startTimer`. */ stopTimer() { if (this.timer) { clearTimeout(this.timer); this.timer = null; } }, /** * Process the given HeaderSet instance. The Header instances in it are * added to the HeaderSetConsolidator. * * @param {HeaderSet} headerSet The HeaderSet instance to process. */ processHeaderSet(headerSet) { const now = headerSet.timestamp.getTime(); this.addHeaders(headerSet.getHeaders()); this._processHeaderSet(now); }, _handleInterval() { const _this = this; const now = Date.now(); this._processHeaderSet(now); const interval = 1000 - (now % 1000); this.timer = setTimeout(() =&gt; { _this._handleInterval(); }, interval); }, _processHeaderSet(now) { let include = true; if (this.minTimestamp) { if (now &lt; this.minTimestamp) { include = false; } } if (this.maxTimestamp) { if (now &gt; this.maxTimestamp) { include = false; } } if (this.interval &gt; 0) { const lastInterval = Math.floor(this.lastIntervalTime / this.interval); const currentInterval = Math.floor(now / this.interval); const diff = currentInterval - lastInterval; if ((diff &gt;= -1) &amp;&amp; (diff &lt;= 0)) { include = false; } } if (include) { if (this.timeToLive &gt; 0) { this.removeHeadersOlderThan(now - this.timeToLive); } this.timestamp = new Date(now); this.emit('headerSet', this); this.lastIntervalTime = now; } }, }); module.exports = HeaderSetConsolidator; × Search results Close "},"i18n.js.html":{"id":"i18n.js.html","title":"Source: i18n.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: i18n.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const moment = require('moment-timezone'); const numeral = require('numeral'); require('numeral/locales/de'); const sprintf = require('sprintf-js').sprintf; const extend = require('./extend'); const _ = require('./lodash'); const knownLanguages = { 'de': { moment: 'de', numeral: 'de', }, 'en': { moment: 'en', numeral: 'en', }, }; const resources = { dev: { translation: require('./locales/dev.json') }, de: { translation: require('./locales/de.json') }, }; const I18N = extend(null, /** @lends I18N# */ { language: null, languageData: null, timezone: null, /** * Creates a new I18N instance for the given language code. * * @constructs * @param {string} [language='en'] Language code (ISO 639-1) */ constructor(language) { if (!language || !_.has(knownLanguages, language)) { language = 'en'; } this.language = language; this.languageData = knownLanguages [language]; }, /** * Formats a string using a `printf(3)` compatible format string and * variadic arguments (comparable to `sprintf(3)`) and returns it. * * @param {string} fmt Format string * @param {...mixed} args Arguments to format * @returns {string} Formatted string * * @see http://linux.die.net/man/3/sprintf * @see http://www.diveintojavascript.com/projects/javascript-sprintf * * @example * // outputs: VBus #3: DeltaSol MX * console.log(i18n.sprintf('VBus #%d: %s', 3, 'DeltaSol MX')); * * // outputs: DeltaSol MX * console.log(i18n.sprintf('%2$s', 3, 'DeltaSol MX')); */ sprintf() { return sprintf.apply(null, arguments); }, /** * Formats a string using a `printf(3)` compatible format string and * a arguments array (comparable to `vsprintf(3)`) and returns it. * * @param {string} fmt Format string * @param {Array} argv Arguments to format * @returns {string} Formatted string * * @example * // outputs: VBus #3: DeltaSol MX * console.log(i18n.vsprintf('VBus #%d: %s', [ 3, 'DeltaSol MX' ])); * * // outputs: DeltaSol MX * console.log(i18n.vsprintf('%2$s', [ 3, 'DeltaSol MX' ])); */ vsprintf(fmt, argv) { const args = argv.slice(0); args.splice(0, 0, fmt); return sprintf.apply(null, args); }, /** * Get a translation for the given key. If more than one argument is * given, the translation is then used as a format string for the * {@link I18N#sprintf} method. * * @param {string} key Key for the translation * @param {...mixed} args Arguments to format * @return {string} Formatted string * * @example * var i18n = new I18N('de'); * * // outputs: Unbekanntes Gerät (0x%1$04X) * console.log(i18n.t('specification.unknownDevice')); * * // outputs: Unbekanntes Gerät (0x7E11) * console.log(i18n.t('specification.unknownDevice', 0x7e11)); */ t(key) { const parts = key.split('.'); const languages = [ this.language, 'dev' ]; let value; for (let i = 0; i &lt; languages.length; i++) { value = resources [languages [i]]; value = value &amp;&amp; value.translation; let j = 0; while (value &amp;&amp; (j &lt; parts.length)) { value = value [parts [j]]; j++; } if (value) { break; } } let text = value || key; if (arguments.length &gt; 1) { const args = _.toArray(arguments).slice(1); text = this.vsprintf(text, args); } return text; }, /** * Wrapper for a moment.js date object that is setup to use this * instance's language code. * * @param {...mixed} args Arguments to be passed to `moment()` function * @returns {mixed} Result of calling the `moment()` function * * @see http://momentjs.com/docs/ */ moment() { let m = moment.apply(null, arguments).locale(this.languageData.moment); if (this.timezone) { m = m.tz(this.timezone); } return m; }, /** * Wrapper for a moment.js UTC date object that is setup to use this * instance's language code. * * @param {...mixed} args Arguments to be passed to `moment.utc()` function * @returns {mixed} Result of calling the `moment.utc()` function * * @see http://momentjs.com/docs/ */ momentUtc() { const m = moment.utc.apply(null, arguments).locale(this.languageData.moment); return m; }, momentTz() { const m = moment.tz.apply(moment, arguments).locale(this.languageData.moment); return m; }, momentTzZone() { const z = moment.tz.zone.apply(moment.tz, arguments); return z; }, /** * Wrapper for a numeral.js number object that is setup to use this * instance's language code. * * @param {...mixed} args Arguments to be passes to `numeral()` function * @returns {mixes} Result of calling the `numeral()` function * * @see http://numeraljs.com/ */ numeral() { numeral.locale(this.languageData.numeral); return numeral.apply(null, arguments); }, }); module.exports = I18N; × Search results Close "},"packet.js.html":{"id":"packet.js.html","title":"Source: packet.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: packet.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const sprintf = require('sprintf-js').sprintf; const Header = require('./header'); const _ = require('./lodash'); const optionKeys = [ 'command', 'frameCount', ]; const Packet = Header.extend(/** @lends Packet# */ { /** * The command field of this VBus packet. See the VBus Protocol specification for details. * @type {number} */ command: 0, /** * The number of frames of this VBus packet. Each frame can hold four bytes of payload. * @type {number} */ frameCount: 0, /** * The buffer containing the frame data of this VBus packet. */ frameData: null, /** * Creates a new Packet instance and optionally initializes its members with the given values. * * @constructs * @augments Header * @param {object} options Initialization values for this instance's members * @param {number} options.command {@link Packet#command} * @param {number} options.frameCount {@link Packet#frameCount} * @param {Buffer} options.frameData {@link Packet#frameData} * @see Header#constructor * * @classdesc * The Packet sub-class provides access to all properties and methods applicable for VBus version 1 packets. * In addition to the packet header it may contain up to 508 bytes of payload data. * The structure of the payload depends on the combination of destination and source addresses as well as * the command of the packet. The different payloads are described in further detail * in Chapter H of the VBus Protocol Specification and can be decoded using a Specification instance. * * @see Specification */ constructor(options) { Header.call(this, options); _.extend(this, _.pick(options, optionKeys)); if (_.has(options, 'frameData') &amp;&amp; _.has(options, 'dontCopyFrameData') &amp;&amp; options.dontCopyFrameData) { this.frameData = options.frameData; } else { this.frameData = Buffer.alloc(127 * 4); this.frameData.fill(0); if (_.has(options, 'frameData')) { const minLength = Math.min(this.frameData.length, options.frameData.length); options.frameData.copy(this.frameData, 0, 0, minLength); } } }, toLiveBuffer(origBuffer, start, end) { const length = 10 + this.frameCount * 6; let buffer; if (origBuffer === undefined) { buffer = Buffer.alloc(length); } else if (start + length &lt;= end) { buffer = origBuffer.slice(start, start + length); } else { throw new Error('Buffer too small'); } buffer [0] = 0xAA; buffer.writeUInt16LE(this.destinationAddress &amp; 0x7F7F, 1); buffer.writeUInt16LE(this.sourceAddress &amp; 0x7F7F, 3); buffer [5] = 0x10; buffer.writeUInt16LE(this.command &amp; 0x7F7F, 6); buffer [8] = this.frameCount &amp; 0x7F; Packet.calcAndSetChecksumV0(buffer, 1, 9); for (let i = 0; i &lt; this.frameCount; i++) { const srcStart = 4 * i; const dstStart = 10 + 6 * i; Packet.extractSeptett(this.frameData, srcStart, srcStart + 4, buffer, dstStart); Packet.calcAndSetChecksumV0(buffer, dstStart, dstStart + 5); } return buffer; }, getProtocolVersion() { return 0x10; }, getId() { const baseId = Header.prototype.getId.call(this); return sprintf('%s_%04X', baseId, this.command); }, compareTo(that) { let result = Header.prototype.compareTo.apply(this, arguments); if (result === 0) { result = this.command - that.command; } return result; }, }, /** @lends Packet */ { fromLiveBuffer(buffer, start, end) { const frameCount = buffer [start + 8]; const frameData = Buffer.alloc(127 * 4); frameData.fill(0); for (let frameIndex = 0; frameIndex &lt; frameCount; frameIndex++) { const sourceStart = start + 10 + frameIndex * 6; const targetStart = frameIndex * 4; Packet.injectSeptett(buffer, sourceStart, sourceStart + 4, frameData, targetStart); } return new Packet({ destinationAddress: buffer.readUInt16LE(start + 1), sourceAddress: buffer.readUInt16LE(start + 3), command: buffer.readUInt16LE(start + 6), frameCount, frameData, dontCopyFrameData: true }); } }); module.exports = Packet; × Search results Close "},"serial-connection.js.html":{"id":"serial-connection.js.html","title":"Source: serial-connection.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: serial-connection.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; let SerialPort; try { SerialPort = require('serialport'); } catch (ex) { // eat it } const Connection = require('./connection'); const _ = require('./lodash'); const optionKeys = [ 'path', ]; const SerialConnection = Connection.extend(/** @lends SerialConnection# */ { /** * The path to the serial port. * @type {string} */ path: null, /** * Timeout in milliseconds to way between reconnection retries. * @type {number} */ reconnectTimeout: 0, /** * Value to increment timeout after every unsuccessful reconnection retry. * @type {number} */ reconnectTimeoutIncr: 10000, /** * Maximum timeout value between unsuccessful reconnection retry. * @type {number} */ reconnectTimeoutMax: 60000, serialPort: null, /** * Creates a new SerialConnection instance and optionally initialized its member with the given values. * * @constructs * @augments Connection * @param {object} options Initialization values * @param {string} options.path See {@link SerialConnection#path} * * @classdesc * The SerialConnection class provides asscess to a VBus live data stream using a serial port. */ constructor(options) { Connection.call(this, options); _.extend(this, _.pick(options, optionKeys)); }, connect() { if (this.connectionState !== SerialConnection.STATE_DISCONNECTED) { throw new Error('Connection is not disconnected (' + this.connectionState + ')'); } this._setConnectionState(SerialConnection.STATE_CONNECTING); return this._connect(); }, disconnect() { if (this.connectionState !== SerialConnection.STATE_DISCONNECTED) { const previousConnectionState = this.connectionState; this._setConnectionState(SerialConnection.STATE_DISCONNECTING); if (this.serialPort &amp;&amp; (previousConnectionState !== SerialConnection.STATE_CONNECTING)) { this.serialPort.close(); } else { this._setConnectionState(SerialConnection.STATE_DISCONNECTED); } } }, _connect() { const _this = this; let serialPort = undefined; return new Promise((resolve, reject) =&gt; { const done = function(err, result) { if (err) { reject(err); } else { resolve(result); } }; const onConnectionData = function(chunk) { serialPort.write(chunk); }; const onSerialPortData = function(chunk) { _this._write(chunk); }; const onSerialPortTermination = function() { _this.removeListener('data', onConnectionData); if (_this.serialPort !== serialPort) { // nop } else if (_this.connectionState === SerialConnection.STATE_CONNECTING) { _this._setConnectionState(SerialConnection.STATE_DISCONNECTED); _this.serialPort = null; done(new Error('Unable to connect')); } else if (_this.connectionState === SerialConnection.STATE_DISCONNECTING) { _this._setConnectionState(SerialConnection.STATE_DISCONNECTED); _this.serialPort = null; } else { _this._setConnectionState(SerialConnection.STATE_INTERRUPTED); _this.serialPort = null; const timeout = _this.reconnectTimeout; if (_this.reconnectTimeout &lt; _this.reconnectTimeoutMax) { _this.reconnectTimeout += _this.reconnectTimeoutIncr; } setTimeout(() =&gt; { _this._setConnectionState(SerialConnection.STATE_RECONNECTING); _this._connect(); }, timeout); } }; const onEnd = function() { onSerialPortTermination(); }; const onError = function() { serialPort.close(); onSerialPortTermination(); }; const onConnectionEstablished = function() { _this.reconnectTimeout = 0; _this._setConnectionState(SerialConnection.STATE_CONNECTED); done(); }; this.on('data', onConnectionData); const onCompletion = function(err) { if (err) { done(err); } }; const onDisconnect = function() { onError(); }; const options = { baudRate: 9600, dataBits: 8, stopBits: 1, parity: 'none', disconnectedCallback: onDisconnect, }; serialPort = this._createSerialPort(this.path, options, onCompletion); serialPort.once('open', () =&gt; { serialPort.on('data', onSerialPortData); serialPort.on('end', onEnd); serialPort.on('error', onError); onConnectionEstablished(); }); this.serialPort = serialPort; }); }, _createSerialPort(path, options, onCompletion) { return new SerialPort(path, options, null, onCompletion); } }, { hasSerialPortSupport: !!SerialPort, }); module.exports = SerialConnection; × Search results Close "},"serial-data-source.js.html":{"id":"serial-data-source.js.html","title":"Source: serial-data-source.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: serial-data-source.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const DataSource = require('./data-source'); const _ = require('./lodash'); const SerialConnection = require('./serial-connection'); const optionKeys = [ 'path', ]; const SerialDataSource = DataSource.extend(/** @lends SerialDataSource# */ { /** * The path to the serial port. */ path: null, /** * Creates a new SerialDataSource. * * @constructs * @augments DataSource */ constructor(options) { DataSource.call(this, options); _.extend(this, _.pick(options, optionKeys)); }, async connectLive(options) { const defaultOptions = { path: this.path, }; options = _.extend(defaultOptions, options, { provider: this.provider, dataSource: this.id, }); const connection = new SerialConnection(options); await connection.connect(); return connection; } }); module.exports = SerialDataSource; × Search results Close "},"tcp-connection.js.html":{"id":"tcp-connection.js.html","title":"Source: tcp-connection.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: tcp-connection.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const net = require('net'); const tls = require('tls'); const Connection = require('./connection'); const _ = require('./lodash'); const optionKeys = [ 'host', 'port', 'viaTag', 'password', 'channel', 'rawVBusDataOnly', 'tlsOptions', ]; const TcpConnection = Connection.extend(/** @lends TcpConnection# */ { /** * Host name or IP address of the connection target. * @type {string} */ host: null, /** * Port number of the connection target. * @type {number} */ port: null, /** * Via tag if connection target is accessed using the VBus.net service. * @type {string} */ viaTag: null, /** * Password needed to connect to target. * @type {string} */ password: null, /** * Channel number to connect to. * @type {string|number} */ channel: 0, /** * Indicates that connection does not need to perform login handshake. * Useful for serial-to-LAN converters. * @type {boolean} */ rawVBusDataOnly: false, tlsOptions: null, /** * Timeout in milliseconds to way between reconnection retries. * @type {number} */ reconnectTimeout: 0, /** * Value to increment timeout after every unsuccessful reconnection retry. * @type {number} */ reconnectTimeoutIncr: 10000, /** * Maximum timeout value between unsuccessful reconnection retry. * @type {number} */ reconnectTimeoutMax: 60000, /** * Creates a new TcpConnection instance and optionally initializes its * members to the given values. * * @constructs * @augments Connection * @param {object} options Initialization values * @param {string} options.host See {@link TcpConnection#host} * @param {number} options.port See {@link TcpConnection#port} * @param {string} options.viaTag See {@link TcpConnection#viaTag} * @param {string} options.password See {@link TcpConnection#password} * @param {boolean} options.rawVBusDataOnly See {@link TcpConnection#rawVBusDataOnly} * * @classdesc * The TcpConnection class is primarily designed to provide access to VBus live data * using the VBus-over-TCP specification. That includes the VBus/LAN adapter, the * Dataloggers (DL2 and DL3) and VBus.net. * In addition to that it can be used to connect to a raw VBus data stream using TCP * (for example provided by a serial-to-LAN gateway). */ constructor(options) { Connection.call(this, options); if (options &amp;&amp; options.tlsOptions) { this.port = 57053; } else { this.port = 7053; } _.extend(this, _.pick(options, optionKeys)); }, async connect(force) { if (this.connectionState !== TcpConnection.STATE_DISCONNECTED) { throw new Error('Connection is not disconnected (' + this.connectionState + ')'); } this._setConnectionState(TcpConnection.STATE_CONNECTING); return this._connect(force); }, disconnect() { if (this.connectionState === TcpConnection.STATE_DISCONNECTING) { if (this.socket) { this.socket.destroy(); this.socket = null; } this._setConnectionState(TcpConnection.STATE_DISCONNECTED); } else if (this.connectionState !== TcpConnection.STATE_DISCONNECTED) { this._setConnectionState(TcpConnection.STATE_DISCONNECTING); if (this.socket) { this.socket.end(); } else { this._setConnectionState(TcpConnection.STATE_DISCONNECTED); } } }, _connect(force) { const _this = this; let socket; return new Promise((resolve, reject) =&gt; { const done = function(err, result) { if (err) { reject(err); } else { resolve(result); } }; let options = { host: this.host, port: this.port }; let phase = this.rawVBusDataOnly ? 1000 : 0; let rxBuffer = null; const write = function() { return socket.write.apply(socket, arguments); }; const onConnectionEstablished = function() { _this.reconnectTimeout = 0; _this._setConnectionState(TcpConnection.STATE_CONNECTED); done(); }; const onConnect = function() { if (phase === 1000) { onConnectionEstablished(); } }; const channelList = []; const onLine = function(line) { let newPhase = -1; if (line [0] === '+') { if (phase === 0) { if (_this.viaTag) { // CONNECT ... newPhase = 20; } else { // PASS ... newPhase = 40; } } else if (phase === 20) { newPhase = 40; } else if (phase === 40) { if (_this.channelListCallback) { newPhase = 60; } else if (_this.channel) { newPhase = 80; } else { newPhase = 900; } } else if (phase === 60) { newPhase = 70; _this.channelListCallback(channelList, (err, channel) =&gt; { if (err) { done(err); } else { if (channel !== undefined) { if (_.isNumber(channel)) { _this.channel = channel; } else if (_.isString(channel)) { _this.channel = parseInt(channel); } else if (_.isObject(channel) &amp;&amp; _.has(channel, 'channel')) { _this.channel = channel.channel; } else { done(new Error('Invalid channel selection ' + JSON.stringify(channel))); } } if (_this.channel) { newPhase = 80; } else { newPhase = 900; } } }); } else if (phase === 80) { newPhase = 900; } else if (phase === 900) { newPhase = 1000; } } else if (line [0] === '-') { newPhase = 800; done(new Error('Remote side responded with ' + JSON.stringify(line))); } else if (line [0] === '*') { if (phase === 60) { const md = /^\\*([\\d]+):(.*)$/.exec(line); if (md) { channelList.push({ channel: md [1], name: md [2], }); } } } else { // nop } if (newPhase &gt;= 0) { phase = newPhase; if (phase === 20) { // CONNECT write('CONNECT ' + _this.viaTag + '\\r\\n'); } else if (phase === 40) { // PASS write('PASS ' + _this.password + '\\r\\n'); } else if (phase === 60) { // CHANNELLIST write('CHANNELLIST\\r\\n'); } else if (phase === 80) { // CHANNEL write('CHANNEL ' + _this.channel + '\\r\\n'); } else if (phase === 800) { // QUIT write('QUIT\\r\\n'); } else if (phase === 900) { // DATA write('DATA\\r\\n'); } else if (phase === 1000) { onConnectionEstablished(); } } }; const onSocketData = function(chunk) { // console.log('onData'); if (phase &lt; 1000) { // console.log(chunk.toString('utf8')); let buffer; if (rxBuffer) { buffer = Buffer.concat([ rxBuffer, chunk ]); } else { buffer = chunk; } let start = 0, index = 0; /* eslint-disable-next-line no-unmodified-loop-condition */ while ((index &lt; buffer.length) &amp;&amp; (phase &lt; 1000)) { if ((buffer [index] === 13) || (buffer [index] === 10)) { if (start &lt; index) { const line = buffer.toString('utf8', start, index); onLine(line); } start = index + 1; } index++; } if (start &lt; buffer.length) { if (phase &gt;= 1000) { _this._write(buffer.slice(start)); rxBuffer = null; } else { rxBuffer = buffer.slice(start); } } else { rxBuffer = null; } } else { _this._write(chunk); } }; const onConnectionData = function(chunk) { write(chunk); }; const onSocketTermination = function() { _this.removeListener('data', onConnectionData); if (_this.socket !== socket) { // nop } else if (!force &amp;&amp; (_this.connectionState === TcpConnection.STATE_CONNECTING)) { // failed to connect _this._setConnectionState(TcpConnection.STATE_DISCONNECTED); _this.socket = null; done(new Error('Unable to connect')); } else if (_this.connectionState === TcpConnection.STATE_DISCONNECTING) { _this._setConnectionState(TcpConnection.STATE_DISCONNECTED); _this.socket = null; } else { _this._setConnectionState(TcpConnection.STATE_INTERRUPTED); _this.socket = null; const timeout = _this.reconnectTimeout; if (_this.reconnectTimeout &lt; _this.reconnectTimeoutMax) { _this.reconnectTimeout += _this.reconnectTimeoutIncr; } setTimeout(() =&gt; { _this._setConnectionState(TcpConnection.STATE_RECONNECTING); _this._connect(); }, timeout); } }; const onEnd = function() { onSocketTermination(); }; const onError = function(/* err */) { socket.destroy(); onSocketTermination(); }; const onTimeout = function() { socket.destroy(); onSocketTermination(); }; this.on('data', onConnectionData); if (this.tlsOptions) { options = _.extend(options, this.tlsOptions); socket = tls.connect(options, onConnect); } else { socket = net.connect(options, onConnect); } socket.on('data', onSocketData); socket.on('end', onEnd); socket.on('error', onError); socket.setTimeout(30000, onTimeout); socket.setKeepAlive(true, 60000); this.socket = socket; }); }, }); module.exports = TcpConnection; × Search results Close "},"tcp-connection-endpoint.js.html":{"id":"tcp-connection-endpoint.js.html","title":"Source: tcp-connection-endpoint.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: tcp-connection-endpoint.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const EventEmitter = require('events').EventEmitter; const net = require('net'); const extend = require('./extend'); const _ = require('./lodash'); const optionKeys = [ 'port', 'channels', ]; const TcpConnectionEndpoint = extend(EventEmitter, /** @lends TcpConnectionEndpoint# */ { /** * The port number to listen on for incoming connections. * @type {number} */ port: 7053, /** * The list of channels to return if the CHANNELLIST command is received. * @type {string[]} */ channels: null, /** * The Server instance used for listening for incoming connections. * @type {net.Server} */ server: null, /** * Creates a new instance and optionally initializes its members. * * @constructs * @augments EventEmitter * @param {object} options The initialization values for this instance. * @param {number} options.port See {@link TcpConnectionEndpoint#port} * @param {number} options.channels See {@link TcpConnectionEndpoint#channels} * * @classdesc * The TcpConnectionEndpoint can act as the remote side for a TcpConnection. * It supports all the commands that a DL3 connected via VBus.net would * provide as well. * * A `connection` event is emitted whenever an incoming connection passes * the VBus-over-TCP handshake. */ constructor(options) { EventEmitter.call(this); _.extend(this, _.pick(options, optionKeys)); if (!_.has(this, 'channels')) { this.channels = [ 'VBus' ]; } }, /** * Starts the server to listen for incoming connections. * * @return {Promise} A promise that resolves when the server is started. */ start() { const _this = this; return new Promise((resolve, reject) =&gt; { const done = function(err, result) { if (err) { reject(err); } else { resolve(result); } }; const server = net.createServer((socket) =&gt; { _this._onConnection(socket); }); server.listen(this.port, () =&gt; { if (_this.port === 0) { _this.port = server.address().port; } done(null, true); }); server.on('error', (err) =&gt; { done(err); }); this.server = server; }); }, stop() { if (this.server) { this.server.close(); this.server = null; } }, _onConnection(socket) { const _this = this; const connectionInfo = { socket, }; let phase = 0; let rxBuffer = null; const write = function() { return socket.write.apply(socket, arguments); }; const onData = function(chunk) { if (phase &lt; 1000) { let buffer; if (rxBuffer) { buffer = Buffer.concat([ rxBuffer, chunk ]); } else { buffer = chunk; } let start = 0, index = 0; let processNextLine = undefined; const callback = function(err, result, transition) { if (err) { write('-ERROR: ' + JSON.stringify(err.toString()) + '\\r\\n'); } else { write(result.toString() + '\\r\\n'); if (transition === false) { socket.end(); connectionInfo.socket = null; } else if (transition === true) { phase = 1000; _this.emit('connection', connectionInfo); } processNextLine(); } }; const processLine = function(line) { let md; if ((md = /^CONNECT (.*)$/.exec(line))) { connectionInfo.viaTag = md [1]; callback(null, '+OK'); } else if ((md = /^PASS (.*)$/.exec(line))) { connectionInfo.password = md [1]; callback(null, '+OK'); } else if ((md = /^CHANNELLIST$/.exec(line))) { const response = _.reduce(_this.channels, (memo, channel, index) =&gt; { if (channel) { memo.push('*' + index + ':' + channel); } return memo; }, []).join('\\r\\n'); callback(null, response + '\\r\\n+OK'); } else if ((md = /^CHANNEL (.*)$/.exec(line))) { connectionInfo.channel = md [1]; callback(null, '+OK'); } else if ((md = /^QUIT$/.exec(line))) { callback(null, '+OK', false); } else if ((md = /^DATA$/.exec(line))) { callback(null, '+OK', true); } else { callback(new Error('Unknown command')); } }; processNextLine = function() { if ((index &lt; buffer.length) &amp;&amp; (phase &lt; 1000)) { while (index &lt; buffer.length) { if ((buffer [index] === 13) || (buffer [index] === 10)) { if (start &lt; index) { const line = buffer.toString('utf8', start, index); start = index + 1; processLine(line); break; } else { start = index + 1; } } index++; } } else { if (start &lt; buffer.length) { if (phase &gt;= 1000) { // _this._write(buffer.slice(start)); rxBuffer = null; } else { rxBuffer = buffer.slice(start); } } else { rxBuffer = null; } } }; processNextLine(); // } else { // _this._write(chunk); } }; const onEnd = function() { }; const onError = function() { }; const onTimeout = function() { }; socket.on('data', onData); socket.on('end', onEnd); socket.on('error', onError); socket.setTimeout(30000, onTimeout); socket.setKeepAlive(true, 60000); write('+HELLO: This is TcpConnectionEndpoint, at your service!\\r\\n'); }, }); module.exports = TcpConnectionEndpoint; × Search results Close "},"tcp-data-source.js.html":{"id":"tcp-data-source.js.html","title":"Source: tcp-data-source.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: tcp-data-source.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const DataSource = require('./data-source'); const _ = require('./lodash'); const TcpConnection = require('./tcp-connection'); const optionKeys = [ 'host', 'liveChannel', 'livePassword', ]; const TcpDataSource = DataSource.extend(/** @lends TcpDataSource# */ { /** * The host to connect to. * @type {string} */ host: null, /** * The port to connect to. * @type {number} */ port: 7053, /** * The channel to connect to live. * @type {number} */ liveChannel: 0, /** * The password to connect live. * @type {string} */ livePassword: 'vbus', /** * Creates a new TcpDataSource instance. * * @constructs * @augments DataSource */ constructor(options) { DataSource.call(this, options); _.extend(this, _.pick(options, optionKeys)); this.options = options; }, async connectLive(options) { const defaultOptions = { host: this.host, port: this.port, viaTag: this.viaTag, password: this.livePassword, channel: this.liveChannel, }; options = _.extend(defaultOptions, options, { provider: this.provider, dataSource: this.id, }); const connection = new TcpConnection(options); await connection.connect(); return connection; } }); module.exports = TcpDataSource; × Search results Close "},"tcp-data-source-provider.js.html":{"id":"tcp-data-source-provider.js.html","title":"Source: tcp-data-source-provider.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: tcp-data-source-provider.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const dgram = require('dgram'); const http = require('http'); const _ = require('./lodash'); const TcpDataSource = require('./tcp-data-source'); const DataSourceProvider = require('./data-source-provider'); const optionKeys = [ 'broadcastAddress', 'broadcastPort', ]; const TcpDataSourceProvider = DataSourceProvider.extend(/** @lends TcpDataSourceProvider# */ { id: 'tcp-data-source-provider', name: 'TCP VBus Data Source Provider', description: 'Data source provider for TCP connected VBus devices', broadcastAddress: '255.255.255.255', broadcastPort: 7053, /** * Creates a new TcpDataSourceProvider instance. * * @constructs * @augments DataSourceProvider */ constructor(options) { DataSourceProvider.call(this, options); _.extend(this, _.pick(options, optionKeys)); }, async discoverDataSources() { const options = { broadcastAddress: this.broadcastAddress, broadcastPort: this.broadcastPort, }; const results = await TcpDataSourceProvider.discoverDevices(options); return results.map((result) =&gt; { const options = _.extend({}, result, { host: result.__address__ }); return this.createDataSource(options); }); }, createDataSource(options) { options = _.extend({}, options, { provider: this.id, id: options.__address__, name: options.name || options.__address__, host: options.__address__, }); return new TcpDataSource(options); }, }, /** @lends TcpDataSourceProvider */ { /** * Discovers devices on the local network. * * @params {object} options * @params {string} options.broadcastAddress IP address to broadcast to * @params {number} options.broadcastPort Port number to broadcast to. * @returns {Promise} A Promise that resolves to an array of device information objects. */ discoverDevices(options) { return TcpDataSourceProvider.sendBroadcast(options).then((promises) =&gt; { return new Promise(resolve =&gt; { const results = []; let promiseIndex = 0; function nextPromise() { if (promiseIndex &lt; promises.length) { const promise = promises [promiseIndex]; promiseIndex += 1; promise.then(result =&gt; { results.push(result); nextPromise(); }, () =&gt; { nextPromise(); }); } else { resolve(results); } } nextPromise(); }); }); }, sendBroadcast(options) { return new Promise((resolve, reject) =&gt; { const done = function(err, result) { if (err) { reject(err); } else { resolve(result); } }; options = _.defaults({}, options, { broadcastAddress: '255.255.255.255', broadcastPort: 7053, tries: 3, timeout: 500, }); if (options.fetchCallback === undefined) { options.fetchCallback = function(address) { return TcpDataSourceProvider.fetchDeviceInformation(address); }; } const bcastAddress = options.broadcastAddress; const bcastPort = options.broadcastPort; const addressMap = {}; const queryString = '---RESOL-BROADCAST-QUERY---'; const replyString = '---RESOL-BROADCAST-REPLY---'; let tries = 0; const socket = dgram.createSocket('udp4'); const sendQuery = function() { if (tries &lt; options.tries) { tries++; const queryBuffer = Buffer.from(queryString); socket.send(queryBuffer, 0, queryBuffer.length, bcastPort, bcastAddress); setTimeout(sendQuery, options.timeout); } else { const keys = _.keys(addressMap).sort(); const result = _.map(keys, (key) =&gt; { return addressMap [key]; }); socket.close(); done(null, result); } }; socket.bind(0, () =&gt; { socket.setBroadcast(true); sendQuery(); }); socket.on('message', (msg, rinfo) =&gt; { if ((rinfo.family === 'IPv4') &amp;&amp; (rinfo.port === 7053) &amp;&amp; (msg.length &gt;= replyString.length)) { const msgString = msg.slice(0, replyString.length).toString(); if (msgString === replyString) { const address = rinfo.address; if (!_.has(addressMap, address)) { addressMap [address] = options.fetchCallback(address); } } } }); socket.on('error', (err) =&gt; { socket.close(); done(err); }); }); }, async fetchDeviceInformation(address, port) { if (port === undefined) { try { return TcpDataSourceProvider.fetchDeviceInformation(address, 80); } catch (err) { return TcpDataSourceProvider.fetchDeviceInformation(address, 3000); } } else { return new Promise((resolve, reject) =&gt; { let portSuffix; if (port !== 80) { portSuffix = ':' + port; } else { portSuffix = ''; } const reqUrl = 'http://' + address + portSuffix + '/cgi-bin/get_resol_device_information'; const req = http.get(reqUrl, (res) =&gt; { if (res.statusCode === 200) { let buffer = Buffer.alloc(0); res.on('data', (chunk) =&gt; { buffer = Buffer.concat([ buffer, chunk ]); }); res.on('end', () =&gt; { const bodyString = buffer.toString(); const info = _.extend(TcpDataSourceProvider.parseDeviceInformation(bodyString), { __address__: address, }); resolve(info); }); res.on('error', (err) =&gt; { reject(err); }); } else { reject(new Error('HTTP request returned status ' + res.statusCode)); } }); req.on('error', (err) =&gt; { reject(err); }); req.setTimeout(10000, () =&gt; { reject(new Error('HTTP request timed out')); }); }); } }, parseDeviceInformation(string) { const result = {}; const re = /([\\w]+)[\\s]*=[\\s]*\"([^\"\\r\\n]*)\"/g; let md; while ((md = re.exec(string)) !== null) { result [md [1]] = md [2]; } return result; }, }); module.exports = TcpDataSourceProvider; × Search results Close "},"telegram.js.html":{"id":"telegram.js.html","title":"Source: telegram.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: telegram.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const sprintf = require('sprintf-js').sprintf; const Header = require('./header'); const _ = require('./lodash'); const optionKeys = [ 'command', ]; const Telegram = Header.extend(/** @lends Telegram# */ { /** * The VBus command of this Telegram instance. * @type {number} */ command: 0, frameData: null, /** * Creates a new Telegram instance. * * @constructs * @augments Header * @param {object} options Initialization options. */ constructor(options) { Header.call(this, options); _.extend(this, _.pick(options, optionKeys)); if (_.has(options, 'frameData') &amp;&amp; _.has(options, 'dontCopyFrameData') &amp;&amp; options.dontCopyFrameData) { this.frameData = options.frameData; } else { this.frameData = Buffer.alloc(3 * 7); this.frameData.fill(0); if (_.has(options, 'frameData')) { const minLength = Math.min(this.frameData.length, options.frameData.length); options.frameData.copy(this.frameData, 0, 0, minLength); } } }, toLiveBuffer(origBuffer, start, end) { const frameCount = this.getFrameCount(); const length = 8 + frameCount * 9; let buffer; if (origBuffer === undefined) { buffer = Buffer.alloc(length); } else if (start + length &lt;= end) { buffer = origBuffer.slice(start, start + length); } else { throw new Error('Buffer too small'); } buffer [0] = 0xAA; buffer.writeUInt16LE(this.destinationAddress &amp; 0x7F7F, 1); buffer.writeUInt16LE(this.sourceAddress &amp; 0x7F7F, 3); buffer [5] = 0x30; buffer [6] = this.command &amp; 0x7F; Telegram.calcAndSetChecksumV0(buffer, 1, 7); for (let i = 0; i &lt; frameCount; i++) { const srcStart = 7 * i; const dstStart = 8 + 9 * i; Telegram.extractSeptett(this.frameData, srcStart, srcStart + 7, buffer, dstStart); Telegram.calcAndSetChecksumV0(buffer, dstStart, dstStart + 8); } return buffer; }, getProtocolVersion() { return 0x30; }, getId() { const baseId = Header.prototype.getId.call(this); return sprintf('%s_%02X', baseId, this.command); }, compareTo(that) { let result = Header.prototype.compareTo.apply(this, arguments); if (result === 0) { result = this.command - that.command; } return result; }, getFrameCount() { return Telegram.getFrameCountForCommand(this.command); }, }, /** @lends Telegram */ { fromLiveBuffer(buffer, start, end) { const frameCount = this.getFrameCountForCommand(buffer [start + 6]); const frameData = Buffer.alloc(3 * 7); frameData.fill(0); for (let i = 0; i &lt; frameCount; i++) { const srcStart = start + 8 + 9 * i; const dstStart = 7 * i; Telegram.injectSeptett(buffer, srcStart, srcStart + 7, frameData, dstStart); } return new Telegram({ destinationAddress: buffer.readUInt16LE(start + 1), sourceAddress: buffer.readUInt16LE(start + 3), command: buffer [start + 6], frameData, dontCopyFrameData: true }); }, getFrameCountForCommand(command) { return ((command &gt;&gt; 5) &amp; 0x03); } }); module.exports = Telegram; × Search results Close "},"text-converter.js.html":{"id":"text-converter.js.html","title":"Source: text-converter.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: text-converter.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const Converter = require('./converter'); const _ = require('./lodash'); const Specification = require('./specification'); const optionKeys = [ 'columnSeparator', 'lineSeparator', 'separateDateAndTime', 'specification', 'dateFormat', 'timeFormat', ]; const TextConverter = Converter.extend(/** @lends TextConverter# */ { /** * Column separator, defaults to tab * @type {string} */ columnSeparator: '\\t', /** * Line separator, defaults to CR+NL * @type {string} */ lineSeparator: '\\r\\n', /** * Specifies whether date and time columns should be output separately * @type {boolean} */ separateDateAndTime: false, /** * VBus specification * @type {Specification} */ specification: null, /** * Date to string formatting for the first column. Can either be a * string to use in `moment(...).format()` or a function that returns * the formatted date string. * @type {string|function} */ dateFormat: 'L', /** * Time to string formatting for the first column. Can either be a * string to use in `moment(...).format()` or a function that returns * the formatted time string. * @type {string|function} */ timeFormat: 'HH:mm:ss', /** * List of packet IDs converted last time, enables decision whether a * new header line pair must be output. * @type {string} */ lastIdList: null, /** * Create a new TextConverter instance given the set of options. * @constructs * @augments Converter * * @classdesc * The TextConverter class takes header sets, converts them into text * representation and then publishes that on the readable stream side * of itself. * * It does not support parsing text content back into header sets (the * writable stream side). */ constructor(options) { Converter.call(this, options); _.extend(this, _.pick(options, optionKeys)); if (!this.specification) { this.specification = new Specification({ language: (options &amp;&amp; options.language) || 'en' }); } }, /** * Resets the converter, resulting in a ne pair of header lines * generated on next header set conversion. */ reset() { this.lastIdList = null; }, /** * Converts a header set into text representation. * * @param {HeaderSet} headerSet */ convertHeaderSet(headerSet) { const _this = this; const spec = this.specification; const i18n = spec.i18n; const headers = headerSet.getSortedHeaders(); const packetFields = spec.getPacketFieldsForHeaders(headers); const now = i18n.moment(headerSet.timestamp); const idList = _.map(packetFields, 'id').join(','); let content = '', columns; const appendDateAndTimeColumns = function(date, time, join) { columns = []; if (_this.separateDateAndTime) { columns.push(date); columns.push(time); } else { columns.push(date + join + time); } }; const appendColumnsToContent = function() { content += columns.join(_this.columnSeparator) + _this.lineSeparator; }; let needHeaderLines = false; if (this.lastIdList !== idList) { this.lastIdList = idList; needHeaderLines = true; } if (needHeaderLines) { // packet spec header line let lastPacketSpec = null; appendDateAndTimeColumns('', '', ''); _.forEach(packetFields, (packetField) =&gt; { let packetDesc; if (lastPacketSpec !== packetField.packetSpec) { lastPacketSpec = packetField.packetSpec; if (packetField.packetSpec) { packetDesc = packetField.packetSpec.fullName || ''; } else { packetDesc = ''; } } else { packetDesc = ''; } columns.push(packetDesc); }); appendColumnsToContent(); // packet field spec header line appendDateAndTimeColumns(i18n.t('textConverter.date'), i18n.t('textConverter.time'), ' / '); _.forEach(packetFields, (packetField) =&gt; { let columnDesc = packetField.name; if (packetField.packetFieldSpec) { const type = packetField.packetFieldSpec.type; if (type &amp;&amp; type.unit &amp;&amp; type.unit.unitText) { columnDesc += ' [' + type.unit.unitText + ']'; } } else { columnDesc = ''; } columns.push(columnDesc); }); appendColumnsToContent(); } // value line const dateString = this.formatDateAndTime(now, this.dateFormat); const timeString = this.formatDateAndTime(now, this.timeFormat); appendDateAndTimeColumns(dateString, timeString, ' '); _.forEach(packetFields, (packetField) =&gt; { const textValue = packetField.formatTextValue('None'); columns.push(textValue); }); appendColumnsToContent(); return this.push(content); }, /** * Format a `Date` object into a string. * * @param {Moment} now The Moment.js timestamp to format. * @param {string|function} format Date formatter. Can either be a * string to use in `moment(...).format()` or a function that returns * the formatted date/time string. * @returns {string} The formatted date/time as a string. */ formatDateAndTime(now, format) { if (typeof format === 'string') { return now.format(format); } else if (typeof format === 'function') { return format(now); } else { throw new Error(`Unsupported format specifier`); } }, _read() { // nop }, }); module.exports = TextConverter; × Search results Close "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: utils.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const utils = { /** * @see http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript */ generateGUID() { const s4 = function() { return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); }; const guid = [ s4(), s4(), '-', s4(), '-', s4(), '-', s4(), '-', s4(), s4(), s4(), ].join(''); return guid; }, roundNumber(value, exp) { if ((value === undefined) || (exp === undefined) || (+exp === 0)) { return value; } value = +value; exp = +exp; if (Number.isNaN(value) || (exp % 1 !== 0)) { return NaN; } let valueParts = value.toString().split('e'); let baseExp = valueParts [1] ? +valueParts [1] : 0; value = Math.round(+(valueParts [0] + 'e' + (baseExp - exp))); valueParts = value.toString().split('e'); baseExp = valueParts [1] ? +valueParts [1] : 0; value = +(valueParts [0] + 'e' + (baseExp + exp)); return value; }, deepFreezeObjectTree(root) { const freezingObjects = []; const deepFreezeObject = function(obj) { if (Object.isFrozen(obj)) { return obj; } if (freezingObjects.indexOf(obj) &gt;= 0) { throw new Error('Circular reference while deep freezing'); } freezingObjects.push(obj); const keys = Object.getOwnPropertyNames(obj); keys.forEach((key) =&gt; { const value = obj [key]; if ((typeof value === 'object') &amp;&amp; (value !== null)) { deepFreezeObject(value); } }); freezingObjects.pop(); return Object.freeze(obj); }; return deepFreezeObject(root); }, }; module.exports = utils; × Search results Close "},"vbus-recording-converter.js.html":{"id":"vbus-recording-converter.js.html","title":"Source: vbus-recording-converter.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: vbus-recording-converter.js /*! resol-vbus | Copyright (c) 2013-2018, Daniel Wippermann | MIT license */ 'use strict'; const moreints = require('buffer-more-ints'); const HeaderSet = require('./header-set'); const _ = require('./lodash'); const Packet = require('./packet'); const Converter = require('./converter'); const optionKeys = [ 'topologyScanOnly', ]; const VBusRecordingConverter = Converter.extend(/** @lends VBusRecordingConverter# */ { topologyScanOnly: false, rxBuffer: null, headerSet: null, headerSetTimestamp: null, currentChannel: 0, knownHeaderIds: null, /** * Creates a new VBusRecordingConverter instance. * * @constructs * @augments Converter * * @classdesc * This Converter subclass converts Header and HeaderSet instances to and from a binary stream that * conforms to the VBus Recording File Format (the binary file format used e.g. to store data on the * Datalogger devices). */ constructor(options) { Converter.call(this, options); _.extend(this, _.pick(options, optionKeys)); this.knownHeaderIds = {}; }, reset() { this.rxBuffer = null; }, end() { const _this = this; if (this.objectMode) { // nop } else if (this.topologyScanOnly) { this._processBuffer(Buffer.alloc(0), true, (record) =&gt; { _this._processRecordForTopologyScan(record); }); this._constructTopologyHeaderSet(); } else { this._processBuffer(Buffer.alloc(0), true, (record) =&gt; { _this._processRecord(record); }); } this._emitHeaderSet(); return Converter.prototype.end.apply(this, arguments); }, convertRawData(rawData) { if (this.objectMode) { return Converter.prototype.convertRawData.apply(this, arguments); } else { const buffers = []; const createBuffer = function(type, length, timestamp) { const buffer = Buffer.alloc(length); buffer.fill(0); buffer [0] = 0xA5; buffer [1] = (type &amp; 0x0F) | ((type &amp; 0x0F) &lt;&lt; 4); buffer.writeUInt16LE(length, 2); buffer.writeUInt16LE(length, 4); moreints.writeUInt64LE(buffer, timestamp.getTime(), 6); return buffer; }; let buffer; if (rawData.channel !== this.currentChannel) { buffer = createBuffer(7, 16, new Date(0)); buffer.writeUInt16LE(rawData.channel, 14); buffers.push(buffer); this.currentChannel = rawData.channel; } buffer = createBuffer(8, 22 + rawData.buffer.length, rawData.startTimestamp); moreints.writeUInt64LE(buffer, rawData.endTimestamp.getTime(), 14); rawData.buffer.copy(buffer, 22, 0, rawData.buffer.length); buffers.push(buffer); buffer = Buffer.concat(buffers); return this.push(buffer); } }, convertComment(timestamp, comment) { if (this.objectMode) { return Converter.prototype.convertRawData.apply(this, arguments); } else { const buffers = []; const createBuffer = function(type, length, timestamp) { const buffer = Buffer.alloc(length); buffer.fill(0); buffer [0] = 0xA5; buffer [1] = (type &amp; 0x0F) | ((type &amp; 0x0F) &lt;&lt; 4); buffer.writeUInt16LE(length, 2); buffer.writeUInt16LE(length, 4); moreints.writeUInt64LE(buffer, timestamp.getTime(), 6); return buffer; }; const rawData = Buffer.from(comment.toString()); let buffer; buffer = createBuffer(9, 14 + rawData.length, timestamp); rawData.copy(buffer, 14, 0, rawData.length); buffers.push(buffer); buffer = Buffer.concat(buffers); return this.push(buffer); } }, convertHeader(header) { if (this.objectMode) { return Converter.prototype.convertHeader.apply(this, arguments); } else { return this._convertHeaders(header.timestamp, [ header ]); } }, convertHeaderSet(headerSet) { if (this.objectMode) { return Converter.prototype.convertHeaderSet.apply(this, arguments); } else { return this._convertHeaders(headerSet.timestamp, headerSet.getSortedHeaders()); } }, _convertHeaders(timestamp, headers) { const buffers = []; const createBuffer = function(type, length, timestamp) { const buffer = Buffer.alloc(length); buffer.fill(0); buffer [0] = 0xA5; buffer [1] = (type &amp; 0x0F) | ((type &amp; 0x0F) &lt;&lt; 4); buffer.writeUInt16LE(length, 2); buffer.writeUInt16LE(length, 4); moreints.writeUInt64LE(buffer, timestamp.getTime(), 6); return buffer; }; let buffer = createBuffer(4, 14, timestamp); buffers.push(buffer); let currentChannel = 0; _.forEach(headers, (header) =&gt; { const majorVersion = header.getProtocolVersion() &gt;&gt; 4; let dataLength; if (majorVersion === 1) { dataLength = header.frameCount * 4; } else { dataLength = -1; } if (dataLength &gt;= 0) { let buffer; if (currentChannel !== header.channel) { currentChannel = header.channel; buffer = createBuffer(7, 16, new Date(0)); buffer.writeUInt16LE(header.channel, 14); buffers.push(buffer); } buffer = createBuffer(6, 26 + dataLength, header.timestamp); buffer.writeUInt16LE(header.destinationAddress, 14); buffer.writeUInt16LE(header.sourceAddress, 16); buffer.writeUInt16LE(header.getProtocolVersion(), 18); if (majorVersion === 1) { buffer.writeUInt16LE(header.command, 20); buffer.writeUInt16LE(dataLength, 22); buffer.writeUInt16LE(0, 24); header.frameData.copy(buffer, 26, 0, dataLength); } buffers.push(buffer); } }); buffer = Buffer.concat(buffers); return this.push(buffer); }, _read() { // nop }, _write(chunk, encoding, callback) { const _this = this; if (this.objectMode) { return Converter.prototype._write.apply(this, arguments); } else if (this.topologyScanOnly) { this._processBuffer(chunk, false, (record) =&gt; { _this._processRecordForTopologyScan(record); }); callback(); } else { this._processBuffer(chunk, false, (record) =&gt; { _this._processRecord(record); }); callback(); } }, _processBuffer(chunk, endOfStream, processRecord) { let buffer; if (this.rxBuffer) { buffer = Buffer.concat([ this.rxBuffer, chunk ]); } else { buffer = chunk; } const getRecordLength = function(index) { let length; if (index &gt; buffer.length - 6) { length = -1; } else if (buffer [index] !== 0xA5) { length = 0; } else if ((buffer [index + 1] &gt;&gt; 4) !== (buffer [index + 1] &amp; 15)) { length = 0; } else if (buffer [index + 2] !== buffer [index + 4]) { length = 0; } else if (buffer [index + 3] !== buffer [index + 5]) { length = 0; } else { length = buffer.readUInt16LE(index + 2); if ((index + length) &gt; buffer.length) { length = -1; } } return length; }; let currentIndex = 0, currentLength = getRecordLength(0), nextIndex, nextLength, start = 0; while ((currentLength &gt;= 0) &amp;&amp; (currentIndex &lt; buffer.length)) { if (currentLength &gt; 0) { nextIndex = currentIndex + currentLength; } else { nextIndex = currentIndex + 1; } nextLength = getRecordLength(nextIndex); if ((nextLength &lt; 0) &amp;&amp; !endOfStream) { break; } if ((currentLength &gt; 0) &amp;&amp; ((nextLength &gt; 0) || (nextIndex === buffer.length))) { const record = buffer.slice(currentIndex, nextIndex); processRecord(record); start = nextIndex; } else if (nextIndex !== (currentIndex + 1)) { nextIndex = currentIndex + 1; nextLength = getRecordLength(nextIndex); if (nextLength &lt; 0) { break; } } currentIndex = nextIndex; currentLength = nextLength; } const maxLength = 65536; if (buffer.length - start &gt;= maxLength) { start = buffer.length - maxLength; } if (start &lt; buffer.length) { this.rxBuffer = Buffer.from(buffer.slice(start)); } else { this.rxBuffer = null; } }, _processRecord(buffer) { const type = buffer [1] &amp; 0x0F; const timestamp = moreints.readUInt64LE(buffer, 6); if (type === 3) { this._processType3Record(buffer, timestamp); } else if (type === 4) { this._emitHeaderSet(); this.headerSet = new HeaderSet(); this.headerSetTimestamp = new Date(timestamp); this.currentChannel = 0; } else if ((type === 6) &amp;&amp; (buffer.length &gt;= 20)) { const destinationAddress = buffer.readUInt16LE(14); const sourceAddress = buffer.readUInt16LE(16); const protocolVersion = buffer.readUInt16LE(18); const majorVersion = protocolVersion &gt;&gt; 4; if ((majorVersion === 1) &amp;&amp; (buffer.length &gt;= 26)) { const command = buffer.readUInt16LE(20); const dataLength = buffer.readUInt16LE(22); if (buffer.length &gt;= 26 + dataLength) { const frameCount = Math.floor(dataLength / 4); const frameData = Buffer.alloc(127 * 4); buffer.copy(frameData, 0, 26, 26 + dataLength); const header = new Packet({ timestamp: new Date(timestamp), channel: this.currentChannel, destinationAddress, sourceAddress, command, frameCount, frameData, dontCopyFrameData: true, }); if (this.headerSet) { this.headerSet.addHeader(header); } this.emit('header', header); } } } else if ((type === 7) &amp;&amp; (buffer.length &gt;= 16)) { this.currentChannel = buffer [14]; } else if ((type === 8) &amp;&amp; (buffer.length &gt;= 22)) { const endTimestamp = moreints.readUInt64LE(buffer, 14); const rawBuffer = Buffer.alloc(buffer.length - 22); buffer.copy(rawBuffer, 0, 22, buffer.length); this.emit('rawData', { startTimestamp: new Date(timestamp), endTimestamp: new Date(endTimestamp), channel: this.currentChannel, buffer: rawBuffer, }); } else if ((type === 9) &amp;&amp; (buffer.length &gt;= 14)) { const comment = buffer.slice(14).toString(); this.emit('comment', { timestamp: new Date(timestamp), comment, }); } }, _processType3Record(buffer, timestamp) { const destinationAddress = buffer.readUInt16LE(14); const sourceAddress = buffer.readUInt16LE(16); const protocolVersion = buffer.readUInt16LE(18); const majorVersion = protocolVersion &gt;&gt; 4; if ((majorVersion === 1) &amp;&amp; (buffer.length &gt;= 26)) { const command = buffer.readUInt16LE(20); const dataLength = buffer.readUInt16LE(22); if (buffer.length &gt;= 26 + dataLength) { const frameCount = Math.floor(dataLength / 4); const frameData = Buffer.alloc(127 * 4); buffer.copy(frameData, 0, 26, 26 + dataLength); const header = new Packet({ timestamp: new Date(timestamp), channel: this.currentChannel, destinationAddress, sourceAddress, command, frameCount, frameData, dontCopyFrameData: true, }); if (destinationAddress === 0x0010) { this._emitHeaderSet(); } else if (this.headerSet &amp;&amp; this.headerSet.containsHeader(header)) { this._emitHeaderSet(); } if (!this.headerSet) { this.headerSet = new HeaderSet(); this.headerSet.timestamp = header.timestamp; } this.headerSet.addHeader(header); this.emit('header', header); } } }, _emitHeaderSet() { if (this.headerSet) { if (this.headerSetTimestamp) { this.headerSet.timestamp = this.headerSetTimestamp; } this.emit('headerSet', this.headerSet); this.headerSet = null; } }, _processRecordForTopologyScan(buffer) { const type = buffer [1] &amp; 0x0F; let destinationAddress = 0, sourceAddress = 0, protocolVersion = 0, command = 0, hasHeader = false; if (((type === 3) || (type === 6)) &amp;&amp; (buffer.length &gt;= 20)) { destinationAddress = buffer.readUInt16LE(14); sourceAddress = buffer.readUInt16LE(16); protocolVersion = buffer.readUInt16LE(18); const majorVersion = protocolVersion &gt;&gt; 4; if ((majorVersion === 1) &amp;&amp; (buffer.length &gt;= 26)) { command = buffer.readUInt16LE(20); hasHeader = true; } } else if (type === 4) { this.currentChannel = 0; } else if ((type === 7) &amp;&amp; (buffer.length &gt;= 16)) { this.currentChannel = buffer [14]; } else if ((type === 8) &amp;&amp; (buffer.length &gt;= 22)) { const startTimestamp = moreints.readUInt64LE(buffer, 6); const endTimestamp = moreints.readUInt64LE(buffer, 14); const rawBuffer = Buffer.alloc(buffer.length - 22); buffer.copy(rawBuffer, 0, 22, buffer.length); this.emit('rawData', { startTimestamp: new Date(startTimestamp), endTimestamp: new Date(endTimestamp), channel: this.currentChannel, buffer: rawBuffer, }); } if (hasHeader) { const headerIdBuffer = Buffer.alloc(8); headerIdBuffer [0] = this.currentChannel; headerIdBuffer.writeUInt16LE(destinationAddress, 1); headerIdBuffer.writeUInt16LE(sourceAddress, 3); headerIdBuffer [5] = protocolVersion; headerIdBuffer.writeUInt16LE(command, 6); const headerId = headerIdBuffer.toString('hex'); this.knownHeaderIds [headerId] = true; } }, _constructTopologyHeaderSet() { const headerSet = new HeaderSet(); const timestamp = new Date(0); _.forEach(_.keys(this.knownHeaderIds), (headerId) =&gt; { const headerIdBuffer = Buffer.from(headerId, 'hex'); const channel = headerIdBuffer [0]; const destinationAddress = headerIdBuffer.readUInt16LE(1); const sourceAddress = headerIdBuffer.readUInt16LE(3); const protocolVersion = headerIdBuffer [5]; const command = headerIdBuffer.readUInt16LE(6); const majorVersion = (protocolVersion &gt;&gt; 4); if (majorVersion === 1) { const packet = new Packet({ timestamp, channel, destinationAddress, sourceAddress, command, frameCount: 0, }); headerSet.addHeader(packet); } else { throw new Error('Unsupported major version'); } }); headerSet.timestamp = timestamp; this.headerSet = headerSet; }, }); module.exports = VBusRecordingConverter; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Global Methods extend(parent, protoProps, staticProps) A helper method for classical inheritance. Parameters: Name Type Argument Description parent function &lt;nullable&gt; Parent class constructor protoProps object &lt;nullable&gt; Properties to be mixed-in the prototype of the child class staticProps object &lt;nullable&gt; Properties to be mixed-in the constructor function of the child class Source: extend.js Returns: Child class constructor Type function getOptimizerOptions() Get an array of possible options for calling this ConfigurationOptimizer's constructor. Source: configuration-optimizer.js Returns: A promise that resolves to an array of constructor options. Type Promise matchOptimizer(options) Find settings for this ConfigurationOptimizer's constructor that matches the given options best. Parameters: Name Type Description options object Options to look for while searching a matching configuration optimizer. Properties Name Type Description id string The identifier for the ConfigurationOptimizer. deviceAddress number The VBus address of the controller. version string The version of the controller. customizer Customizer A Customizer instance to query additional information with. Source: configuration-optimizer.js Returns: A Promise that resolves to the best matching optimizer result or null if no match was found. Type Promise Type Definitions BlockTypeSection Type: object Properties: Name Type Description sectionId string Section identifier surrogatePacketId string Surrogate packet identifier packet Packet Packet object packetSpec PacketSpecification PacketSpecification object startOffset number Offset of section start within Packet frame data endOffset number Offset of section end within Packet frame data type number Section type payloadCount number Count of payload elements frameCount number Count of frames frameData Buffer Frame data Source: specification.js Configuration Type: Array.&lt;ConfigurationValue&gt; Source: configuration-optimizer.js ConfigurationValue Type: object Properties: Name Type Description valueId String Value ID valueIndex number Value Index value number Value priority number Priority (higher numbers mean higher priority) pending boolean Indicates that this value has to be tranceived. transceived boolean Indicates that this value has been tranceived. Source: configuration-optimizer.js DeviceSpecification Type: object Properties: Name Type Description deviceId string Device identifier channel number VBus channel selfAddress number VBus address of the device itself peerAddress number VBus address of the device's peer name string Name of the device fullName string Name of the device optionally prefixed with VBus channel (if it is not 0) Source: specification.js FilteredPacketFieldSpecification Type: object Properties: Name Type Description filteredPacketFieldId string packetId string fieldId string name string type string getRawValue string Source: specification.js PacketField Type: object Properties: Name Type Description id string Packet field identifier packet Packet Packet packetSpec PacketSpecification packetFieldSpec PacketFieldSpecification origPacketFieldSpec PacketFieldSpecification name string rawValue number Raw value formatTextValue function Function to format this packet field's raw value into textual form Source: specification.js packetFieldGetRawValue(buffer, start, end) Parameters: Name Type Description buffer Buffer Buffer object start number Start index in the buffer end number End index in the buffer Source: specification.js PacketFieldSpecification Type: object Properties: Name Type Description fieldId string Field identifier name object Object containing names by language code type TypeSpecification TypeSpecification object getRawValue packetFieldGetRawValue Function to get raw value from a buffer Source: specification.js PacketSpecification Type: object Properties: Name Type Description packetId string Packet identifier channel number VBus channel destinationAddress number VBus address of the destination device sourceAddress number VBus address of the source device protocolVersion number VBus protocol version command number VBus command info number Additional info for sorting purposes destinationDevice DeviceSpecification DeviceSpecification object of the destination device sourceDevice DeviceSpecification DeviceSpecification object of the source device packetFields Array.&lt;PacketFieldSpecification&gt; Array of PacketFieldSpecification objects Source: specification.js RawData Type: object Properties: Name Type Description channel Number VBus Channel number startTimestamp Date Timestamp of the start of reception of this data endTimestamp Date Timestamp of the end of reception of this data buffer Buffer The VBus raw data buffer Source: converter.js TypeSpecification Type: object Properties: Name Type Description typeId String Type identifier rootTypeId String Root type identifier precision number Precision for numeral values unit UnitSpecification Unit object Source: specification.js UnitSpecification Type: object Properties: Name Type Description unitId String Unit identifier unitCode String Unit code unitFamily String Unit family unitText String Unit text Source: specification.js × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Classes Classes Connection ConnectionCustomizer Converter Customizer Datagram DLxJsonConverter DLxRecorder Header HeaderSet HeaderSetConsolidator I18N Packet Recorder SerialConnection SerialDataSource Specification TcpConnection TcpConnectionEndpoint TcpDataSource TcpDataSourceProvider Telegram TextConverter VBusRecordingConverter Events addHeader This event is fired whenever a Header instance is added to this set. Type: Header Source: header-set.js removeHeader This event is fired whenever a Header is removed from this set. Type: Header Source: header-set.js addHeader This event is fired whenever a Header instance is added to this set. Type: Header Inherited From: HeaderSet#event:addHeader Source: header-set.js removeHeader This event is fired whenever a Header is removed from this set. Type: Header Inherited From: HeaderSet#event:removeHeader Source: header-set.js × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer resol-vbus A JavaScript library for processing RESOL VBus data. Features Connects to various RESOL VBus devices Processes live and recorded VBus data streams Discovers LAN-enabled RESOL devices on the local network Allows to send parameterization commands to a controller Synchronizes recorded VBus data from a RESOL datalogger to your local file system Converts recorded VBus data into human or machine readable formats, optionally allowing to filter the output Documentation You can find the work-in-progress documentation for this project here: http://danielwippermann.github.io/resol-vbus/ The JSDoc-generated documentation is located here: http://danielwippermann.github.io/resol-vbus/jsdoc/classes.list.html Installation If you want to use this module in your own application, you can just install it from the npm registry: ⌘ npm install --save resol-vbus If you want to contribute to it you might want to check out the latest version from GitHub: ⌘ git clone https://github.com/danielwippermann/resol-vbus.git ⌘ cd resol-vbus ⌘ npm install Running the console examples ⌘ node examples/&lt;name&gt;/index.js Running the tests To start a single run of the test suite just enter the following command into your shell: ⌘ gulp In addition to that the project is configured to watch its own files for modification and rerun the documentation generator and test suite every time you hit save on a file. To run that just enter the following command into your shell: ⌘ gulp watch Supported Devices &amp; Services All current RESOL controllers with VBus RESOL DL2 Datalogger RESOL DL3 Datalogger RESOL KM2 Communication module RESOL VBus/LAN interface adapter RESOL VBus/USB interface adapter RESOL VBus.net Technical Information &amp; Specifications RESOL VBus Google Group RESOL VBus Protocol Specification RESOL VBus Packet List RESOL VBus Recording File Format RESOL VBus Specification File Format v1 RESOL VBus over TCP Specification RESOL DL2 (v1) Data Download API RESOL DL2 (v2) &amp; DL3 Data Download API Known issues The FileSystemRecorder class sometimes writes invalid JSON into its \"SyncState.json\" file causing it to not being able to restore and recover from that when the app using the recorder restarts (e.g. the \"vbustouch-proxy\" example). The ConfigurationOptimizers do not yet detect the firmware version running on the controller to be configured. That sometimes causes configuration loads and saves to fail because unknown values are read from or written to (e.g. using the \"customizer\" example on a DeltaSol MX with firmware version 1.11 or below). Short-term plans Remove current ConfigurationOptimizer constructs in favor of RESOL's official support. Changelog Work in progress Version 0.20.0 (2019-06-15) This version contains several breaking changes! You have been warned... Refactor code to make use of ES2018 features (using Babel to back-support up to Node.js 6) Remove custom Promise implementation in favor of built-in, native one. Promise return values no longer provide the finally and done methods. Remove utils.promise, utils.Promise and utils.cancelablePromise. Add reportProgress and checkCanceled options to ConnectionCustomizer#transceive{Configuration,Value} as a replacement to the previously used cancelablePromise solution. Add RESOL DeltaSol C configuration optimizer. Add support for VBus-over-TCP wrapped in TLS. Version 0.17.0 (2018-02-10) Add Buffer support to Connection#(get|set)ValueById for values larger than 32-bit. Add Connection#getCaps1. Add bulk value transaction support to Connection class. Add support to generate and parse \"type 9\" comment records using VBusRecordingConverter. Make it easier to create a Specification from a SpecificationFile. Extend vbustouch-proxy example with text data logging feature. Update dependencies. Some minor bug fixes. Version 0.16.0 (2017-02-01) Use VSF binary file to load VBus specification data Add support to read and write raw data in VBus recordings Extend VBusRecordingConverter to support fast topology-only scan Code clean up Several minor bug fixes Version 0.15.0 (2016-03-30) Update VBus specification data Several minor bug fixes Version 0.14.0 (2015-10-29) Improve configuration optimizers and their discovery Update VBus specification data Version 0.13.0 (2015-05-14) Add configuration optimizers for RESOL DeltaSol SLT Add BlockType support Version 0.12.2 (2015-05-05) Update VBus specification data Version 0.12.1 (2015-04-27) Add configuration optimizers for RESOL DeltaSol MX and BS/4 v2 Add a simple JSON live data server example Add some documentation Several bug fixes Version 0.12.0 (2015-02-28) Add vbustouch-proxy example Add support for rounding floating point numbers Version 0.11.1 (2014-11-04) Fix a floating point bug caused by setRawValue Version 0.11.0 (2014-10-29) Added support for setting packet field values Several bug fixes Version 0.10.0 (2014-04-26) Finalized support for customizing controller configuration. Several bug fixes. Version 0.9.0 (2014-03-16) Completed Recorder class by adding support for recording Added unit conversion to VBus specification Several bug fixes. Version 0.8.0 (2014-03-03) Extended Converter and VBusRecordingConverter to support object mode in stream (for performance reason) Fixed several bugs Increased test coverage and completed documentation. Version 0.7.0 (2014-02-17) First release to the NPM registry. Contributors Thorsten Müller Paul Hanna Sabine Käß Andrew Thompson (@thompsa) Legal Notices RESOL, VBus, VBus.net and others are trademarks or registered trademarks of RESOL - Elektronische Regelungen GmbH. All other trademarks are the property of their respective owners. License The MIT License (MIT) Copyright (c) 2013-2018, Daniel Wippermann. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. × Search results Close "},"Connection.html":{"id":"Connection.html","title":"Class: Connection","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Connection Connection The Connection class is the abstract base class for all VBus live data connections. It extends the Duplex stream class. Any data written to a Connection instance is parsed according to the VBus Protocol Specification. Once a valid instance of one of the Header sub-classes (Packet, Datagram or Telegram) is created from the binary data stream, the respective event is emitted on the Connection instance. In addition to receiving incoming data the Connection class offers several helper methods e.g. to send data to the underlying VBus connection. The Connection class itself has no knowledge about the underlying VBus connection. Several sub-classes exist that know how to contact different types of VBus live streams. See SerialConnection or TcpConnection for concrete implementations. new Connection(options) Creates a new Connection instance and optionally initializes its member with the given values. Parameters: Name Type Description options object Initialization values for this instance's members Properties Name Type Description channel number See Connection#channel selfAddress number See Connection#selfAddress Source: connection.js Example var connection = new SerialConnection({ path: '/dev/tty.usbserial' }); connection.on('connectionState', function(state) { console.log(state); }); connection.on('packet', function(packet) { console.log(packet.getId()); }); connection.on('datagram', function(datagram) { console.log(datagram.getId()); }); connection.connect(); Extends Duplex Members channel :number The VBus channel that this connection is established to. All Header instances created by this Connection instance will be assigned this VBus channel. Type: number Source: connection.js connectionState :string The current connection state. Type: string Source: connection.js dataSource :DataSource Reference to this instance's DataSource. Type: DataSource Source: connection.js rxBuffer :Buffer The internal receive buffer of this conneciton. Type: Buffer Source: connection.js selfAddress :number The VBus address used for sending information over this connection. Type: number Source: connection.js Methods beginBulkValueTransaction(address, txTimeout, options) Sends a Datagram to begin a bulk valke transaction. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to begin the transaction on. txTimeout number The number of seconds of inactivity after which the transaction is rolled back. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise commitBulkValueTransaction(address, options) Sends a Datagram to commit a bulk valke transaction. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to commit the transaction on. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise &lt;abstract&gt; connect() Establish underlying connection and start streaming data to the writable side of this Connection instance's stream. Source: connection.js Returns: A promise that resolves once the connection has been established. Type Promise createConnectedPromise() Creates a promise that resolves when this Connection instance is connected and rejects if it is disconnected. If it is neither connected nor disconnected the promise will stay pending until one of the states is entered. Source: connection.js Returns: Type Promise &lt;abstract&gt; disconnect() Diconnect this instance. Source: connection.js getCaps1(address, options) Sends a Datagram to lookup the controller's capabilities (part 1). Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to get the capabilities from. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise getValueById(address, valueId, options) Sends a Datagram to get a value from a device. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to get the value from valueId number The ID of the value to read from the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to get the value. Source: connection.js Returns: A promise that resolves to the received Datagram or null on timeout. Type Promise getValueIdByIdHash(address, valueIdHash, options) Sends a Datagram to lookup a value ID in a device. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to lookup the value in. valueIdHash number The ID hash of the value to lookup in the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise getValueIdHashById(address, valueId, options) Sends a Datagram to lookup a value ID hash in a device. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to lookup the value in. valueId number The ID of the value to lookup in the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise releaseBus(address, options) Sends a VBus bus release datagram (Command 0x0600). Returns a Promise that resolves with the first VBus packet received after the release or null on timeout. Parameters: Name Type Description address number The VBus address of the master device to give the bus ownership back to. options object Properties Name Type Default Description tries number 2 Number of tries to give the bus ownership back. timeout number 1500 Time in milliseconds to wait between tries. Source: connection.js rollbackBulkValueTransaction(address, options) Sends a Datagram to rollback a bulk valke transaction. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to perform the rollback on. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise send(data) Send raw data over this Connection instance. Parameters: Name Type Description data Header | Buffer The Header or Buffer instance to be sent. Source: connection.js setBulkValueById(address, valueId, value, options) Sends a Datagram to set a value during a bulk value transaction. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to set the value on. valueId number The ID of the value to write to the device. value number The value to write to the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise setValueById(address, valueId, value, options) Sends a Datagram to set a value in a device. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to set the value in valueId number The ID of the value to write to the device. value number The value to write to the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to get the value. Source: connection.js Returns: A promise that resolves to the received Datagram or null on timeout. Type Promise transceive(txData, options) Sends and / or receives a VBus data. Parameters: Name Type Description txData Header | Buffer The Header or Buffer instance to be sent. options object Properties Name Type Argument Description timeout number Timeout in milliseconds after which the txData will be sent again timeoutIncr number After each timeout retransmission the timeout value for the next try is increment by this value. tries number After this number of tries the returned Promise will resolve with value null. filterPacket function &lt;nullable&gt; Will be called when a Packet has been received with the Packet and a callback as arguments. filterDatagram function &lt;nullable&gt; Will be called when a Datagram has been received with the Datagram and a callback as arguments. Source: connection.js Returns: A Promise that either resolves to the VBus data selected by one of the filter callbacks or null on timeout. Type Promise waitForFreeBus(timeout) Waits for a VBus bus offering datagram (Command 0x0500). Returns a Promise that resolves with the Datagram or null if the method timed out. Parameters: Name Type Default Description timeout number 20000 Timeout in milliseconds Source: connection.js Returns: A Promise that resolves to the bus offering Datagram or null on timeout. Type Promise × Search results Close "},"ConnectionCustomizer.html":{"id":"ConnectionCustomizer.html","title":"Class: ConnectionCustomizer","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: ConnectionCustomizer ConnectionCustomizer A ConnectionCustomizer uses an established connection to a device to transfer sets of configuration values over it. new ConnectionCustomizer( [options]) Constructs a new ConnectionCustomizer instance and optionally initializes its members with the given values. Parameters: Name Type Argument Description options object &lt;optional&gt; Initialization values for this instance's members Properties Name Type Argument Description connection number &lt;optional&gt; ConnectionCustomizer#connection maxRounds number &lt;optional&gt; ConnectionCustomizer#maxRounds triesPerValue number &lt;optional&gt; ConnectionCustomizer#triesPerValue timeoutPerValue number &lt;optional&gt; ConnectionCustomizer#timeoutPerValue masterTimeout number &lt;optional&gt; ConnectionCustomizer#masterTimeout Source: connection-customizer.js Extends Customizer Members connection :Connection The connection to use for transfer of the configuration values. Type: Connection Source: connection-customizer.js deviceAddress :number The VBus address of the device to customize. Type: number Inherited From: Customizer#deviceAddress Source: customizer.js id :string An identifier for this customizer. Type: string Inherited From: Customizer#id Source: customizer.js masterTimeout :number Interval in milliseconds in which the VBus master is contacted to reissue the VBus clearance. Type: number Default Value: 8000 Source: connection-customizer.js maxRounds :number Maximum number of optimization rounds for transceiveConfiguration. Type: number Default Value: 10 Source: connection-customizer.js optimizer :ConfigurationOptimizer A configuration optimizer. Type: ConfigurationOptimizer Inherited From: Customizer#optimizer Source: customizer.js timeoutPerValue :number Timeout in milliseconds after which the transceive times out. Type: number Default Value: 30000 Source: connection-customizer.js triesPerValue :number Amount of retries to transceive one value. Between two tries the VBus is released and then re-acquired. Type: number Default Value: 2 Source: connection-customizer.js Methods _completeConfiguration(config) Converts the configuration provided into an array of {@see ConfigurationValue} objects. The provided configuration can be either an array of partially initialized ConfigurationValue objects or an object mapping value IDs as keys to values. If no configuration is given a complete configuration set is returned. Parameters: Name Type Description config undefined | null | array | object Configuration to complete. Inherited From: Customizer#_completeConfiguration Source: customizer.js Returns: A Promise that resolves to the completed array of values. Type Promise _loadConfiguration() Load a set of configuration values from a device. See Customizer#loadConfiguration for details. Source: connection-customizer.js _optimizeLoadConfiguration(config) Gets the optimized array of values based on what values are already loaded. Parameters: Name Type Description config array The array of values that has already been loaded. Inherited From: Customizer#_optimizeLoadConfiguration Source: customizer.js Returns: A Promise that resolves to the array of values to load next. Type Promise _optimizeSaveConfiguration(newConfig, oldConfig) Gets the optimzed array of values to save to the controller. Parameters: Name Type Description newConfig array The array of values to transfer. oldConfig array The array of values that are assumed to be currently stored in the device. Inherited From: Customizer#_optimizeSaveConfiguration Source: customizer.js Returns: A Promise that resolves to the array of values to save. Type Promise _saveConfiguration() Save a set of configuration values to a device. See Customizer#saveConfiguration for details. Source: connection-customizer.js loadConfiguration(configuration, options) Load a set of configuration values from a device. If the Customizer has an optimizer set, the configuration parameter is passed to the optimizer's completeConfiguration method. Otherwise it must be an array of ConfigurationValue objects. If options.optimize is \"truthy\" the list of ConfigurationValue objects is passed into the optimizer's optimizeLoadConfiguration method to determine the minimal set of values to transfer. If options.optimize is \"falsy\" all of the ConfigurationValue objects will be loaded. Parameters: Name Type Description configuration array The set of values to transfer. options object Inherited From: Customizer#loadConfiguration Source: customizer.js Returns: A Promise that resolves to the set of values transfered. Type Promise saveConfiguration(newConfiguration, oldConfiguration, options) Save a set of configuration values to a device. If the Customizer has an optimizer set, the newConfiguration parameter is passed to the optimizer's completeConfiguration method. Otherwise it must be an array of ConfigurationValue objects. If a oldConfiguration parameter is given, the same procedure as for the newConfiguration is applied to it as well. If options.optimize is \"truthy\" the list of ConfigurationValue objects is passed into the optimizer's optimizeLoadConfiguration method to determine the minimal set of values to transfer. If options.optimize is \"falsy\" all of the ConfigurationValue objects will be loaded. Parameters: Name Type Description newConfiguration array The set of values to transfer. oldConfiguration array The set of values to assume to be stored in the device. options object Inherited From: Customizer#saveConfiguration Source: customizer.js Returns: A Promise that resolves to the set of values transfered. Type Promise transceiveConfiguration(options, optimizerCallback) Transceives a controller configuration set, handling timeouts, retries etc. Parameters: Name Type Description options object Options Properties Name Type Argument Description maxRounds number &lt;optional&gt; ConnectionCustomizer#maxRounds triesPerValue number &lt;optional&gt; ConnectionCustomizer#triesPerValue timeoutPerValue number &lt;optional&gt; ConnectionCustomizer#timeoutPerValue masterTimeout number &lt;optional&gt; ConnectionCustomizer#masterTimeout action string Action to perform, can be 'get' or 'set'. actionOptions object &lt;optional&gt; Options object to forward to the action to perform. reportProgress function &lt;optional&gt; Callback to inform about progress. checkCanceled function &lt;optional&gt; Callback to check whether the operation should be canceled. optimizerCallback function Callback to optimize configuration between rounds. Source: connection-customizer.js Returns: Promise that resolves to the configuration or null on timeout. Type object transceiveValue(valueInfoOrIndex, value, options, state) Transceive a controller value over this connection, handling timeouts, retries etc. Parameters: Name Type Description valueInfoOrIndex object | number Value info object or value index valueInfo.valueIndex number Value index valueInfo.valueIdHash number Value ID hash value number Value options object Options Properties Name Type Argument Description triesPerValue number ConnectionCustomizer#triesPerValue timeoutPerValue number ConnectionCustomizer#timeoutPerValue masterTimeout number ConnectionCustomizer#masterTimeout action string Action to perform, can be 'get' or 'set'. actionOptions object &lt;optional&gt; Options object to forward to the action to perform. reportProgress function &lt;optional&gt; Callback to inform about progress. checkCanceled function &lt;optional&gt; Callback to check whether the operation should be canceled. state object State to share between multiple calls to this method. Source: connection-customizer.js Returns: Promise that resolves with the datagram received or null on timeout. Type object × Search results Close "},"Converter.html":{"id":"Converter.html","title":"Class: Converter","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Converter Converter Converter instances are streams that convert VBus models (Packet, Datagram and Telegram instances) and / or Headerset instances to another representation. Optionally some Converter sub-classes support parsing that representation back to the model instances. Converter sub-classes include VBusRecordingConverter (for parsing and generating according to the VBus Recording File Format) and TextConverter that creates character-separated text representations. new Converter(options) Creates a new Converter instance and optionally initializes its members with the given values. Parameters: Name Type Description options object Initialization values Properties Name Type Description objectMode boolean See Converter#objectMode Source: converter.js Extends Duplex Members objectMode :boolean Specifies whether the underlying stream operates in object mode. Type: boolean Source: converter.js Methods convertHeader(header) This method queues a VBus Header model (Packet, Datagram or Telegram) for conversion. Not all Converter sub-classes support this method. Parameters: Name Type Description header Header The Header to queue for conversion. Source: converter.js convertHeaderSet(headerSet) This method queues a VBus HeaderSet instance for conversion. Not all Converter sub-classes support this method. Parameters: Name Type Description headerSet HeaderSet The HeaderSet to queue for conversion. Source: converter.js convertRawData(rawData) This method queues a VBus raw data chunk from conversion. Not all Converter sub-classes support this method. Parameters: Name Type Description rawData RawData The VBus raw data chunk to queue for conversion. Source: converter.js finish() This method signals that no additional VBus Header or HeaderSet models will be converted. It returns a promise that resolves when all data has been consumed. Source: converter.js Returns: A Promise that resolves when all data has been consumed. Type Promise reset() This method resets the converter. It should be used e.g. if the converter output switches between files (allows some Converter sub-classes to correctly write a header). Source: converter.js × Search results Close "},"Customizer.html":{"id":"Customizer.html","title":"Class: Customizer","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Customizer Customizer A Customizer provides functionality to transfer a set of configuration values from or to a device. new Customizer( [options]) Creates a new Customizer instance and optionally initializes its members with the given values. Parameters: Name Type Argument Description options object &lt;optional&gt; Initialization values for this instance's members Properties Name Type Argument Description id string &lt;optional&gt; Customizer#id deviceAddress string &lt;optional&gt; Customizer#deviceAddress optimizer string &lt;optional&gt; Customizer#optimizer Source: customizer.js Members deviceAddress :number The VBus address of the device to customize. Type: number Source: customizer.js id :string An identifier for this customizer. Type: string Source: customizer.js optimizer :ConfigurationOptimizer A configuration optimizer. Type: ConfigurationOptimizer Source: customizer.js Methods _completeConfiguration(config) Converts the configuration provided into an array of {@see ConfigurationValue} objects. The provided configuration can be either an array of partially initialized ConfigurationValue objects or an object mapping value IDs as keys to values. If no configuration is given a complete configuration set is returned. Parameters: Name Type Description config undefined | null | array | object Configuration to complete. Source: customizer.js Returns: A Promise that resolves to the completed array of values. Type Promise _optimizeLoadConfiguration(config) Gets the optimized array of values based on what values are already loaded. Parameters: Name Type Description config array The array of values that has already been loaded. Source: customizer.js Returns: A Promise that resolves to the array of values to load next. Type Promise _optimizeSaveConfiguration(newConfig, oldConfig) Gets the optimzed array of values to save to the controller. Parameters: Name Type Description newConfig array The array of values to transfer. oldConfig array The array of values that are assumed to be currently stored in the device. Source: customizer.js Returns: A Promise that resolves to the array of values to save. Type Promise loadConfiguration(configuration, options) Load a set of configuration values from a device. If the Customizer has an optimizer set, the configuration parameter is passed to the optimizer's completeConfiguration method. Otherwise it must be an array of ConfigurationValue objects. If options.optimize is \"truthy\" the list of ConfigurationValue objects is passed into the optimizer's optimizeLoadConfiguration method to determine the minimal set of values to transfer. If options.optimize is \"falsy\" all of the ConfigurationValue objects will be loaded. Parameters: Name Type Description configuration array The set of values to transfer. options object Source: customizer.js Returns: A Promise that resolves to the set of values transfered. Type Promise saveConfiguration(newConfiguration, oldConfiguration, options) Save a set of configuration values to a device. If the Customizer has an optimizer set, the newConfiguration parameter is passed to the optimizer's completeConfiguration method. Otherwise it must be an array of ConfigurationValue objects. If a oldConfiguration parameter is given, the same procedure as for the newConfiguration is applied to it as well. If options.optimize is \"truthy\" the list of ConfigurationValue objects is passed into the optimizer's optimizeLoadConfiguration method to determine the minimal set of values to transfer. If options.optimize is \"falsy\" all of the ConfigurationValue objects will be loaded. Parameters: Name Type Description newConfiguration array The set of values to transfer. oldConfiguration array The set of values to assume to be stored in the device. options object Source: customizer.js Returns: A Promise that resolves to the set of values transfered. Type Promise × Search results Close "},"Datagram.html":{"id":"Datagram.html","title":"Class: Datagram","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Datagram Datagram The Datagram sub-class provides access to all properties and methods applicable for VBus version 2 datagrams. In addition to the packet header it may contain a command, a value ID and a value. The value ID is a device-specific reference to one of the values presented in the device's menu interface. new Datagram(options) Creates a new Datagram instance and optionally initializes its members with the given values. Parameters: Name Type Description options object Initialization values for this instance's members Properties Name Type Description command number Datagram#command valueId number Datagram#valueId value Buffer Datagram#value Source: datagram.js See: Header#constructor Extends Header Members channel :number VBus channel of this header Type: number Inherited From: Header#channel Default Value: 0 Source: header.js command :number The command field of this VBus datagram. See the VBus Protocol Specification for details. Type: number Source: datagram.js destinationAddress :number VBus address of this header's destination Type: number Inherited From: Header#destinationAddress Default Value: 0 Source: header.js sourceAddress :number VBus address of this header's source Type: number Inherited From: Header#sourceAddress Source: header.js timestamp :Date Timestamp of this header Type: Date Inherited From: Header#timestamp Default Value: now Source: header.js value :number The value field of this VBus datagram. Type: number Source: datagram.js valueId :number The value ID field of this VBus datagram. Type: number Source: datagram.js Methods compareTo(that) Compares this Header instance to another one. Sub-classes can extend the comparison to include specific information. Parameters: Name Type Description that Header Another Header instance to compare to. Inherited From: Header#compareTo Overrides: Header#compareTo Source: header.js Returns: Returns a number less than 0 if this &lt; that greater than 0 if this &gt; that equal to to if this == that Type number getId() Returns a string identifier describing this Header instance. It contains at least: channel destination address source address protocol version Sub-classes can extend that information. The structure of this identifier is implementation specific, do not rely on it! Inherited From: Header#getId Overrides: Header#getId Source: header.js Returns: Identifier Type string getInfo() Returns an info number about this Header instance. It can be used for sorting purposes (to distinguish Header objects that would otherwise compare as equal). Inherited From: Header#getInfo Overrides: Header#getInfo Source: header.js Returns: Info value Type number &lt;abstract&gt; getProtocolVersion() Returns the protocol version of this Header instance as a 8-bit number. The high nibble is used for the major version, the low nibble for the minor version. For example: a header with protocol version 2.0 would return 0x20. Must be implemented by sub-class. Inherited From: Header#getProtocolVersion Overrides: Header#getProtocolVersion Source: header.js Returns: Protocol version Type number &lt;abstract&gt; toLiveBuffer( [buffer] [, start] [, end]) Creates a representation of this Header instance that can be transmitted over a Connection. If no buffer is given as an arguments, it creates a new one that is big enough to hold the representation. Must be implemented by sub-class. Parameters: Name Type Argument Description buffer Buffer &lt;optional&gt; Buffer object to store data in start number &lt;optional&gt; Start index in the buffer end number &lt;optional&gt; End index in the buffer Inherited From: Header#toLiveBuffer Overrides: Header#toLiveBuffer Source: header.js Returns: Buffer object containing the data Type Buffer × Search results Close "},"DLxJsonConverter.html":{"id":"DLxJsonConverter.html","title":"Class: DLxJsonConverter","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: DLxJsonConverter DLxJsonConverter The DLxJsonConverter class takes HeaderSet instances, converts them into JSON representation and then publishes that on the readable stream side of itself. The format of the JSON data is similar to the one that is generated by the Dataloggers DL2 and DL3. It does not support parsing JSON content back into HeaderSet instances (the writable stream side). new DLxJsonConverter(options) Creates a new DLxJsonConverter instance and optionally initializes its members with the given values. Parameters: Name Type Description options object Initialization values Properties Name Type Description specification object See DLxJsonConverter#specification Source: dlx-json-converter.js Extends Converter Members objectMode :boolean Specifies whether the underlying stream operates in object mode. Type: boolean Inherited From: Converter#objectMode Source: converter.js specification :Specification Reference to the Specification instance that is used for the binary -&gt; text conversion. Type: Specification Source: dlx-json-converter.js Methods convertHeader(header) This method queues a VBus Header model (Packet, Datagram or Telegram) for conversion. Not all Converter sub-classes support this method. Parameters: Name Type Description header Header The Header to queue for conversion. Inherited From: Converter#convertHeader Source: converter.js convertHeaderSet(headerSet) This method queues a VBus HeaderSet instance for conversion. Not all Converter sub-classes support this method. Parameters: Name Type Description headerSet HeaderSet The HeaderSet to queue for conversion. Inherited From: Converter#convertHeaderSet Overrides: Converter#convertHeaderSet Source: converter.js convertRawData(rawData) This method queues a VBus raw data chunk from conversion. Not all Converter sub-classes support this method. Parameters: Name Type Description rawData RawData The VBus raw data chunk to queue for conversion. Inherited From: Converter#convertRawData Source: converter.js finish() This method signals that no additional VBus Header or HeaderSet models will be converted. It returns a promise that resolves when all data has been consumed. Inherited From: Converter#finish Overrides: Converter#finish Source: converter.js Returns: A Promise that resolves when all data has been consumed. Type Promise reset() This method resets the converter. It should be used e.g. if the converter output switches between files (allows some Converter sub-classes to correctly write a header). Inherited From: Converter#reset Overrides: Converter#reset Source: converter.js × Search results Close "},"DLxRecorder.html":{"id":"DLxRecorder.html","title":"Class: DLxRecorder","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: DLxRecorder DLxRecorder DLxRecorder is a recorder that can play back data recorded by a Datalogger. new DLxRecorder() Creates a new DLxRecorder instance. Source: dlx-recorder.js Extends Recorder Members id :string Identifier for this recorder instance. It may be used to reference recorders, for example in sync data storage. Type: string Inherited From: Recorder#id Source: recorder.js interval :number Interval to be used as a default during playback and synchronization. Type: number Inherited From: Recorder#interval Default Value: 0 Source: recorder.js maxTimestamp :Date Maximum timestamp to use as a default during playback and synchronization. Type: Date Inherited From: Recorder#maxTimestamp Default Value: '2038-01-01T00:00:00.000Z' Source: recorder.js minTimestamp :Date Minimum timestamp to use as a default during playback and synchronization. Type: Date Inherited From: Recorder#minTimestamp Default Value: '2001-01-01T00:00:00.000Z' Source: recorder.js password :string The password to login to the web interface. Type: string Source: dlx-recorder.js urlPrefix :string The root URL to access the DLx. Type: string Source: dlx-recorder.js username :string The username to login to the web interface. Type: string Source: dlx-recorder.js Methods _playbackSyncJob(stream, syncJob) Plays back the requested synchronization job, piping the resulting data into the provided stream. Returns a Promise that resolves to the played back ranges. Parameters: Name Type Description stream Stream The stream (in object mode) to pipe data into syncJob RecorderSyncJob The synchronization job to perform. Inherited From: Recorder#_playbackSyncJob Overrides: Recorder#_playbackSyncJob Source: recorder.js Returns: Promise resolving with a list of ranges that were synchronized. Type Promise _recordSyncJob(recorder, syncJob) Starts a playback of the provided recorder, recording its data and returning a Promise that resolves to the recorded ranges. Parameters: Name Type Description recorder Recorder The recorder to use for playback syncJob RecorderSyncJob The synchronization job to perform. Inherited From: Recorder#_recordSyncJob Source: recorder.js Returns: Promise resolving with a list of ranges that were synchronized. Type Promise playback(stream, options) Plays back a given range of HeaderSets. The stream must be in object mode. Parameters: Name Type Description stream Writable A writable stream options object Options to select and filter HeaderSets Properties Name Type Argument Default Description minTimestamp Date &lt;optional&gt; Recorder#minTimestamp maxTimestamp Date &lt;optional&gt; Recorder#maxTimestamp interval number &lt;optional&gt; Recorder#interval end boolean &lt;optional&gt; true Whether the stream should be end()ed when the playback is complete Inherited From: Recorder#playback Source: recorder.js record(stream, options) Records a given range of HeaderSet instances. The stream must be in object mode. Parameters: Name Type Description stream Readable A readable stream in object mode. options object Options to select and filter HeaderSet instances. Properties Name Type Argument Description minTimestamp Date &lt;optional&gt; See Recorder#minTimestamp maxTimestamp Date &lt;optional&gt; See Recorder#maxTimestamp interval number &lt;optional&gt; See Recorder#interval Inherited From: Recorder#record Source: recorder.js Returns: A Promise that resolves to the recorded ranges. Type Promise synchronizeTo(recorder, options) Synchronize this Recorder's HeaderSets to another Recorder. Parameters: Name Type Description recorder Recorder Destination Recorder options object Options to select and filter HeaderSets Properties Name Type Argument Description minTimestamp Date &lt;optional&gt; Recorder#minTimestamp maxTimestamp Date &lt;optional&gt; Recorder#maxTimestamp interval number &lt;optional&gt; Recorder#interval Inherited From: Recorder#synchronizeTo Source: recorder.js Returns: Promise resolving with a list of ranges that were synchronized. Type Promise × Search results Close "},"Header.html":{"id":"Header.html","title":"Class: Header","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Header Header All VBus models are sub-classes of this Header class. The Header class provides a generic interface and the common properties that all (currently three) different types of VBus models can use. Header instances can either be created by calling the constructor function or by passing a Buffer object containing the binary VBus data to the class method HeaderSubClass.fromLiveBuffer. new Header( [options]) Creates a new Header instance and optionally initializes its members with the given values Parameters: Name Type Argument Description options object &lt;optional&gt; Initialization values for this instance's members Properties Name Type Argument Description timestamp Date &lt;optional&gt; Header#timestamp channel number &lt;optional&gt; Header#channel destinationAddress number &lt;optional&gt; Header#destinationAddress sourceAddress number &lt;optional&gt; Header#sourceAddress Source: header.js See: Packet Datagram Telegram Members channel :number VBus channel of this header Type: number Default Value: 0 Source: header.js destinationAddress :number VBus address of this header's destination Type: number Default Value: 0 Source: header.js sourceAddress :number VBus address of this header's source Type: number Source: header.js timestamp :Date Timestamp of this header Type: Date Default Value: now Source: header.js Methods &lt;static&gt; calcAndCompareChecksumV0(buffer, start, end) Calculates the VBus checksum (according to version x.0 specification) over a part of a Buffer instance and compares it the checksum byte stored at the end position. Parameters: Name Type Description buffer Buffer Buffer to calc and compare checksum for start number Start index in the buffer end number End index in the buffer Source: header.js Returns: Result whether calculated and stored checksum match Type boolean &lt;static&gt; calcAndSetChecksumV0(buffer, start, end) Calculates the VBus checksum (according to version x.0 specification) over a part of the Buffer instance and stores it at the end position. Parameters: Name Type Description buffer Buffer Buffer to calc and store checksum for start number Start index in the buffer end number End index in the buffer Source: header.js Returns: Calculated checksum Type number &lt;static&gt; calcChecksumV0(buffer, start, end) Calculates the VBus checksum (according to version x.0 specification) over a part of a Buffer instance. Parameters: Name Type Description buffer Buffer Buffer to calc checksum for start number Start index in the buffer end number End index in the buffer Source: header.js Returns: Calculated checksum Type number &lt;static&gt; extractSeptett(srcBuffer, srcStart, srcEnd, dstBuffer, dstStart) Copies a part of the source Buffer instance to the destination Buffer instance, extracting the MSBs during the process and storing the septett byte to the destination buffer's end position. Parameters: Name Type Description srcBuffer Buffer Buffer to copy from srcStart number Start index in the source buffer srcEnd number End index in the source buffer dstBuffer Buffer Buffer to copy to dstStart number Start index in the destination buffer Source: header.js &lt;abstract, static&gt; fromLiveBuffer(buffer, start, end) Creates a Header instance from a representation that was received over a Connection. Must be implemented by sub-class. Parameters: Name Type Description buffer Buffer Buffer that contains the representation start number Start index in the buffer end number End index in the buffer Source: header.js Returns: Header instance created from the representation Type Header &lt;static&gt; injectSeptett(srcBuffer, srcStart, srcEnd, dstBuffer, dstStart) Copies a part of the source Buffer instance to the destination Buffer instance, injecting the MSBs stored in the septett byte during the process. Parameters: Name Type Description srcBuffer Buffer Buffer to copy from srcStart number Start index in the source buffer srcEnd number End index in the source buffer dstBuffer Buffer Buffer to copy to dstStart number Start index in the destination buffer Source: header.js compareTo(that) Compares this Header instance to another one. Sub-classes can extend the comparison to include specific information. Parameters: Name Type Description that Header Another Header instance to compare to. Source: header.js Returns: Returns a number less than 0 if this &lt; that greater than 0 if this &gt; that equal to to if this == that Type number getId() Returns a string identifier describing this Header instance. It contains at least: channel destination address source address protocol version Sub-classes can extend that information. The structure of this identifier is implementation specific, do not rely on it! Source: header.js Returns: Identifier Type string getInfo() Returns an info number about this Header instance. It can be used for sorting purposes (to distinguish Header objects that would otherwise compare as equal). Source: header.js Returns: Info value Type number &lt;abstract&gt; getProtocolVersion() Returns the protocol version of this Header instance as a 8-bit number. The high nibble is used for the major version, the low nibble for the minor version. For example: a header with protocol version 2.0 would return 0x20. Must be implemented by sub-class. Source: header.js Returns: Protocol version Type number &lt;abstract&gt; toLiveBuffer( [buffer] [, start] [, end]) Creates a representation of this Header instance that can be transmitted over a Connection. If no buffer is given as an arguments, it creates a new one that is big enough to hold the representation. Must be implemented by sub-class. Parameters: Name Type Argument Description buffer Buffer &lt;optional&gt; Buffer object to store data in start number &lt;optional&gt; Start index in the buffer end number &lt;optional&gt; End index in the buffer Source: header.js Returns: Buffer object containing the data Type Buffer × Search results Close "},"HeaderSet.html":{"id":"HeaderSet.html","title":"Class: HeaderSet","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: HeaderSet HeaderSet new HeaderSet(options) Creates a new header set instance and optionally initializes its members with the given values. Parameters: Name Type Description options object Initialization values for this instance's members Properties Name Type Description timestamp Date HeaderSet#timestamp headers Array.&lt;Header&gt; Array of Headers to add to this instance Source: header-set.js Extends EventEmitter Members headerList :Array.&lt;Header&gt; Array of Header instances in this set. Type: Array.&lt;Header&gt; Source: header-set.js timestamp :Date Timestamp of the youngest Header instance added to this set. Type: Date Source: header-set.js Methods addHeader(header) Adds a Header instance to this set, replacing a previously added Header of same kind. Parameters: Name Type Description header Header The Header instance to add to this set. Source: header-set.js addHeaders(headers) Adds a list of Header instances to this set, replacing previously added Headers of same kind. Parameters: Name Type Description headers Array.&lt;Header&gt; The list of Header instances to add. Source: header-set.js containsHeader() Returns true if a Header of the same kind is already added to the HeaderSet. Source: header-set.js Returns: true if a Header of the same kind is already in the HeaderSet, false otherwise. Type boolean getHeaderCount() Returns the count of Header instances currently stored in this set. Source: header-set.js Returns: Number of Header instances in this set. Type number getHeaders() Returns an unsorted list of Header instances stored in this set. Source: header-set.js Returns: List of headers stored in this set. Type Array.&lt;Header&gt; getId() Returns an ID composed of the IDs of all headers stored in this set. Source: header-set.js Returns: ID of this HeaderSet. Type string getIdHash() Returns an ID hash for this HeaderSet instance. Source: header-set.js Returns: ID hash for this HeaderSet Type string getSortedHeaders() Returns a sorted list of Header instances stored in this set. Source: header-set.js Returns: List of headers stored in this set. Type Array.&lt;Header&gt; removeAllHeaders() Removes all Header instances from this set. Source: header-set.js removeHeadersOlderThan(timestamp) Removes all Header instances from this set which are older than the given timestamp. Parameters: Name Type Description timestamp number | Date Timestamp to compare Header instances against. Source: header-set.js Events addHeader This event is fired whenever a Header instance is added to this set. Type: Header Source: header-set.js removeHeader This event is fired whenever a Header is removed from this set. Type: Header Source: header-set.js × Search results Close "},"HeaderSetConsolidator.html":{"id":"HeaderSetConsolidator.html","title":"Class: HeaderSetConsolidator","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: HeaderSetConsolidator HeaderSetConsolidator The HeaderSetConsolidator extends the functionality of the HeaderSet class by allowing to filter and organize the Header instances added to it. There are two common use cases for this class: The first use case is in combination with a Connection. As live Header instances are reported by their corresponding event they are aded to the HeaderSetConsolidator instance using addHeader or addHeaders methods. The startTimer method is used to start a background timer that fires a headerSet event every time the given interval has passed. The second use case is in combination with Recorders. In that case no timer has to be started because the data is not received in real time. As recorded HeaderSet instances are played back they are can be handed over to the processHeaderSet method. This method will fire a headerSet event every time the recorded data belong to a different interval. new HeaderSetConsolidator(options) Creates a new instances and optionally initializes its members to the given values. Parameters: Name Type Description options object Properties Name Type Description interval number See HeaderSetConsolidator#interval timeToLive number See HeaderSetConsolidator#timeToLive minTimestamp number See HeaderSetConsolidator#minTimestamp maxTimestamp number See HeaderSetConsolidator#maxTimestamp Source: header-set-consolidator.js Example // --- use case 1: live data --- var connection = createConnection(); // create a HeaderSetConsolidator that fires a headerSet event every minute var hsc = new HeaderSetConsolidator({ interval: 1 * 60 * 1000 }); // add an event handlers to the connection that adds incoming headers to the consolidator var onHeader = function(header) { hsc.addHeader(header); }; connection.on('packet', onHeader); connection.on('datagram', onHeader); connection.on('telegram', onHeader); // add an event handler to the consolidator hsc.on('headerSet', function(headerSet) { console.log(headerSet); }); // start the timer hsc.startTimer(); // --- use case 2: recorded data --- var stream = getRecordedDataStream(); var converter = new VBusRecordingConverter(); // create a HeaderSetConsolidator that sieves incoming headers var hsc = new HeaderSetConsolidator({ interval: 60 * 60 * 1000 }); // add an event handler to the converter that processes incoming header sets in the consolidator converter.on('headerSet', function(headerSet) { hsc.processHeaderSet(headerSet); }); // add an event handler to the consolidator hsc.on('headerSet', function(headerSet) { console.log(headerSet); }); // start the conversion stream.pipe(converter); Extends HeaderSet Members headerList :Array.&lt;Header&gt; Array of Header instances in this set. Type: Array.&lt;Header&gt; Inherited From: HeaderSet#headerList Source: header-set.js interval :number The interval in which the headerSet event should be emitted. Type: number Source: header-set-consolidator.js maxTimestamp :Date HeaderSet instances from a time after this Date are ignored. Type: Date Source: header-set-consolidator.js minTimestamp :Date HeaderSet instances from a time before this Date are ignored. Type: Date Source: header-set-consolidator.js timestamp :Date Timestamp of the youngest Header instance added to this set. Type: Date Inherited From: HeaderSet#timestamp Overrides: HeaderSet#timestamp Source: header-set.js timeToLive :number Header instances that are older then this duration are removed from the set. Type: number Source: header-set-consolidator.js Methods addHeader(header) Adds a Header instance to this set, replacing a previously added Header of same kind. Parameters: Name Type Description header Header The Header instance to add to this set. Inherited From: HeaderSet#addHeader Source: header-set.js addHeaders(headers) Adds a list of Header instances to this set, replacing previously added Headers of same kind. Parameters: Name Type Description headers Array.&lt;Header&gt; The list of Header instances to add. Inherited From: HeaderSet#addHeaders Source: header-set.js containsHeader() Returns true if a Header of the same kind is already added to the HeaderSet. Inherited From: HeaderSet#containsHeader Source: header-set.js Returns: true if a Header of the same kind is already in the HeaderSet, false otherwise. Type boolean getHeaderCount() Returns the count of Header instances currently stored in this set. Inherited From: HeaderSet#getHeaderCount Source: header-set.js Returns: Number of Header instances in this set. Type number getHeaders() Returns an unsorted list of Header instances stored in this set. Inherited From: HeaderSet#getHeaders Source: header-set.js Returns: List of headers stored in this set. Type Array.&lt;Header&gt; getId() Returns an ID composed of the IDs of all headers stored in this set. Inherited From: HeaderSet#getId Source: header-set.js Returns: ID of this HeaderSet. Type string getIdHash() Returns an ID hash for this HeaderSet instance. Inherited From: HeaderSet#getIdHash Source: header-set.js Returns: ID hash for this HeaderSet Type string getSortedHeaders() Returns a sorted list of Header instances stored in this set. Inherited From: HeaderSet#getSortedHeaders Source: header-set.js Returns: List of headers stored in this set. Type Array.&lt;Header&gt; processHeaderSet(headerSet) Process the given HeaderSet instance. The Header instances in it are added to the HeaderSetConsolidator. Parameters: Name Type Description headerSet HeaderSet The HeaderSet instance to process. Source: header-set-consolidator.js removeAllHeaders() Removes all Header instances from this set. Inherited From: HeaderSet#removeAllHeaders Source: header-set.js removeHeadersOlderThan(timestamp) Removes all Header instances from this set which are older than the given timestamp. Parameters: Name Type Description timestamp number | Date Timestamp to compare Header instances against. Inherited From: HeaderSet#removeHeadersOlderThan Source: header-set.js startTimer() Starts a timer that processes live HeaderSets automatically. Source: header-set-consolidator.js stopTimer() Stops the timer that was started by startTimer. Source: header-set-consolidator.js Events addHeader This event is fired whenever a Header instance is added to this set. Type: Header Inherited From: HeaderSet#event:addHeader Source: header-set.js removeHeader This event is fired whenever a Header is removed from this set. Type: Header Inherited From: HeaderSet#event:removeHeader Source: header-set.js × Search results Close "},"I18N.html":{"id":"I18N.html","title":"Class: I18N","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: I18N I18N new I18N( [language]) Creates a new I18N instance for the given language code. Parameters: Name Type Argument Default Description language string &lt;optional&gt; 'en' Language code (ISO 639-1) Source: i18n.js Methods moment(args) Wrapper for a moment.js date object that is setup to use this instance's language code. Parameters: Name Type Argument Description args mixed &lt;repeatable&gt; Arguments to be passed to moment() function Source: i18n.js See: http://momentjs.com/docs/ Returns: Result of calling the moment() function Type mixed momentUtc(args) Wrapper for a moment.js UTC date object that is setup to use this instance's language code. Parameters: Name Type Argument Description args mixed &lt;repeatable&gt; Arguments to be passed to moment.utc() function Source: i18n.js See: http://momentjs.com/docs/ Returns: Result of calling the moment.utc() function Type mixed numeral(args) Wrapper for a numeral.js number object that is setup to use this instance's language code. Parameters: Name Type Argument Description args mixed &lt;repeatable&gt; Arguments to be passes to numeral() function Source: i18n.js See: http://numeraljs.com/ Returns: Result of calling the numeral() function Type mixes sprintf(fmt, args) Formats a string using a printf(3) compatible format string and variadic arguments (comparable to sprintf(3)) and returns it. Parameters: Name Type Argument Description fmt string Format string args mixed &lt;repeatable&gt; Arguments to format Source: i18n.js See: http://linux.die.net/man/3/sprintf http://www.diveintojavascript.com/projects/javascript-sprintf Returns: Formatted string Type string Example // outputs: VBus #3: DeltaSol MX console.log(i18n.sprintf('VBus #%d: %s', 3, 'DeltaSol MX')); // outputs: DeltaSol MX console.log(i18n.sprintf('%2$s', 3, 'DeltaSol MX')); t(key, args) Get a translation for the given key. If more than one argument is given, the translation is then used as a format string for the I18N#sprintf method. Parameters: Name Type Argument Description key string Key for the translation args mixed &lt;repeatable&gt; Arguments to format Source: i18n.js Returns: Formatted string Type string Example var i18n = new I18N('de'); // outputs: Unbekanntes Gerät (0x%1$04X) console.log(i18n.t('specification.unknownDevice')); // outputs: Unbekanntes Gerät (0x7E11) console.log(i18n.t('specification.unknownDevice', 0x7e11)); vsprintf(fmt, argv) Formats a string using a printf(3) compatible format string and a arguments array (comparable to vsprintf(3)) and returns it. Parameters: Name Type Description fmt string Format string argv Array Arguments to format Source: i18n.js Returns: Formatted string Type string Example // outputs: VBus #3: DeltaSol MX console.log(i18n.vsprintf('VBus #%d: %s', [ 3, 'DeltaSol MX' ])); // outputs: DeltaSol MX console.log(i18n.vsprintf('%2$s', [ 3, 'DeltaSol MX' ])); × Search results Close "},"Packet.html":{"id":"Packet.html","title":"Class: Packet","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Packet Packet The Packet sub-class provides access to all properties and methods applicable for VBus version 1 packets. In addition to the packet header it may contain up to 508 bytes of payload data. The structure of the payload depends on the combination of destination and source addresses as well as the command of the packet. The different payloads are described in further detail in Chapter H of the VBus Protocol Specification and can be decoded using a Specification instance. new Packet(options) Creates a new Packet instance and optionally initializes its members with the given values. Parameters: Name Type Description options object Initialization values for this instance's members Properties Name Type Description command number Packet#command frameCount number Packet#frameCount frameData Buffer Packet#frameData Source: packet.js See: Header#constructor Specification Extends Header Members channel :number VBus channel of this header Type: number Inherited From: Header#channel Default Value: 0 Source: header.js command :number The command field of this VBus packet. See the VBus Protocol specification for details. Type: number Source: packet.js destinationAddress :number VBus address of this header's destination Type: number Inherited From: Header#destinationAddress Default Value: 0 Source: header.js frameCount :number The number of frames of this VBus packet. Each frame can hold four bytes of payload. Type: number Source: packet.js frameData The buffer containing the frame data of this VBus packet. Source: packet.js sourceAddress :number VBus address of this header's source Type: number Inherited From: Header#sourceAddress Source: header.js timestamp :Date Timestamp of this header Type: Date Inherited From: Header#timestamp Default Value: now Source: header.js Methods compareTo(that) Compares this Header instance to another one. Sub-classes can extend the comparison to include specific information. Parameters: Name Type Description that Header Another Header instance to compare to. Inherited From: Header#compareTo Overrides: Header#compareTo Source: header.js Returns: Returns a number less than 0 if this &lt; that greater than 0 if this &gt; that equal to to if this == that Type number getId() Returns a string identifier describing this Header instance. It contains at least: channel destination address source address protocol version Sub-classes can extend that information. The structure of this identifier is implementation specific, do not rely on it! Inherited From: Header#getId Overrides: Header#getId Source: header.js Returns: Identifier Type string getInfo() Returns an info number about this Header instance. It can be used for sorting purposes (to distinguish Header objects that would otherwise compare as equal). Inherited From: Header#getInfo Source: header.js Returns: Info value Type number &lt;abstract&gt; getProtocolVersion() Returns the protocol version of this Header instance as a 8-bit number. The high nibble is used for the major version, the low nibble for the minor version. For example: a header with protocol version 2.0 would return 0x20. Must be implemented by sub-class. Inherited From: Header#getProtocolVersion Overrides: Header#getProtocolVersion Source: header.js Returns: Protocol version Type number &lt;abstract&gt; toLiveBuffer( [buffer] [, start] [, end]) Creates a representation of this Header instance that can be transmitted over a Connection. If no buffer is given as an arguments, it creates a new one that is big enough to hold the representation. Must be implemented by sub-class. Parameters: Name Type Argument Description buffer Buffer &lt;optional&gt; Buffer object to store data in start number &lt;optional&gt; Start index in the buffer end number &lt;optional&gt; End index in the buffer Inherited From: Header#toLiveBuffer Overrides: Header#toLiveBuffer Source: header.js Returns: Buffer object containing the data Type Buffer × Search results Close "},"Recorder.html":{"id":"Recorder.html","title":"Class: Recorder","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Recorder Recorder A Recorder provides access to HeaderSet stores (e.g. dataloggers) by allowing to either playback the HeaderSets in the store, record HeaderSets to the store or synchronize two Recorders. The playback and record operation both use the VBusRecordingConverter to serialize the HeaderSets to and from Node.js streams. The synchronization operation builds on top of this two operations and is able to find unsynced HeaderSets in the source Recorder. Thoses unsynced HeaderSets are then played back from the source Recorder and recorded in the destination Recorder. The storage mechanism and format of the Recorder sub-classes is implementation-specific to this class. new Recorder(options) Creates a new Recorder instance and optionally initializes its members with the given values. Parameters: Name Type Description options object Initialization values for this instance's members Properties Name Type Description id string Recorder#id minTimestamp Date Recorder#minTimestamp maxTimestamp Date Recorder#maxTimestamp interval number Recorder#interval Source: recorder.js Members id :string Identifier for this recorder instance. It may be used to reference recorders, for example in sync data storage. Type: string Source: recorder.js interval :number Interval to be used as a default during playback and synchronization. Type: number Default Value: 0 Source: recorder.js maxTimestamp :Date Maximum timestamp to use as a default during playback and synchronization. Type: Date Default Value: '2038-01-01T00:00:00.000Z' Source: recorder.js minTimestamp :Date Minimum timestamp to use as a default during playback and synchronization. Type: Date Default Value: '2001-01-01T00:00:00.000Z' Source: recorder.js Methods &lt;static&gt; performRangeSetOperation(rangesA, rangesB, interval, operation) Performs operations on two sets of timestamp ranges. Timestamp ranges are objects with two properties: minTimestamp and maxTimestamp. The operations correspond to the operations in mathematic's set theory. Currently supported are union, difference and intersection. See http://en.wikipedia.org/wiki/Set_theory for details. Parameters: Name Type Description rangesA Array Set A containing timestamp ranges rangesB Array Set B containing timestamp ranges interval number Interval to allow between adjacent timestamp ranges operation string Operation to perform, can be 'union', 'difference' or 'intersection' Source: recorder.js Returns: Set containing timestamp ranges after the operation Type Array _playbackSyncJob(stream, syncJob) Plays back the requested synchronization job, piping the resulting data into the provided stream. Returns a Promise that resolves to the played back ranges. Parameters: Name Type Description stream Stream The stream (in object mode) to pipe data into syncJob RecorderSyncJob The synchronization job to perform. Source: recorder.js Returns: Promise resolving with a list of ranges that were synchronized. Type Promise _recordSyncJob(recorder, syncJob) Starts a playback of the provided recorder, recording its data and returning a Promise that resolves to the recorded ranges. Parameters: Name Type Description recorder Recorder The recorder to use for playback syncJob RecorderSyncJob The synchronization job to perform. Source: recorder.js Returns: Promise resolving with a list of ranges that were synchronized. Type Promise playback(stream, options) Plays back a given range of HeaderSets. The stream must be in object mode. Parameters: Name Type Description stream Writable A writable stream options object Options to select and filter HeaderSets Properties Name Type Argument Default Description minTimestamp Date &lt;optional&gt; Recorder#minTimestamp maxTimestamp Date &lt;optional&gt; Recorder#maxTimestamp interval number &lt;optional&gt; Recorder#interval end boolean &lt;optional&gt; true Whether the stream should be end()ed when the playback is complete Source: recorder.js record(stream, options) Records a given range of HeaderSet instances. The stream must be in object mode. Parameters: Name Type Description stream Readable A readable stream in object mode. options object Options to select and filter HeaderSet instances. Properties Name Type Argument Description minTimestamp Date &lt;optional&gt; See Recorder#minTimestamp maxTimestamp Date &lt;optional&gt; See Recorder#maxTimestamp interval number &lt;optional&gt; See Recorder#interval Source: recorder.js Returns: A Promise that resolves to the recorded ranges. Type Promise synchronizeTo(recorder, options) Synchronize this Recorder's HeaderSets to another Recorder. Parameters: Name Type Description recorder Recorder Destination Recorder options object Options to select and filter HeaderSets Properties Name Type Argument Description minTimestamp Date &lt;optional&gt; Recorder#minTimestamp maxTimestamp Date &lt;optional&gt; Recorder#maxTimestamp interval number &lt;optional&gt; Recorder#interval Source: recorder.js Returns: Promise resolving with a list of ranges that were synchronized. Type Promise × Search results Close "},"SerialConnection.html":{"id":"SerialConnection.html","title":"Class: SerialConnection","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: SerialConnection SerialConnection The SerialConnection class provides asscess to a VBus live data stream using a serial port. new SerialConnection(options) Creates a new SerialConnection instance and optionally initialized its member with the given values. Parameters: Name Type Description options object Initialization values Properties Name Type Description path string See SerialConnection#path Source: serial-connection.js Extends Connection Members channel :number The VBus channel that this connection is established to. All Header instances created by this Connection instance will be assigned this VBus channel. Type: number Inherited From: Connection#channel Source: connection.js connectionState :string The current connection state. Type: string Inherited From: Connection#connectionState Source: connection.js dataSource :DataSource Reference to this instance's DataSource. Type: DataSource Inherited From: Connection#dataSource Source: connection.js path :string The path to the serial port. Type: string Source: serial-connection.js reconnectTimeout :number Timeout in milliseconds to way between reconnection retries. Type: number Source: serial-connection.js reconnectTimeoutIncr :number Value to increment timeout after every unsuccessful reconnection retry. Type: number Source: serial-connection.js reconnectTimeoutMax :number Maximum timeout value between unsuccessful reconnection retry. Type: number Source: serial-connection.js rxBuffer :Buffer The internal receive buffer of this conneciton. Type: Buffer Inherited From: Connection#rxBuffer Source: connection.js selfAddress :number The VBus address used for sending information over this connection. Type: number Inherited From: Connection#selfAddress Source: connection.js Methods beginBulkValueTransaction(address, txTimeout, options) Sends a Datagram to begin a bulk valke transaction. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to begin the transaction on. txTimeout number The number of seconds of inactivity after which the transaction is rolled back. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#beginBulkValueTransaction Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise commitBulkValueTransaction(address, options) Sends a Datagram to commit a bulk valke transaction. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to commit the transaction on. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#commitBulkValueTransaction Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise &lt;abstract&gt; connect() Establish underlying connection and start streaming data to the writable side of this Connection instance's stream. Inherited From: Connection#connect Overrides: Connection#connect Source: connection.js Returns: A promise that resolves once the connection has been established. Type Promise createConnectedPromise() Creates a promise that resolves when this Connection instance is connected and rejects if it is disconnected. If it is neither connected nor disconnected the promise will stay pending until one of the states is entered. Inherited From: Connection#createConnectedPromise Source: connection.js Returns: Type Promise &lt;abstract&gt; disconnect() Diconnect this instance. Inherited From: Connection#disconnect Overrides: Connection#disconnect Source: connection.js getCaps1(address, options) Sends a Datagram to lookup the controller's capabilities (part 1). Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to get the capabilities from. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#getCaps1 Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise getValueById(address, valueId, options) Sends a Datagram to get a value from a device. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to get the value from valueId number The ID of the value to read from the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to get the value. Inherited From: Connection#getValueById Source: connection.js Returns: A promise that resolves to the received Datagram or null on timeout. Type Promise getValueIdByIdHash(address, valueIdHash, options) Sends a Datagram to lookup a value ID in a device. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to lookup the value in. valueIdHash number The ID hash of the value to lookup in the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#getValueIdByIdHash Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise getValueIdHashById(address, valueId, options) Sends a Datagram to lookup a value ID hash in a device. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to lookup the value in. valueId number The ID of the value to lookup in the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#getValueIdHashById Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise releaseBus(address, options) Sends a VBus bus release datagram (Command 0x0600). Returns a Promise that resolves with the first VBus packet received after the release or null on timeout. Parameters: Name Type Description address number The VBus address of the master device to give the bus ownership back to. options object Properties Name Type Default Description tries number 2 Number of tries to give the bus ownership back. timeout number 1500 Time in milliseconds to wait between tries. Inherited From: Connection#releaseBus Source: connection.js rollbackBulkValueTransaction(address, options) Sends a Datagram to rollback a bulk valke transaction. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to perform the rollback on. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#rollbackBulkValueTransaction Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise send(data) Send raw data over this Connection instance. Parameters: Name Type Description data Header | Buffer The Header or Buffer instance to be sent. Inherited From: Connection#send Source: connection.js setBulkValueById(address, valueId, value, options) Sends a Datagram to set a value during a bulk value transaction. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to set the value on. valueId number The ID of the value to write to the device. value number The value to write to the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#setBulkValueById Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise setValueById(address, valueId, value, options) Sends a Datagram to set a value in a device. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to set the value in valueId number The ID of the value to write to the device. value number The value to write to the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to get the value. Inherited From: Connection#setValueById Source: connection.js Returns: A promise that resolves to the received Datagram or null on timeout. Type Promise transceive(txData, options) Sends and / or receives a VBus data. Parameters: Name Type Description txData Header | Buffer The Header or Buffer instance to be sent. options object Properties Name Type Argument Description timeout number Timeout in milliseconds after which the txData will be sent again timeoutIncr number After each timeout retransmission the timeout value for the next try is increment by this value. tries number After this number of tries the returned Promise will resolve with value null. filterPacket function &lt;nullable&gt; Will be called when a Packet has been received with the Packet and a callback as arguments. filterDatagram function &lt;nullable&gt; Will be called when a Datagram has been received with the Datagram and a callback as arguments. Inherited From: Connection#transceive Source: connection.js Returns: A Promise that either resolves to the VBus data selected by one of the filter callbacks or null on timeout. Type Promise waitForFreeBus(timeout) Waits for a VBus bus offering datagram (Command 0x0500). Returns a Promise that resolves with the Datagram or null if the method timed out. Parameters: Name Type Default Description timeout number 20000 Timeout in milliseconds Inherited From: Connection#waitForFreeBus Source: connection.js Returns: A Promise that resolves to the bus offering Datagram or null on timeout. Type Promise × Search results Close "},"SerialDataSource.html":{"id":"SerialDataSource.html","title":"Class: SerialDataSource","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: SerialDataSource SerialDataSource new SerialDataSource() Creates a new SerialDataSource. Source: serial-data-source.js Extends DataSource Members path The path to the serial port. Source: serial-data-source.js × Search results Close "},"Specification.html":{"id":"Specification.html","title":"Class: Specification","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Specification Specification new Specification(options) Creates a new Specification instance and optionally initializes its members with the given values. Parameters: Name Type Description options object Initialization values for this instance's members Properties Name Type Description language string Specification#language specificationData string Specification#specificationData Source: specification.js Members i18n :I18N I18N instance Type: I18N Source: specification.js language :string Language code (ISO 639-1) Type: string Source: specification.js specificationData :object Custom specification data to be mixed-in to built-in specification. Type: object Source: specification.js Methods convertRawValue(rawValue, sourceUnit, targetUnit) Converts a raw number value from one unit to another. The units must be in the same unit family. Parameters: Name Type Description rawValue number Raw number value to convert from sourceUnit Unit Unit to convert from targetUnit Unit Unit to convert to Source: specification.js Returns: Result containing a rawValue property with the conversion result and a unit property with the associated unit. Type object formatTextValueFromRawValue(packetField, rawValue [, unit]) Formats a raw value into its textual representation. Parameters: Name Type Argument Description packetField PacketFieldSpecification PacketFieldSpecification object rawValue number Raw value unit string | UnitSpecification | null &lt;optional&gt; Unit to format to Source: specification.js Returns: Textual representation of the raw value Type string Example &gt; var packetFieldSpec = spec.getPacketFieldSpecification('01_0010_7721_10_0100_000_2_0'); undefined &gt; var rawValue = 888.8000000000001; undefined &gt; console.log(spec.formatTextValueFromRawValue(packetFieldSpec, rawValue, 'DegreesCelsius')); 888.8 °C undefined &gt; getBlockTypeFieldsForSections(sections) Gets an array of PacketField objects for the provided BlockTypeSection objects. Parameters: Name Type Description sections Array.&lt;BlockTypeSection&gt; Array of BlockTypeSection objects. Source: specification.js Returns: Array of PacketField objects Type Array.&lt;PacketField&gt; getBlockTypePacketSpecificationsForSections(sections) Gets the PacketSpecification objects matching the given BlockTypeSection objects. Parameters: Name Type Description sections Array.&lt;BlockTypeSection&gt; Array of BlockTypeSection objects Source: specification.js Returns: Array of PacketSpecificationObjects Type Array.&lt;PacketSpecification&gt; getBlockTypeSectionsForHeaders(headers) Gets an array of BlockType sections from a collection of headers. Parameters: Name Type Description headers Array.&lt;Header&gt; Array of Header objects Source: specification.js Returns: Array of BlockTypeSection objects Type Array.&lt;BlockTypeSection&gt; getDeviceSpecification(header, which) Gets the DeviceSpecification object matching the given header and direction. Parameters: Name Type Description header Header Header instance which string Either 'source' or 'destination' Source: specification.js Returns: DeviceSpecification object Type DeviceSpecification getDeviceSpecification(selfAddress, peerAddress [, channel]) Gets the DeviceSpecification object matching the given arguments. Parameters: Name Type Argument Default Description selfAddress number VBus address of the device itself peerAddress number VBus address of the device's peer channel number &lt;optional&gt; 0 VBus channel of the device Source: specification.js Returns: DeviceSpecification object Type DeviceSpecification Example &gt; console.log(spec.getDeviceSpecification(0x7E11, 0x0000, 1)); { name: 'DeltaSol MX [Regler]', deviceId: '01_7E11_0000', channel: 1, selfAddress: 32273, peerAddress: 0, fullName: 'VBus #1: DeltaSol MX [Regler]' } undefined &gt; getPacketFieldsForHeaders(headers) Gets an array of PacketField objects for the provided Packet objects. Parameters: Name Type Description headers Array.&lt;Header&gt; Array of Header objects Source: specification.js Returns: Array of PacketField objects Type Array.&lt;PacketField&gt; getPacketFieldSpecification(packetFieldId) Gets the PacketFieldSpecification object matching the given arguments. Parameters: Name Type Description packetFieldId string Packet field identifier Source: specification.js Returns: PacketFieldSpecification object Type PacketFieldSpecification Example &gt; console.log(spec.getPacketFieldSpecification('01_0010_7E21_10_0100_000_2_0')); { fieldId: '000_2_0', name: { ref: 'Flow set temperature', en: 'Flow set temperature', de: 'Vorlauf-Soll-Temperatur', fr: 'Température nominale départ' }, type: { typeId: 'Number_0_1_DegreesCelsius', rootTypeId: 'Number', precision: 1, unit: { unitId: 'DegreesCelsius', unitCode: 'DegreesCelsius', unitText: ' °C' } }, getRawValue: [Function] } undefined &gt; getPacketFieldSpecification(packetSpec, fieldId) Gets the PacketFieldSpecification object matching the given arguments. Parameters: Name Type Description packetSpec PacketSpecification PacketSpecification object fieldId string Field identifier Source: specification.js Returns: PacketFieldSpecification object Type PacketFieldSpecification Example &gt; var packetSpec = spec.getPacketSpecification('01_0010_7E21_10_0100'); undefined &gt; console.log(spec.getPacketFieldSpecification(packetSpec, '000_2_0')); { fieldId: '000_2_0', name: { ref: 'Flow set temperature', en: 'Flow set temperature', de: 'Vorlauf-Soll-Temperatur', fr: 'Température nominale départ' }, type: { typeId: 'Number_0_1_DegreesCelsius', rootTypeId: 'Number', precision: 1, unit: { unitId: 'DegreesCelsius', unitCode: 'DegreesCelsius', unitText: ' °C' } }, getRawValue: [Function] } undefined &gt; getPacketSpecification(packet) Gets the PacketSpecification object matching the given packet. Parameters: Name Type Description packet Packet VBus packet Source: specification.js Returns: PacketSpecification object Type PacketSpecification getPacketSpecification(packetSpecId) Gets the PacketSpecification object matching the given arguments. Parameters: Name Type Description packetSpecId string PacketSpecification identifier Source: specification.js Returns: PacketSpecification object Type PacketSpecification Example &gt; console.log(spec.getPacketSpecification('01_0010_7E21_10_0100')); { packetId: '01_0010_7E21_10_0100', packetFields: [ { fieldId: '000_2_0', name: [Object], type: [Object], getRawValue: [Function] }, { fieldId: '002_1_0', name: [Object], type: [Object], getRawValue: [Function] } ], channel: 1, destinationAddress: 16, sourceAddress: 32289, protocolVersion: 16, command: 256, info: 0, destinationDevice: { name: 'DFA', deviceId: '01_0010_7E21', channel: 1, selfAddress: 16, peerAddress: 32289, fullName: 'VBus #1: DFA' }, sourceDevice: { name: 'DeltaSol MX [Heizkreis #1]', deviceId: '01_7E21_0010', channel: 1, selfAddress: 32289, peerAddress: 16, fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' }, fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' } undefined &gt; getPacketSpecification(channel, destinationAddress, sourceAddress, command) Gets the PacketSpecification object matching the given arguments. Parameters: Name Type Description channel number VBus channel destinationAddress number VBus address of destination device sourceAddress number VBus address of source device command number VBus command Source: specification.js Returns: PacketSpecification object Type PacketSpecification Example &gt; console.log(spec.getPacketSpecification(1, 0x0010, 0x7E21, 0x0100)); { packetId: '01_0010_7E21_10_0100', packetFields: [ { fieldId: '000_2_0', name: [Object], type: [Object], getRawValue: [Function] }, { fieldId: '002_1_0', name: [Object], type: [Object], getRawValue: [Function] } ], channel: 1, destinationAddress: 16, sourceAddress: 32289, protocolVersion: 16, command: 256, info: 0, destinationDevice: { name: 'DFA', deviceId: '01_0010_7E21', channel: 1, selfAddress: 16, peerAddress: 32289, fullName: 'VBus #1: DFA' }, sourceDevice: { name: 'DeltaSol MX [Heizkreis #1]', deviceId: '01_7E21_0010', channel: 1, selfAddress: 32289, peerAddress: 16, fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' }, fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' } undefined &gt; getRawValue(packetField, buffer [, start] [, end]) Gets the raw value of a packet field from a buffer. Parameters: Name Type Argument Default Description packetField PacketFieldSpecification PacketFieldSpecification object buffer Buffer Buffer object start number &lt;optional&gt; 0 Start index in the buffer end number &lt;optional&gt; buffer.length End index in the buffer Source: specification.js Returns: Raw value Type number Example &gt; var packetFieldSpec = spec.getPacketFieldSpecification('01_0010_7721_10_0100_000_2_0'); undefined &gt; var buffer = Buffer.from('b822', 'hex'); undefined &gt; console.log(spec.getRawValue(packetFieldSpec, buffer)); 888.8000000000001 undefined &gt; getTypeById(id) Gets the TypeSpecification object matching the given identifier. Parameters: Name Type Description id string Type identifier Source: specification.js Returns: Type object Type TypeSpecification Example &gt; console.log(spec.getTypeById('Number_0_1_DegreesCelsius')); { typeId: 'Number_0_1_DegreesCelsius', rootTypeId: 'Number', precision: 1, unit: { unitId: 'DegreesCelsius', unitCode: 'DegreesCelsius', unitText: ' °C' } } undefined &gt; getUnitById(id) Gets the UnitSpecification object matching the given identifier. Parameters: Name Type Description id string Unit identifier Source: specification.js Returns: Unit object Type UnitSpecification Example &gt; console.log(spec.getUnitById('DegreesCelsius')); { unitId: 'DegreesCelsius', unitCode: 'DegreesCelsius', unitText: ' °C' } undefined &gt; × Search results Close "},"TcpConnection.html":{"id":"TcpConnection.html","title":"Class: TcpConnection","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: TcpConnection TcpConnection The TcpConnection class is primarily designed to provide access to VBus live data using the VBus-over-TCP specification. That includes the VBus/LAN adapter, the Dataloggers (DL2 and DL3) and VBus.net. In addition to that it can be used to connect to a raw VBus data stream using TCP (for example provided by a serial-to-LAN gateway). new TcpConnection(options) Creates a new TcpConnection instance and optionally initializes its members to the given values. Parameters: Name Type Description options object Initialization values Properties Name Type Description host string See TcpConnection#host port number See TcpConnection#port viaTag string See TcpConnection#viaTag password string See TcpConnection#password rawVBusDataOnly boolean See TcpConnection#rawVBusDataOnly Source: tcp-connection.js Extends Connection Members channel :string|number Channel number to connect to. Type: string | number Overrides: Connection#channel Source: tcp-connection.js connectionState :string The current connection state. Type: string Inherited From: Connection#connectionState Source: connection.js dataSource :DataSource Reference to this instance's DataSource. Type: DataSource Inherited From: Connection#dataSource Source: connection.js host :string Host name or IP address of the connection target. Type: string Source: tcp-connection.js password :string Password needed to connect to target. Type: string Source: tcp-connection.js port :number Port number of the connection target. Type: number Source: tcp-connection.js rawVBusDataOnly :boolean Indicates that connection does not need to perform login handshake. Useful for serial-to-LAN converters. Type: boolean Source: tcp-connection.js reconnectTimeout :number Timeout in milliseconds to way between reconnection retries. Type: number Source: tcp-connection.js reconnectTimeoutIncr :number Value to increment timeout after every unsuccessful reconnection retry. Type: number Source: tcp-connection.js reconnectTimeoutMax :number Maximum timeout value between unsuccessful reconnection retry. Type: number Source: tcp-connection.js rxBuffer :Buffer The internal receive buffer of this conneciton. Type: Buffer Inherited From: Connection#rxBuffer Source: connection.js selfAddress :number The VBus address used for sending information over this connection. Type: number Inherited From: Connection#selfAddress Source: connection.js viaTag :string Via tag if connection target is accessed using the VBus.net service. Type: string Source: tcp-connection.js Methods beginBulkValueTransaction(address, txTimeout, options) Sends a Datagram to begin a bulk valke transaction. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to begin the transaction on. txTimeout number The number of seconds of inactivity after which the transaction is rolled back. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#beginBulkValueTransaction Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise commitBulkValueTransaction(address, options) Sends a Datagram to commit a bulk valke transaction. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to commit the transaction on. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#commitBulkValueTransaction Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise &lt;abstract&gt; connect() Establish underlying connection and start streaming data to the writable side of this Connection instance's stream. Inherited From: Connection#connect Overrides: Connection#connect Source: connection.js Returns: A promise that resolves once the connection has been established. Type Promise createConnectedPromise() Creates a promise that resolves when this Connection instance is connected and rejects if it is disconnected. If it is neither connected nor disconnected the promise will stay pending until one of the states is entered. Inherited From: Connection#createConnectedPromise Source: connection.js Returns: Type Promise &lt;abstract&gt; disconnect() Diconnect this instance. Inherited From: Connection#disconnect Overrides: Connection#disconnect Source: connection.js getCaps1(address, options) Sends a Datagram to lookup the controller's capabilities (part 1). Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to get the capabilities from. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#getCaps1 Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise getValueById(address, valueId, options) Sends a Datagram to get a value from a device. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to get the value from valueId number The ID of the value to read from the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to get the value. Inherited From: Connection#getValueById Source: connection.js Returns: A promise that resolves to the received Datagram or null on timeout. Type Promise getValueIdByIdHash(address, valueIdHash, options) Sends a Datagram to lookup a value ID in a device. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to lookup the value in. valueIdHash number The ID hash of the value to lookup in the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#getValueIdByIdHash Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise getValueIdHashById(address, valueId, options) Sends a Datagram to lookup a value ID hash in a device. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to lookup the value in. valueId number The ID of the value to lookup in the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#getValueIdHashById Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise releaseBus(address, options) Sends a VBus bus release datagram (Command 0x0600). Returns a Promise that resolves with the first VBus packet received after the release or null on timeout. Parameters: Name Type Description address number The VBus address of the master device to give the bus ownership back to. options object Properties Name Type Default Description tries number 2 Number of tries to give the bus ownership back. timeout number 1500 Time in milliseconds to wait between tries. Inherited From: Connection#releaseBus Source: connection.js rollbackBulkValueTransaction(address, options) Sends a Datagram to rollback a bulk valke transaction. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to perform the rollback on. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#rollbackBulkValueTransaction Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise send(data) Send raw data over this Connection instance. Parameters: Name Type Description data Header | Buffer The Header or Buffer instance to be sent. Inherited From: Connection#send Source: connection.js setBulkValueById(address, valueId, value, options) Sends a Datagram to set a value during a bulk value transaction. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to set the value on. valueId number The ID of the value to write to the device. value number The value to write to the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#setBulkValueById Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise setValueById(address, valueId, value, options) Sends a Datagram to set a value in a device. Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to set the value in valueId number The ID of the value to write to the device. value number The value to write to the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to get the value. Inherited From: Connection#setValueById Source: connection.js Returns: A promise that resolves to the received Datagram or null on timeout. Type Promise transceive(txData, options) Sends and / or receives a VBus data. Parameters: Name Type Description txData Header | Buffer The Header or Buffer instance to be sent. options object Properties Name Type Argument Description timeout number Timeout in milliseconds after which the txData will be sent again timeoutIncr number After each timeout retransmission the timeout value for the next try is increment by this value. tries number After this number of tries the returned Promise will resolve with value null. filterPacket function &lt;nullable&gt; Will be called when a Packet has been received with the Packet and a callback as arguments. filterDatagram function &lt;nullable&gt; Will be called when a Datagram has been received with the Datagram and a callback as arguments. Inherited From: Connection#transceive Source: connection.js Returns: A Promise that either resolves to the VBus data selected by one of the filter callbacks or null on timeout. Type Promise waitForFreeBus(timeout) Waits for a VBus bus offering datagram (Command 0x0500). Returns a Promise that resolves with the Datagram or null if the method timed out. Parameters: Name Type Default Description timeout number 20000 Timeout in milliseconds Inherited From: Connection#waitForFreeBus Source: connection.js Returns: A Promise that resolves to the bus offering Datagram or null on timeout. Type Promise × Search results Close "},"TcpConnectionEndpoint.html":{"id":"TcpConnectionEndpoint.html","title":"Class: TcpConnectionEndpoint","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: TcpConnectionEndpoint TcpConnectionEndpoint The TcpConnectionEndpoint can act as the remote side for a TcpConnection. It supports all the commands that a DL3 connected via VBus.net would provide as well. A connection event is emitted whenever an incoming connection passes the VBus-over-TCP handshake. new TcpConnectionEndpoint(options) Creates a new instance and optionally initializes its members. Parameters: Name Type Description options object The initialization values for this instance. Properties Name Type Description port number See TcpConnectionEndpoint#port channels number See TcpConnectionEndpoint#channels Source: tcp-connection-endpoint.js Extends EventEmitter Members channels :Array.&lt;string&gt; The list of channels to return if the CHANNELLIST command is received. Type: Array.&lt;string&gt; Source: tcp-connection-endpoint.js port :number The port number to listen on for incoming connections. Type: number Source: tcp-connection-endpoint.js server :net.Server The Server instance used for listening for incoming connections. Type: net.Server Source: tcp-connection-endpoint.js Methods start() Starts the server to listen for incoming connections. Source: tcp-connection-endpoint.js Returns: A promise that resolves when the server is started. Type Promise × Search results Close "},"TcpDataSource.html":{"id":"TcpDataSource.html","title":"Class: TcpDataSource","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: TcpDataSource TcpDataSource new TcpDataSource() Creates a new TcpDataSource instance. Source: tcp-data-source.js Extends DataSource Members host :string The host to connect to. Type: string Source: tcp-data-source.js liveChannel :number The channel to connect to live. Type: number Source: tcp-data-source.js livePassword :string The password to connect live. Type: string Source: tcp-data-source.js port :number The port to connect to. Type: number Source: tcp-data-source.js × Search results Close "},"TcpDataSourceProvider.html":{"id":"TcpDataSourceProvider.html","title":"Class: TcpDataSourceProvider","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: TcpDataSourceProvider TcpDataSourceProvider new TcpDataSourceProvider() Creates a new TcpDataSourceProvider instance. Source: tcp-data-source-provider.js Extends DataSourceProvider Methods &lt;static&gt; discoverDevices() Discovers devices on the local network. Source: tcp-data-source-provider.js Returns: A Promise that resolves to an array of device information objects. Type Promise × Search results Close "},"Telegram.html":{"id":"Telegram.html","title":"Class: Telegram","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Telegram Telegram new Telegram(options) Creates a new Telegram instance. Parameters: Name Type Description options object Initialization options. Source: telegram.js Extends Header Members channel :number VBus channel of this header Type: number Inherited From: Header#channel Default Value: 0 Source: header.js command :number The VBus command of this Telegram instance. Type: number Source: telegram.js destinationAddress :number VBus address of this header's destination Type: number Inherited From: Header#destinationAddress Default Value: 0 Source: header.js sourceAddress :number VBus address of this header's source Type: number Inherited From: Header#sourceAddress Source: header.js timestamp :Date Timestamp of this header Type: Date Inherited From: Header#timestamp Default Value: now Source: header.js Methods compareTo(that) Compares this Header instance to another one. Sub-classes can extend the comparison to include specific information. Parameters: Name Type Description that Header Another Header instance to compare to. Inherited From: Header#compareTo Overrides: Header#compareTo Source: header.js Returns: Returns a number less than 0 if this &lt; that greater than 0 if this &gt; that equal to to if this == that Type number getId() Returns a string identifier describing this Header instance. It contains at least: channel destination address source address protocol version Sub-classes can extend that information. The structure of this identifier is implementation specific, do not rely on it! Inherited From: Header#getId Overrides: Header#getId Source: header.js Returns: Identifier Type string getInfo() Returns an info number about this Header instance. It can be used for sorting purposes (to distinguish Header objects that would otherwise compare as equal). Inherited From: Header#getInfo Source: header.js Returns: Info value Type number &lt;abstract&gt; getProtocolVersion() Returns the protocol version of this Header instance as a 8-bit number. The high nibble is used for the major version, the low nibble for the minor version. For example: a header with protocol version 2.0 would return 0x20. Must be implemented by sub-class. Inherited From: Header#getProtocolVersion Overrides: Header#getProtocolVersion Source: header.js Returns: Protocol version Type number &lt;abstract&gt; toLiveBuffer( [buffer] [, start] [, end]) Creates a representation of this Header instance that can be transmitted over a Connection. If no buffer is given as an arguments, it creates a new one that is big enough to hold the representation. Must be implemented by sub-class. Parameters: Name Type Argument Description buffer Buffer &lt;optional&gt; Buffer object to store data in start number &lt;optional&gt; Start index in the buffer end number &lt;optional&gt; End index in the buffer Inherited From: Header#toLiveBuffer Overrides: Header#toLiveBuffer Source: header.js Returns: Buffer object containing the data Type Buffer × Search results Close "},"TextConverter.html":{"id":"TextConverter.html","title":"Class: TextConverter","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: TextConverter TextConverter The TextConverter class takes header sets, converts them into text representation and then publishes that on the readable stream side of itself. It does not support parsing text content back into header sets (the writable stream side). new TextConverter() Create a new TextConverter instance given the set of options. Source: text-converter.js Extends Converter Members columnSeparator :string Column separator, defaults to tab Type: string Source: text-converter.js dateFormat :string|function Date to string formatting for the first column. Can either be a string to use in moment(...).format() or a function that returns the formatted date string. Type: string | function Source: text-converter.js lastIdList :string List of packet IDs converted last time, enables decision whether a new header line pair must be output. Type: string Source: text-converter.js lineSeparator :string Line separator, defaults to CR+NL Type: string Source: text-converter.js objectMode :boolean Specifies whether the underlying stream operates in object mode. Type: boolean Inherited From: Converter#objectMode Source: converter.js separateDateAndTime :boolean Specifies whether date and time columns should be output separately Type: boolean Source: text-converter.js specification :Specification VBus specification Type: Specification Source: text-converter.js timeFormat :string|function Time to string formatting for the first column. Can either be a string to use in moment(...).format() or a function that returns the formatted time string. Type: string | function Source: text-converter.js Methods convertHeader(header) This method queues a VBus Header model (Packet, Datagram or Telegram) for conversion. Not all Converter sub-classes support this method. Parameters: Name Type Description header Header The Header to queue for conversion. Inherited From: Converter#convertHeader Source: converter.js convertHeaderSet(headerSet) Converts a header set into text representation. Parameters: Name Type Description headerSet HeaderSet Overrides: Converter#convertHeaderSet Source: text-converter.js convertRawData(rawData) This method queues a VBus raw data chunk from conversion. Not all Converter sub-classes support this method. Parameters: Name Type Description rawData RawData The VBus raw data chunk to queue for conversion. Inherited From: Converter#convertRawData Source: converter.js finish() This method signals that no additional VBus Header or HeaderSet models will be converted. It returns a promise that resolves when all data has been consumed. Inherited From: Converter#finish Source: converter.js Returns: A Promise that resolves when all data has been consumed. Type Promise formatDateAndTime(now, format) Format a Date object into a string. Parameters: Name Type Description now Moment The Moment.js timestamp to format. format string | function Date formatter. Can either be a string to use in moment(...).format() or a function that returns the formatted date/time string. Source: text-converter.js Returns: The formatted date/time as a string. Type string reset() Resets the converter, resulting in a ne pair of header lines generated on next header set conversion. Overrides: Converter#reset Source: text-converter.js × Search results Close "},"VBusRecordingConverter.html":{"id":"VBusRecordingConverter.html","title":"Class: VBusRecordingConverter","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: VBusRecordingConverter VBusRecordingConverter This Converter subclass converts Header and HeaderSet instances to and from a binary stream that conforms to the VBus Recording File Format (the binary file format used e.g. to store data on the Datalogger devices). new VBusRecordingConverter() Creates a new VBusRecordingConverter instance. Source: vbus-recording-converter.js Extends Converter Members objectMode :boolean Specifies whether the underlying stream operates in object mode. Type: boolean Inherited From: Converter#objectMode Source: converter.js Methods convertHeader(header) This method queues a VBus Header model (Packet, Datagram or Telegram) for conversion. Not all Converter sub-classes support this method. Parameters: Name Type Description header Header The Header to queue for conversion. Inherited From: Converter#convertHeader Overrides: Converter#convertHeader Source: converter.js convertHeaderSet(headerSet) This method queues a VBus HeaderSet instance for conversion. Not all Converter sub-classes support this method. Parameters: Name Type Description headerSet HeaderSet The HeaderSet to queue for conversion. Inherited From: Converter#convertHeaderSet Overrides: Converter#convertHeaderSet Source: converter.js convertRawData(rawData) This method queues a VBus raw data chunk from conversion. Not all Converter sub-classes support this method. Parameters: Name Type Description rawData RawData The VBus raw data chunk to queue for conversion. Inherited From: Converter#convertRawData Overrides: Converter#convertRawData Source: converter.js finish() This method signals that no additional VBus Header or HeaderSet models will be converted. It returns a promise that resolves when all data has been consumed. Inherited From: Converter#finish Source: converter.js Returns: A Promise that resolves when all data has been consumed. Type Promise reset() This method resets the converter. It should be used e.g. if the converter output switches between files (allows some Converter sub-classes to correctly write a header). Inherited From: Converter#reset Overrides: Converter#reset Source: converter.js × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
