<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"specification.js.html":{"id":"specification.js.html","title":"Source: specification.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: specification.js /*! resol-vbus | Copyright (c) 2013-2015, Daniel Wippermann | MIT license */ 'use strict'; var crypto = require('crypto'); var _ = require('lodash'); var sprintf = require('sprintf').sprintf; var extend = require('./extend'); var I18N = require('./i18n'); var utils = require('./utils'); // var createVBusSpecificationData = require('./specification-data'); var SpecificationFile = require('./specification-file'); // var globalSpecificationData = utils.deepFreezeObjectTree(createVBusSpecificationData()); var globalSpecificationFile = SpecificationFile.getDefaultSpecificationFile() var globalSpecificationData = null; if (globalSpecificationFile) { globalSpecificationData = utils.deepFreezeObjectTree(globalSpecificationFile.getSpecificationData()); } var globalSpecification; var conversionFactors = { BtusPerWattHour: 3.412128, GramsCO2OilPerWattHour: 0.568, GramsCO2GasPerWattHour: 0.2536, GallonsPerLiter: 0.264172, PoundsForcePerSquareInchPerBar: 14.5037738, }; var optionKeys = [ 'language' ]; var numberFormatCache = {}; /** * @typedef UnitSpecification * @type {object} * @property {String} unitId Unit identifier * @property {String} unitCode Unit code * @property {String} unitFamily Unit family * @property {String} unitText Unit text */ /** * @typedef TypeSpecification * @type {object} * @property {String} typeId Type identifier * @property {String} rootTypeId Root type identifier * @property {number} precision Precision for numeral values * @property {UnitSpecification} unit Unit object */ /** * @typedef DeviceSpecification * @type {object} * @property {string} deviceId Device identifier * @property {number} channel VBus channel * @property {number} selfAddress VBus address of the device itself * @property {number} peerAddress VBus address of the device's peer * @property {string} name Name of the device * @property {string} fullName Name of the device optionally prefixed with VBus channel (if it is not 0) */ /** * @typedef PacketSpecification * @type {object} * @property {string} packetId Packet identifier * @property {number} channel VBus channel * @property {number} destinationAddress VBus address of the destination device * @property {number} sourceAddress VBus address of the source device * @property {number} protocolVersion VBus protocol version * @property {number} command VBus command * @property {number} info Additional info for sorting purposes * @property {DeviceSpecification} destinationDevice DeviceSpecification object of the destination device * @property {DeviceSpecification} sourceDevice DeviceSpecification object of the source device * @property {PacketFieldSpecification[]} packetFields Array of PacketFieldSpecification objects */ /** * @typedef packetFieldGetRawValue * @type {function} * @param {Buffer} buffer Buffer object * @param {number} start Start index in the buffer * @param {number} end End index in the buffer */ /** * @typedef PacketFieldSpecification * @type {object} * @property {string} fieldId Field identifier * @property {object} name Object containing names by language code * @property {TypeSpecification} type TypeSpecification object * @property {packetFieldGetRawValue} getRawValue Function to get raw value from a buffer */ /** * @typedef PacketField * @type {object} * @property {string} id Packet field identifier * @property {Packet} packet Packet * @property {PacketSpecification} packetSpec * @property {PacketFieldSpecification} packetFieldSpec * @property {PacketFieldSpecification} origPacketFieldSpec * @property {string} name * @property {number} rawValue Raw value * @property {function} formatTextValue Function to format this packet field's raw value into textual form */ /** * @typedef FilteredPacketFieldSpecification * @type {object} * @property {string} filteredPacketFieldId * @property {string} packetId * @property {string} fieldId * @property {string} name * @property {string} type * @property {string} getRawValue */ /** * @typedef BlockTypeSection * @type {object} * @property {string} sectionId Section identifier * @property {string} surrogatePacketId Surrogate packet identifier * @property {Packet} packet Packet object * @property {PacketSpecification} packetSpec PacketSpecification object * @property {number} startOffset Offset of section start within Packet frame data * @property {number} endOffset Offset of section end within Packet frame data * @property {number} type Section type * @property {number} payloadCount Count of payload elements * @property {number} frameCount Count of frames * @property {Buffer} frameData Frame data */ var Specification = extend(null, /** @lends Specification# */ { /** * Language code (ISO 639-1) * @type {string} */ language: 'en', deviceSpecCache: null, packetSpecCache: null, blockTypePacketSpecCache: null, /** * I18N instance * @type {I18N} */ i18n: null, /** * Custom specification data to be mixed-in to built-in specification. * @type {object} */ specificationData: null, /** * Creates a new Specification instance and optionally initializes its members with the given values. * * @constructs * @param {object} options Initialization values for this instance's members * @param {string} options.language {@link Specification#language} * @param {string} options.specificationData {@link Specification#specificationData} */ constructor: function(options) { _.extend(this, _.pick(options, optionKeys)); this.i18n = new I18N(this.language); this.deviceSpecCache = {}; this.packetSpecCache = {}; this.blockTypePacketSpecCache = {}; var specificationData; if (!options) { // nop } else if (options.specificationData) { specificationData = options.specificationData; } else if (options.specificationFile) { specificationData = { specificationData: options.specificationFile.getSpecificationData(), }; } this.specificationData = Specification.loadSpecificationData(specificationData); }, /** * Gets the UnitSpecification object matching the given identifier. * * @param {string} id Unit identifier * @returns {UnitSpecification} Unit object * * @example * &gt; console.log(spec.getUnitById('DegreesCelsius')); * { unitId: 'DegreesCelsius', * unitCode: 'DegreesCelsius', * unitText: ' °C' } * undefined * &gt; */ getUnitById: function(id) { return this.specificationData.units [id]; }, /** * Gets the TypeSpecification object matching the given identifier. * * @param {string} id Type identifier * @returns {TypeSpecification} Type object * * @example * &gt; console.log(spec.getTypeById('Number_0_1_DegreesCelsius')); * { typeId: 'Number_0_1_DegreesCelsius', * rootTypeId: 'Number', * precision: 1, * unit: * { unitId: 'DegreesCelsius', * unitCode: 'DegreesCelsius', * unitText: ' °C' } } * undefined * &gt; */ getTypeById: function(id) { return this.specificationData.types [id]; }, /** * Gets the DeviceSpecification object matching the given arguments. * * @memberof Specification# * @name getDeviceSpecification * @method * * @param {number} selfAddress VBus address of the device itself * @param {number} peerAddress VBus address of the device's peer * @param {number} [channel=0] VBus channel of the device * @returns {DeviceSpecification} DeviceSpecification object * * @example * &gt; console.log(spec.getDeviceSpecification(0x7E11, 0x0000, 1)); * { name: 'DeltaSol MX [Regler]', * deviceId: '01_7E11_0000', * channel: 1, * selfAddress: 32273, * peerAddress: 0, * fullName: 'VBus #1: DeltaSol MX [Regler]' } * undefined * &gt; */ /** * Gets the DeviceSpecification object matching the given header and direction. * * @param {Header} header Header instance * @param {string} which Either `'source'` or `'destination'` * @returns {DeviceSpecification} DeviceSpecification object */ getDeviceSpecification: function(selfAddress, peerAddress, channel) { if (typeof selfAddress === 'object') { if (peerAddress === 'source') { channel = selfAddress.channel; peerAddress = selfAddress.destinationAddress; selfAddress = selfAddress.sourceAddress; } else if (peerAddress === 'destination') { channel = selfAddress.channel; peerAddress = selfAddress.sourceAddress; selfAddress = selfAddress.destinationAddress; } else { throw new Error('Invalid arguments'); } } else if (typeof selfAddress === 'string') { var md = selfAddress.match(/^(?:([0-9a-f]{2})_)?([0-9a-f]{4})(?:_([0-9a-f]{4})(?:_.*)?)?$/i); if (!md) { throw new Error('Invalid device ID'); } selfAddress = parseInt(md [2], 16); peerAddress = parseInt(md [3], 16); channel = parseInt(md [1], 16); } if (channel === undefined) { channel = 0; } var deviceId = sprintf('%02X_%04X_%04X', channel, selfAddress, peerAddress); if (!_.has(this.deviceSpecCache, deviceId)) { var origDeviceSpec; if (!origDeviceSpec &amp;&amp; this.specificationData.getDeviceSpecification) { origDeviceSpec = this.specificationData.getDeviceSpecification(selfAddress, peerAddress); } if (!origDeviceSpec &amp;&amp; this.specificationData.deviceSpecs) { origDeviceSpec = this.specificationData.deviceSpecs ['_' + deviceId]; } var deviceSpec = _.extend({}, origDeviceSpec, { deviceId: deviceId, channel: channel, selfAddress: selfAddress, peerAddress: peerAddress, }); if (!_.has(deviceSpec, 'name')) { deviceSpec.name = this.i18n.t('specification.unknownDevice', selfAddress); } if (!_.has(deviceSpec, 'fullName')) { var fullNameFormatter; if (channel) { fullNameFormatter = 'specification.fullNameWithChannel'; } else { fullNameFormatter = 'specification.fullNameWithoutChannel'; } deviceSpec.fullName = this.i18n.t(fullNameFormatter, channel, deviceSpec.name); } this.deviceSpecCache [deviceId] = Object.freeze(deviceSpec); } return this.deviceSpecCache [deviceId]; }, /** * Gets the PacketSpecification object matching the given arguments. * * @memberof Specification# * @name getPacketSpecification * @method * * @param {number} channel VBus channel * @param {number} destinationAddress VBus address of destination device * @param {number} sourceAddress VBus address of source device * @param {number} command VBus command * @returns {PacketSpecification} PacketSpecification object * * @example * &gt; console.log(spec.getPacketSpecification(1, 0x0010, 0x7E21, 0x0100)); * { packetId: '01_0010_7E21_10_0100', * packetFields: * [ { fieldId: '000_2_0', * name: [Object], * type: [Object], * getRawValue: [Function] }, * { fieldId: '002_1_0', * name: [Object], * type: [Object], * getRawValue: [Function] } ], * channel: 1, * destinationAddress: 16, * sourceAddress: 32289, * protocolVersion: 16, * command: 256, * info: 0, * destinationDevice: * { name: 'DFA', * deviceId: '01_0010_7E21', * channel: 1, * selfAddress: 16, * peerAddress: 32289, * fullName: 'VBus #1: DFA' }, * sourceDevice: * { name: 'DeltaSol MX [Heizkreis #1]', * deviceId: '01_7E21_0010', * channel: 1, * selfAddress: 32289, * peerAddress: 16, * fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' }, * fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' } * undefined * &gt; */ /** * Gets the PacketSpecification object matching the given arguments. * * @memberof Specification# * @name getPacketSpecification * @method * * @param {string} packetSpecId PacketSpecification identifier * @returns {PacketSpecification} PacketSpecification object * * @example * &gt; console.log(spec.getPacketSpecification('01_0010_7E21_10_0100')); * { packetId: '01_0010_7E21_10_0100', * packetFields: * [ { fieldId: '000_2_0', * name: [Object], * type: [Object], * getRawValue: [Function] }, * { fieldId: '002_1_0', * name: [Object], * type: [Object], * getRawValue: [Function] } ], * channel: 1, * destinationAddress: 16, * sourceAddress: 32289, * protocolVersion: 16, * command: 256, * info: 0, * destinationDevice: * { name: 'DFA', * deviceId: '01_0010_7E21', * channel: 1, * selfAddress: 16, * peerAddress: 32289, * fullName: 'VBus #1: DFA' }, * sourceDevice: * { name: 'DeltaSol MX [Heizkreis #1]', * deviceId: '01_7E21_0010', * channel: 1, * selfAddress: 32289, * peerAddress: 16, * fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' }, * fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' } * undefined * &gt; */ /** * Gets the PacketSpecification object matching the given packet. * * @param {Packet} packet VBus packet * @returns {PacketSpecification} PacketSpecification object */ getPacketSpecification: function(headerOrChannel, destinationAddress, sourceAddress, command) { if (typeof headerOrChannel === 'object') { command = headerOrChannel.command; sourceAddress = headerOrChannel.sourceAddress; destinationAddress = headerOrChannel.destinationAddress; headerOrChannel = headerOrChannel.channel; } else if (typeof headerOrChannel === 'string') { var md = headerOrChannel.match(/^([0-9a-f]{2})_([0-9a-f]{4})_([0-9a-f]{4})(?:_10)?_([0-9a-f]{4})/i); if (!md) { throw new Error('Invalid packet ID'); } command = parseInt(md [4], 16); sourceAddress = parseInt(md [3], 16); destinationAddress = parseInt(md [2], 16); headerOrChannel = parseInt(md [1], 16); } var packetId = sprintf('%02X_%04X_%04X_10_%04X', headerOrChannel, destinationAddress, sourceAddress, command); if (!_.has(this.packetSpecCache, packetId)) { var origPacketSpec; if (!origPacketSpec &amp;&amp; this.specificationData.getPacketSpecification) { origPacketSpec = this.specificationData.getPacketSpecification(destinationAddress, sourceAddress, command); } if (!origPacketSpec &amp;&amp; this.specificationData.packetSpecs) { origPacketSpec = this.specificationData.packetSpecs ['_' + packetId]; } var destinationDeviceSpec = this.getDeviceSpecification(destinationAddress, sourceAddress, headerOrChannel); var sourceDeviceSpec = this.getDeviceSpecification(sourceAddress, destinationAddress, headerOrChannel); var fullName = sourceDeviceSpec.fullName; if (destinationAddress !== 0x0010) { fullName += ' =&gt; ' + destinationDeviceSpec.name; } var packetSpec = _.extend({}, origPacketSpec, { packetId: packetId, channel: headerOrChannel, destinationAddress: destinationAddress, sourceAddress: sourceAddress, protocolVersion: 0x10, command: command, info: 0, destinationDevice: destinationDeviceSpec, sourceDevice: sourceDeviceSpec, fullName: fullName, }); if (!_.has(packetSpec, 'packetFields')) { packetSpec.packetFields = []; } this.packetSpecCache [packetId] = Object.freeze(packetSpec); } return this.packetSpecCache [packetId]; }, /** * Gets the PacketFieldSpecification object matching the given arguments. * * @memberof Specification# * @name getPacketFieldSpecification * @method * * @param {PacketSpecification} packetSpec PacketSpecification object * @param {string} fieldId Field identifier * @returns {PacketFieldSpecification} PacketFieldSpecification object * * @example * &gt; var packetSpec = spec.getPacketSpecification('01_0010_7E21_10_0100'); * undefined * &gt; console.log(spec.getPacketFieldSpecification(packetSpec, '000_2_0')); * { fieldId: '000_2_0', * name: * { ref: 'Flow set temperature', * en: 'Flow set temperature', * de: 'Vorlauf-Soll-Temperatur', * fr: 'Température nominale départ' }, * type: * { typeId: 'Number_0_1_DegreesCelsius', * rootTypeId: 'Number', * precision: 1, * unit: * { unitId: 'DegreesCelsius', * unitCode: 'DegreesCelsius', * unitText: ' °C' } }, * getRawValue: [Function] } * undefined * &gt; */ /** * Gets the PacketFieldSpecification object matching the given arguments. * * @param {string} packetFieldId Packet field identifier * @returns {PacketFieldSpecification} PacketFieldSpecification object * * @example * &gt; console.log(spec.getPacketFieldSpecification('01_0010_7E21_10_0100_000_2_0')); * { fieldId: '000_2_0', * name: * { ref: 'Flow set temperature', * en: 'Flow set temperature', * de: 'Vorlauf-Soll-Temperatur', * fr: 'Température nominale départ' }, * type: * { typeId: 'Number_0_1_DegreesCelsius', * rootTypeId: 'Number', * precision: 1, * unit: * { unitId: 'DegreesCelsius', * unitCode: 'DegreesCelsius', * unitText: ' °C' } }, * getRawValue: [Function] } * undefined * &gt; */ getPacketFieldSpecification: function(packetSpecOrId, fieldId) { var packetFieldSpec; if (typeof packetSpecOrId === 'string') { if (this.specificationData.filteredPacketFieldSpecs) { packetFieldSpec = _.find(this.specificationData.filteredPacketFieldSpecs, { filteredPacketFieldId: packetSpecOrId }); } if (!packetFieldSpec) { var md = packetSpecOrId.match(/^([0-9a-f]{2}_[0-9a-f]{4}_[0-9a-f]{4}(?:_10)?_[0-9a-f]{4})_(.*)$/i); if (!md) { throw new Error('Invalid packet field ID'); } fieldId = md [2]; packetSpecOrId = this.getPacketSpecification(md [1]); } } if (!packetFieldSpec &amp;&amp; packetSpecOrId) { packetFieldSpec = _.find(packetSpecOrId.packetFields, { fieldId: fieldId }); } return packetFieldSpec; }, /** * Gets the raw value of a packet field from a buffer. * * @param {PacketFieldSpecification} packetField PacketFieldSpecification object * @param {Buffer} buffer Buffer object * @param {number} [start=0] Start index in the buffer * @param {number} [end=buffer.length] End index in the buffer * @returns {number} Raw value * * @example * &gt; var packetFieldSpec = spec.getPacketFieldSpecification('01_0010_7721_10_0100_000_2_0'); * undefined * &gt; var buffer = new Buffer('b822', 'hex'); * undefined * &gt; console.log(spec.getRawValue(packetFieldSpec, buffer)); * 888.8000000000001 * undefined * &gt; */ getRawValue: function(packetField, buffer, start, end) { if (start === undefined) { start = 0; } if (end === undefined) { end = buffer ? buffer.length : 0; } var rawValue; if (packetField &amp;&amp; packetField.getRawValue) { rawValue = packetField.getRawValue(buffer, start, end); } else if (packetField &amp;&amp; packetField.packetFieldSpec) { rawValue = this.getRawValue(packetField.packetFieldSpec, buffer, start, end); if (_.isNumber(rawValue)) { if (packetField.conversions) { rawValue = this.convertRawValue(rawValue, packetField.conversions).rawValue; } else { rawValue = this.convertRawValue(rawValue, packetField.packetFieldSpec.type.unit, packetField.type.unit).rawValue; } } } else { rawValue = null; } return rawValue; }, getRoundedRawValue: function(packetField, buffer, start, end) { var rawValue = this.getRawValue(packetField, buffer, start, end); var precision = packetField &amp;&amp; packetField.type &amp;&amp; packetField.type.precision || 0; var roundedRawValue = utils.roundNumber(rawValue, -precision); return roundedRawValue; }, invertConversions: function(conversions) { if (!_.isArray(conversions)) { return conversions; } return _.map(conversions.reverse(), function(conversion) { var invertedConversion = {}; if (_.isNumber(conversion.offset)) { invertedConversion.offset = conversion.offset * -1; } if (_.isNumber(conversion.factor)) { invertedConversion.factor = 1 / conversion.factor; } if (_.isNumber(conversion.power)) { if (conversion.power !== 0) { invertedConversion.power = 1 / conversion.power; } else { invertedConversion.power = conversion.power; } } if (conversion.sourceUnit) { invertedConversion.targetUnit = conversion.sourceUnit; } if (conversion.targetUnit) { invertedConversion.sourceUnit = conversion.targetUnit; } return invertedConversion; }); }, setRawValue: function(packetField, rawValue, buffer, start, end) { if (start === undefined) { start = 0; } if (end === undefined) { end = buffer ? buffer.length : 0; } if (packetField &amp;&amp; packetField.setRawValue) { packetField.setRawValue(rawValue, buffer, start, end); } else if (packetField &amp;&amp; packetField.packetFieldSpec) { if (_.isNumber(rawValue)) { if (packetField.conversions) { rawValue = this.convertRawValue(rawValue, this.invertConversions(packetField.conversions)).rawValue; } else { rawValue = this.convertRawValue(rawValue, packetField.type.unit, packetField.packetFieldSpec.type.unit).rawValue; } } this.setRawValue(packetField.packetFieldSpec, rawValue, buffer, start, end); } }, /** * Converts a raw number value from one unit to another. The units must be in the same unit family. * * @param {number} rawValue Raw number value to convert from * @param {Unit} sourceUnit Unit to convert from * @param {Unit} targetUnit Unit to convert to * @return {object} Result containing a `rawValue` property with the conversion result and a `unit` property with the associated unit. */ convertRawValue: function(rawValue_, sourceUnit_, targetUnit_) { var that = this; var conversions; if (_.isArray(sourceUnit_)) { conversions = sourceUnit_; } else { conversions = [{ power: null, factor: null, offset: null, sourceUnit: sourceUnit_, targetUnit: targetUnit_, }]; } var result = _.reduce(conversions, function(valueInfo, conversion) { var rawValue = valueInfo.rawValue; var sourceUnit = conversion.sourceUnit; var targetUnit = conversion.targetUnit; var unitFamily = sourceUnit &amp;&amp; sourceUnit.unitFamily; var hasPower = _.isNumber(conversion.power); var hasFactor = _.isNumber(conversion.factor); var hasOffset = _.isNumber(conversion.offset); var autoConvert = !hasFactor &amp;&amp; !hasOffset &amp;&amp; !hasPower; if (hasPower) { if (rawValue === 0 &amp;&amp; conversion.power &lt; 0) { rawValue = 0; // Infinity } else { rawValue = Math.pow(rawValue, conversion.power); } } if (hasFactor) { rawValue = rawValue * conversion.factor; } if (hasOffset) { rawValue = rawValue + conversion.offset; } if (autoConvert &amp;&amp; !sourceUnit) { throw new Error('Must provide a source unit'); } else if (!targetUnit) { // nop, no conversion requested } else if (sourceUnit.unitCode === targetUnit.unitCode) { // nop, no conversion for same unit } else if (targetUnit.unitCode === 'None') { // nop, just ignore the unit suffix } else if (!autoConvert) { // nop, already multiplied by factor above and allows to change unit family } else if (unitFamily !== targetUnit.unitFamily) { throw new Error('Unit families of source and target unit must match'); } else if (!unitFamily) { // nop, no conversion for unknown unit family } else if (unitFamily === 'Temperature') { rawValue = that._convertTemperatureRawValue(rawValue, sourceUnit.unitCode, targetUnit.unitCode); } else if (unitFamily === 'Volume') { rawValue = that._convertVolumeRawValue(rawValue, sourceUnit.unitCode, targetUnit.unitCode); } else if (unitFamily === 'VolumeFlow') { rawValue = that._convertVolumeFlowRawValue(rawValue, sourceUnit.unitCode, targetUnit.unitCode); } else if (unitFamily === 'Pressure') { rawValue = that._convertPressureRawValue(rawValue, sourceUnit.unitCode, targetUnit.unitCode); } else if (unitFamily === 'Energy') { rawValue = that._convertEnergyRawValue(rawValue, sourceUnit.unitCode, targetUnit.unitCode); } else if (unitFamily === 'Power') { rawValue = that._convertPowerRawValue(rawValue, sourceUnit.unitCode, targetUnit.unitCode); } else if (unitFamily === 'Time') { rawValue = that._convertTimeRawValue(rawValue, sourceUnit.unitCode, targetUnit.unitCode); } else { throw new Error('Unsupported unit family ' + JSON.stringify(sourceUnit.unitFamily)); } return { rawValue: rawValue, unit: targetUnit || sourceUnit, }; }, { rawValue: rawValue_, unit: sourceUnit_, }); return result; }, _convertTemperatureRawValue: function(rawValue, sourceUnitCode, targetUnitCode) { switch (sourceUnitCode) { case 'DegreesCelsius': // nop break; case 'DegreesFahrenheit': rawValue = (rawValue - 32) / 1.8; break; default: throw new Error('Unsupported source unit ' + JSON.stringify(sourceUnitCode)); } switch (targetUnitCode) { case 'DegreesCelsius': // nop break; case 'DegreesFahrenheit': rawValue = (rawValue * 1.8) + 32; break; default: throw new Error('Unsupported target unit ' + JSON.stringify(targetUnitCode)); } return rawValue; }, _convertVolumeRawValue: function(rawValue, sourceUnitCode, targetUnitCode) { switch (sourceUnitCode) { case 'Liters': // nop break; case 'CubicMeters': rawValue = rawValue * 1000; break; case 'Gallons': rawValue = rawValue / conversionFactors.GallonsPerLiter; break; default: throw new Error('Unsupported source unit ' + JSON.stringify(sourceUnitCode)); } switch (targetUnitCode) { case 'Liters': // nop break; case 'CubicMeters': rawValue = rawValue / 1000; break; case 'Gallons': rawValue = rawValue * conversionFactors.GallonsPerLiter; break; default: throw new Error('Unsupported target unit ' + JSON.stringify(targetUnitCode)); } return rawValue; }, _convertVolumeFlowRawValue: function(rawValue, sourceUnitCode, targetUnitCode) { switch (sourceUnitCode) { case 'LitersPerHour': // nop break; case 'LitersPerMinute': rawValue = rawValue * 60; break; case 'CubicMetersPerHour': rawValue = rawValue * 1000; break; case 'GallonsPerHour': rawValue = rawValue / conversionFactors.GallonsPerLiter; break; case 'GallonsPerMinute': rawValue = rawValue * 60 / conversionFactors.GallonsPerLiter; break; default: throw new Error('Unsupported source unit ' + JSON.stringify(sourceUnitCode)); } switch (targetUnitCode) { case 'LitersPerHour': // nop break; case 'LitersPerMinute': rawValue = rawValue / 60; break; case 'CubicMetersPerHour': rawValue = rawValue / 1000; break; case 'GallonsPerHour': rawValue = rawValue * conversionFactors.GallonsPerLiter; break; case 'GallonsPerMinute': rawValue = rawValue / 60 * conversionFactors.GallonsPerLiter; break; default: throw new Error('Unsupported target unit ' + JSON.stringify(targetUnitCode)); } return rawValue; }, _convertPressureRawValue: function(rawValue, sourceUnitCode, targetUnitCode) { switch (sourceUnitCode) { case 'Bars': // nop break; case 'PoundsForcePerSquareInch': rawValue = rawValue / conversionFactors.PoundsForcePerSquareInchPerBar; break; default: throw new Error('Unsupported source unit ' + JSON.stringify(sourceUnitCode)); } switch (targetUnitCode) { case 'Bars': // nop break; case 'PoundsForcePerSquareInch': rawValue = rawValue * conversionFactors.PoundsForcePerSquareInchPerBar; break; default: throw new Error('Unsupported target unit ' + JSON.stringify(targetUnitCode)); } return rawValue; }, _convertEnergyRawValue: function(rawValue, sourceUnitCode, targetUnitCode) { switch (sourceUnitCode) { case 'WattHours': // nop break; case 'KilowattHours': rawValue = rawValue * 1000; break; case 'MegawattHours': rawValue = rawValue * 1000000; break; case 'Btus': rawValue = rawValue / conversionFactors.BtusPerWattHour; break; case 'KiloBtus': rawValue = rawValue * 1000 / conversionFactors.BtusPerWattHour; break; case 'MegaBtus': rawValue = rawValue * 1000000 / conversionFactors.BtusPerWattHour; break; case 'GramsCO2Gas': rawValue = rawValue / conversionFactors.GramsCO2GasPerWattHour; break; case 'KilogramsCO2Gas': rawValue = rawValue * 1000 / conversionFactors.GramsCO2GasPerWattHour; break; case 'TonsCO2Gas': rawValue = rawValue * 1000000 / conversionFactors.GramsCO2GasPerWattHour; break; case 'GramsCO2Oil': rawValue = rawValue / conversionFactors.GramsCO2OilPerWattHour; break; case 'KilogramsCO2Oil': rawValue = rawValue * 1000 / conversionFactors.GramsCO2OilPerWattHour; break; case 'TonsCO2Oil': rawValue = rawValue * 1000000 / conversionFactors.GramsCO2OilPerWattHour; break; default: throw new Error('Unsupported source unit ' + JSON.stringify(sourceUnitCode)); } switch (targetUnitCode) { case 'WattHours': // nop break; case 'KilowattHours': rawValue = rawValue / 1000; break; case 'MegawattHours': rawValue = rawValue / 1000000; break; case 'Btus': rawValue = rawValue * conversionFactors.BtusPerWattHour; break; case 'KiloBtus': rawValue = rawValue / 1000 * conversionFactors.BtusPerWattHour; break; case 'MegaBtus': rawValue = rawValue / 1000000 * conversionFactors.BtusPerWattHour; break; case 'GramsCO2Gas': rawValue = rawValue * conversionFactors.GramsCO2GasPerWattHour; break; case 'KilogramsCO2Gas': rawValue = rawValue / 1000 * conversionFactors.GramsCO2GasPerWattHour; break; case 'TonsCO2Gas': rawValue = rawValue / 1000000 * conversionFactors.GramsCO2GasPerWattHour; break; case 'GramsCO2Oil': rawValue = rawValue * conversionFactors.GramsCO2OilPerWattHour; break; case 'KilogramsCO2Oil': rawValue = rawValue / 1000 * conversionFactors.GramsCO2OilPerWattHour; break; case 'TonsCO2Oil': rawValue = rawValue / 1000000 * conversionFactors.GramsCO2OilPerWattHour; break; default: throw new Error('Unsupported target unit ' + JSON.stringify(targetUnitCode)); } return rawValue; }, _convertPowerRawValue: function(rawValue, sourceUnitCode, targetUnitCode) { switch (sourceUnitCode) { case 'Watts': // nop break; case 'Kilowatts': rawValue = rawValue * 1000; break; default: throw new Error('Unsupported source unit ' + JSON.stringify(sourceUnitCode)); } switch (targetUnitCode) { case 'Watts': // nop break; case 'Kilowatts': rawValue = rawValue / 1000; break; default: throw new Error('Unsupported target unit ' + JSON.stringify(targetUnitCode)); } return rawValue; }, _convertTimeRawValue: function(rawValue, sourceUnitCode, targetUnitCode) { switch (sourceUnitCode) { case 'Seconds': // nop break; case 'Minutes': rawValue = rawValue * 60; break; case 'Hours': rawValue = rawValue * 3600; break; case 'Days': rawValue = rawValue * 86400; break; default: throw new Error('Unsupported source unit ' + JSON.stringify(sourceUnitCode)); } switch (targetUnitCode) { case 'Seconds': // nop break; case 'Minutes': rawValue = rawValue / 60; break; case 'Hours': rawValue = rawValue / 3600; break; case 'Days': rawValue = rawValue / 86400; break; default: throw new Error('Unsupported target unit ' + JSON.stringify(targetUnitCode)); } return rawValue; }, /** * Formats a raw value into its textual representation. * * @param {PacketFieldSpecification} packetField PacketFieldSpecification object * @param {number} rawValue Raw value * @param {string|UnitSpecification|null} [unit] Unit to format to * @returns {string} Textual representation of the raw value * * @example * &gt; var packetFieldSpec = spec.getPacketFieldSpecification('01_0010_7721_10_0100_000_2_0'); * undefined * &gt; var rawValue = 888.8000000000001; * undefined * &gt; console.log(spec.formatTextValueFromRawValue(packetFieldSpec, rawValue, 'DegreesCelsius')); * 888.8 °C * undefined * &gt; */ formatTextValueFromRawValue: function(packetField, rawValue, unit) { var textValue; if ((rawValue !== undefined) &amp;&amp; (rawValue !== null)) { if (typeof unit === 'string') { if (_.has(this.specificationData.units, unit)) { unit = this.specificationData.units [unit]; } else { throw new Error('Unknown unit named &quot;' + unit + '&quot;'); } } if (packetField &amp;&amp; packetField.type) { var type = packetField.type; if (type.formatTextValue) { textValue = type.formatTextValue(rawValue, unit); } else { textValue = this.formatTextValueFromRawValueInternal(rawValue, unit, type.rootTypeId, type.precision, type.unit); } } else { textValue = rawValue.toString(); if (unit &amp;&amp; unit.unitText) { textValue += unit.unitText; } } } else { textValue = ''; } return textValue; }, formatTextValueFromRawValueInternal: function(rawValue, unit, rootType, precision, defaultUnit) { var unitText = unit ? unit.unitText : defaultUnit ? defaultUnit.unitText : ''; var result, textValue, format; if (rootType === 'Time') { textValue = this.i18n.moment(rawValue * 60000).utc().format('HH:mm'); result = textValue + unitText; } else if (rootType === 'Weektime') { textValue = this.i18n.moment((rawValue + 5760) * 60000).utc().format('dd,HH:mm'); result = textValue + unitText; } else if (rootType === 'DateTime') { textValue = this.i18n.moment((rawValue + 978307200) * 1000).utc().format('L HH:mm:ss'); result = textValue + unitText; } else if (precision === 0) { textValue = this.i18n.numeral(rawValue).format('0'); result = textValue + unitText; } else if (precision === 1) { textValue = this.i18n.numeral(rawValue).format('0.0'); result = textValue + unitText; } else if (precision === 2) { textValue = this.i18n.numeral(rawValue).format('0.00'); result = textValue + unitText; } else if (precision === 3) { textValue = this.i18n.numeral(rawValue).format('0.000'); result = textValue + unitText; } else if (precision === 4) { textValue = this.i18n.numeral(rawValue).format('0.0000'); result = textValue + unitText; } else { if (!_.has(numberFormatCache, precision)) { format = '0.'; for (var i = 0; i &lt; precision; i++) { format = format + '0'; } numberFormatCache [precision] = format; } textValue = this.i18n.numeral(rawValue).format(numberFormatCache [precision]); result = textValue + unitText; } return result; }, /** * Gets an array of PacketField objects for the provided Packet objects. * * @param {Header[]} headers Array of Header objects * @returns {PacketField[]} Array of PacketField objects */ getPacketFieldsForHeaders: function(headers) { var _this = this; // filter out all packets var packets = _.reduce(headers, function(memo, header) { if ((header.getProtocolVersion() &amp; 0xF0) === 0x10) { memo.push(header); } return memo; }, []); var packetFields = []; var filteredPacketFieldSpecs = this.specificationData.filteredPacketFieldSpecs; if (filteredPacketFieldSpecs) { var packetById = _.reduce(packets, function(memo, packet) { var packetSpec = _this.getPacketSpecification(packet); memo [packetSpec.packetId] = packet; return memo; }, {}); _.forEach(filteredPacketFieldSpecs, function(fpfs) { var packetField = _.extend({}, { id: fpfs.filteredPacketFieldId, packet: packetById [fpfs.packetId], packetSpec: fpfs.packetSpec, packetFieldSpec: fpfs, origPacketFieldSpec: fpfs.packetFieldSpec, }); packetFields.push(packetField); }); } else { _.forEach(packets, function(packet) { var packetSpec = _this.getPacketSpecification(packet); if (packetSpec) { _.forEach(packetSpec.packetFields, function(packetFieldSpec) { var packetField = { id: packetSpec.packetId + '_' + packetFieldSpec.fieldId, packet: packet, packetSpec: packetSpec, packetFieldSpec: packetFieldSpec, origPacketFieldSpec: packetFieldSpec, }; packetFields.push(packetField); }); } }); } var language = this.language; _.forEach(packetFields, function(packetField) { var pfsName = packetField.packetFieldSpec.name; var name; if (_.isString(pfsName)) { var key = 'specificationData.packetFieldName.' + pfsName; name = _this.i18n.t(key); if (name === key) { name = pfsName; } } else if (_.isObject(pfsName)) { name = pfsName [language] || pfsName.en || pfsName.de || pfsName.ref; } var rawValue; if (packetField.packetFieldSpec &amp;&amp; packetField.packet) { var frameData = packetField.packet.frameData.slice(0, packetField.packet.frameCount * 4); rawValue = _this.getRawValue(packetField.packetFieldSpec, frameData); } var precision; if (packetField.packetFieldSpec &amp;&amp; packetField.packetFieldSpec.type) { precision = packetField.packetFieldSpec.type.precision || 0; } _.extend(packetField, { name: name, rawValue: rawValue, formatTextValue: function(unit) { return _this.formatTextValueFromRawValue(packetField.packetFieldSpec, rawValue, unit); }, getRoundedRawValue: function() { return utils.roundNumber(rawValue, -precision); }, }); }); return packetFields; }, setPacketFieldRawValues: function(packetFields, rawValues) { var _this = this; var packetFieldById = _.reduce(packetFields, function(memo, packetField) { memo [packetField.id] = packetField; var fieldId = packetField.packetFieldSpec.fieldId; if (memo [fieldId] === undefined) { memo [fieldId] = packetField; } else { memo [fieldId] = null; } return memo; }, {}); _.forEach(rawValues, function(rawValue, key) { var packetField = packetFieldById [key]; if (packetField === undefined) { throw new Error('Unknown raw value ID ' + JSON.stringify(key)); } else if (packetField === null) { throw new Error('Non-unique raw value ID ' + JSON.stringify(key)); } else { var frameData = packetField.packet.frameData.slice(0, packetField.packet.frameCount * 4); _this.setRawValue(packetField.packetFieldSpec, rawValue, frameData); } }); }, getFilteredPacketFieldSpecificationsForHeaders: function(headers) { var filteredPacketFieldSpecs = []; var packetFields = this.getPacketFieldsForHeaders(headers); _.forEach(packetFields, function(packetField) { var packetSpec = packetField.packetSpec; var packetFieldSpec = packetField.packetFieldSpec; if (packetSpec &amp;&amp; packetFieldSpec) { var filteredPacketFieldSpec = _.extend({}, packetFieldSpec, { filteredPacketFieldId: packetSpec.packetId + '_' + packetFieldSpec.fieldId, packetId: packetSpec.packetId, name: packetField.name, }); filteredPacketFieldSpecs.push(filteredPacketFieldSpec); } }); return filteredPacketFieldSpecs; }, /** * Gets an array of BlockType sections from a collection of headers. * * @param {Header[]} headers Array of Header objects * @return {BlockTypeSection[]} Array of BlockTypeSection objects */ getBlockTypeSectionsForHeaders: function(headers) { var _this = this; return _.reduce(headers, function(memo, header) { if (((header.getProtocolVersion() &amp; 0xF0) === 0x10) &amp;&amp; (header.destinationAddress === 0x0015) &amp;&amp; (header.command === 0x0100)) { var packetSpec = _this.getPacketSpecification(header); var startOffset = 0, length = header.frameCount * 4, frameData = header.frameData; while (startOffset + 4 &lt;= length) { var frameCount = frameData [startOffset] &amp; 255; var endOffset = startOffset + 4 + 4 * frameCount; if (endOffset &lt;= length) { var type = frameData [startOffset + 1] &amp; 255; var payloadSize = null, payloadCount = null; // TODO(daniel): refine the payload count based on the type if (type === 1) { payloadSize = 2; } else if (type === 5) { payloadSize = 4; } else if (type === 8) { payloadSize = 1; } else if (type === 10) { payloadSize = 8; } else if (type === 11) { payloadSize = 4; } else if (type === 12) { payloadSize = 4; } else if (type === 13) { payloadSize = 4; } else if (type === 14) { payloadSize = 1; } else { payloadSize = 1; } if (!payloadCount &amp;&amp; payloadSize) { payloadCount = Math.floor((endOffset - startOffset - 4) / payloadSize); } var sectionId = sprintf('%s_%02X_%02X_%d', packetSpec.packetId, frameCount, type, payloadCount); var shasum = crypto.createHash('sha1'); shasum.update(new Buffer(sectionId, 'utf8')); var surrogatePacketIdHash = shasum.digest('hex').toUpperCase(); var surrogatePacketIdHashPart1 = surrogatePacketIdHash.slice(0, 4); var surrogatePacketIdHashPart2 = surrogatePacketIdHash.slice(4, 8); var surrogatePacketId = sprintf('%02X_%04X_%s_%02X_%s', header.channel, header.destinationAddress | 0x8000, surrogatePacketIdHashPart1, 0x10, surrogatePacketIdHashPart2); memo.push({ sectionId: sectionId, surrogatePacketId: surrogatePacketId, packet: header, packetSpec: packetSpec, startOffset: startOffset, endOffset: endOffset, type: type, payloadCount: payloadCount, frameCount: frameCount, frameData: frameData.slice(startOffset, endOffset), }); } startOffset = endOffset; } if (startOffset !== length) { throw new Error('Malformed block type packet, ending prematurely at offset ' + startOffset); } } return memo; }, []); }, _createUInt8BlockTypeFieldSpecification: function(fieldIdPrefix, offset, name, typeId, factor) { return { fieldId: sprintf('%s_%03d_1_0', fieldIdPrefix, offset), name: name, type: this.getTypeById(typeId), factor: factor, parts: [{ offset: offset, mask: 255, isSigned: false, factor: 1, }], getRawValue: function(buffer, start, end) { var rawValue = 0, valid = false; if (start + offset &lt; end) { rawValue += buffer.readUInt8(start + offset); valid = true; } if (valid) { rawValue = rawValue * factor; } else { rawValue = null; } return rawValue; }, setRawValue: function(newValue, buffer, start, end) { newValue = Math.round(newValue / factor); var rawValue; if (start + offset &lt; end) { rawValue = newValue &amp; 255; buffer.writeUInt8(rawValue, start + offset); } }, }; }, _createInt16BlockTypeFieldSpecification: function(fieldIdPrefix, offset, name, typeId, factor) { return { fieldId: sprintf('%s_%03d_2_0', fieldIdPrefix, offset), name: name, type: this.getTypeById(typeId), factor: factor, parts: [{ offset: offset, mask: 255, isSigned: false, factor: 1, }, { offset: offset + 1, mask: 255, isSigned: true, factor: 256, }], getRawValue: function(buffer, start, end) { var rawValue = 0, valid = false; if (start + offset &lt; end) { rawValue += buffer.readUInt8(start + offset); valid = true; } if (start + offset + 1 &lt; end) { rawValue += buffer.readInt8(start + offset + 1) * 256; valid = true; } if (valid) { rawValue = rawValue * factor; } else { rawValue = null; } return rawValue; }, setRawValue: function(newValue, buffer, start, end) { newValue = Math.round(newValue / factor); var rawValue; if (start + offset &lt; end) { rawValue = newValue &amp; 255; buffer.writeUInt8(rawValue, start + offset); } if (start + offset + 1 &lt; end) { rawValue = (newValue / 256) &amp; 255; buffer.writeUInt8(rawValue, start + offset + 1); } }, }; }, _createUInt32BlockTypeFieldSpecification: function(fieldIdPrefix, offset, name, typeId, factor) { return { fieldId: sprintf('%s_%03d_4_0', fieldIdPrefix, offset), name: name, type: this.getTypeById(typeId), factor: factor, parts: [{ offset: offset, mask: 255, isSigned: false, factor: 1, }, { offset: offset + 1, mask: 255, isSigned: false, factor: 256, }, { offset: offset + 2, mask: 255, isSigned: false, factor: 65536, }, { offset: offset + 3, mask: 255, isSigned: false, factor: 16777216, }], getRawValue: function(buffer, start, end) { var rawValue = 0, valid = false; if (start + offset &lt; end) { rawValue += buffer.readUInt8(start + offset); valid = true; } if (start + offset + 1 &lt; end) { rawValue += buffer.readUInt8(start + offset + 1) * 256; valid = true; } if (start + offset + 2 &lt; end) { rawValue += buffer.readUInt8(start + offset + 2) * 65536; valid = true; } if (start + offset + 3 &lt; end) { rawValue += buffer.readUInt8(start + offset + 3) * 16777216; valid = true; } if (valid) { rawValue = rawValue * factor; } else { rawValue = null; } return rawValue; }, setRawValue: function(newValue, buffer, start, end) { newValue = Math.round(newValue / factor); var rawValue; if (start + offset &lt; end) { rawValue = newValue &amp; 255; buffer.writeUInt8(rawValue, start + offset); } if (start + offset + 1 &lt; end) { rawValue = (newValue / 256) &amp; 255; buffer.writeUInt8(rawValue, start + offset + 1); } if (start + offset + 2 &lt; end) { rawValue = (newValue / 65536) &amp; 255; buffer.writeUInt8(rawValue, start + offset + 2); } if (start + offset + 3 &lt; end) { rawValue = (newValue / 16777216) &amp; 255; buffer.writeUInt8(rawValue, start + offset + 3); } }, }; }, /** * Gets the PacketSpecification objects matching the given BlockTypeSection objects. * * @param {BlockTypeSection[]} sections Array of BlockTypeSection objects * @return {PacketSpecification[]} Array of PacketSpecificationObjects */ getBlockTypePacketSpecificationsForSections: function(sections) { var _this = this; return _.reduce(sections, function(memo, section) { var sectionId = section.sectionId; if (!_.has(_this.blockTypePacketSpecCache, sectionId)) { var fieldIdPrefix = section.sectionId; var forEachPayload = function(iterator) { var count = section.payloadCount; for (var i = 0; i &lt; count; i++) { var suffix = (count &gt; 1) ? (' ' + (i + 1)) : ''; iterator(i, suffix); } }; var packetFieldSpecs = []; if (section.type === 1) { // temperatures forEachPayload(function(index, suffix) { packetFieldSpecs.push(_this._createInt16BlockTypeFieldSpecification(fieldIdPrefix, 4 + index * 2, 'Temperatur Sensor' + suffix, 'Number_0_1_DegreesCelsius', 0.1)); }); } else if (section.type === 5) { forEachPayload(function(index, suffix) { packetFieldSpecs.push(_this._createUInt32BlockTypeFieldSpecification(fieldIdPrefix, 4 + index * 4, 'Wärmemenge' + suffix, 'Number_1_WattHours', 1)); }); } else if (section.type === 8) { // Relais speeds forEachPayload(function(index, suffix) { packetFieldSpecs.push(_this._createUInt8BlockTypeFieldSpecification(fieldIdPrefix, 4 + index, 'Drehzahl Relais' + suffix, 'Number_1_Percent', 1)); }); } else if (section.type === 10) { // SmartDisplay forEachPayload(function(index, suffix) { packetFieldSpecs.push(_this._createInt16BlockTypeFieldSpecification(fieldIdPrefix, 4 + index * 8, 'Temperatur Kollektor' + suffix, 'Number_0_1_DegreesCelsius', 0.1)); packetFieldSpecs.push(_this._createInt16BlockTypeFieldSpecification(fieldIdPrefix, 6 + index * 8, 'Temperatur Speicher' + suffix, 'Number_0_1_DegreesCelsius', 0.1)); packetFieldSpecs.push(_this._createUInt32BlockTypeFieldSpecification(fieldIdPrefix, 8 + index * 8, 'Wärmemenge' + suffix, 'Number_1_WattHours', 1)); }); } else if (section.type === 11) { forEachPayload(function(index, suffix) { packetFieldSpecs.push(_this._createUInt32BlockTypeFieldSpecification(fieldIdPrefix, 4 + index * 4, 'Fehlermaske' + suffix, 'Number_1_None', 1)); }); } else if (section.type === 12) { forEachPayload(function(index, suffix) { packetFieldSpecs.push(_this._createUInt32BlockTypeFieldSpecification(fieldIdPrefix, 4 + index * 4, 'Warnungsmaske' + suffix, 'Number_1_None', 1)); }); } else if (section.type === 13) { forEachPayload(function(index, suffix) { packetFieldSpecs.push(_this._createUInt32BlockTypeFieldSpecification(fieldIdPrefix, 4 + index * 4, 'Statusmaske' + suffix, 'Number_1_None', 1)); }); } else if (section.type === 14) { forEachPayload(function(index, suffix) { packetFieldSpecs.push(_this._createUInt8BlockTypeFieldSpecification(fieldIdPrefix, 4 + index, 'Segmentmaske' + suffix, 'Number_1_None', 1)); }); } _this.blockTypePacketSpecCache [sectionId] = _.extend({}, section.packetSpec, { packetId: section.surrogatePacketId, sectionId: sectionId, packetFields: packetFieldSpecs, }); } var packetSpec = _this.blockTypePacketSpecCache [sectionId]; memo.push(packetSpec); return memo; }, []); }, /** * Gets an array of PacketField objects for the provided BlockTypeSection objects. * * @param {BlockTypeSection[]} sections Array of BlockTypeSection objects. * @return {PacketField[]} Array of PacketField objects */ getBlockTypeFieldsForSections: function(sections) { var _this = this; var sectionByBlockTypeId = _.reduce(sections, function(memo, section) { memo [section.sectionId] = section; return memo; }, {}); var packetSpecs = this.getBlockTypePacketSpecificationsForSections(sections); var packetFields = []; _.forEach(packetSpecs, function(packetSpec) { _.forEach(packetSpec.packetFields, function(packetFieldSpec) { var section = sectionByBlockTypeId [packetSpec.sectionId]; var packetField = { id: packetSpec.packetId + '_' + packetFieldSpec.fieldId, section: section, packet: section.packet, packetSpec: packetSpec, packetFieldSpec: packetFieldSpec, origPacketFieldSpec: packetFieldSpec, }; packetFields.push(packetField); }); }); var language = this.language; _.forEach(packetFields, function(packetField) { var pfsName = packetField.packetFieldSpec.name; var name; if (_.isString(pfsName)) { var key = 'specificationData.packetFieldName.' + pfsName; name = _this.i18n.t(key); if (name === key) { name = pfsName; } } else if (_.isObject(pfsName)) { name = pfsName [language] || pfsName.en || pfsName.de || pfsName.ref; } var rawValue; if (packetField.packetFieldSpec &amp;&amp; packetField.section) { var frameData = packetField.section.frameData; rawValue = _this.getRawValue(packetField.packetFieldSpec, frameData); } _.extend(packetField, { name: name, rawValue: rawValue, formatTextValue: function(unit) { return _this.formatTextValueFromRawValue(packetField.packetFieldSpec, rawValue, unit); }, }); }); return packetFields; }, }, { loadSpecificationData: function(rawSpecificationData, options) { if (rawSpecificationData === undefined) { rawSpecificationData = {}; } if (options === undefined) { options = {}; } var rawFilteredPacketFieldSpecs = rawSpecificationData.filteredPacketFieldSpecs; var specification = options.specification || globalSpecification || {}; var specificationData = options.specificationData || specification.specificationData || globalSpecificationData || {}; var filteredPacketFieldSpecs; if (rawFilteredPacketFieldSpecs) { var resolve = function(value, collectionKey) { var collection = specificationData [collectionKey]; if (_.has(collection, value)) { value = collection [value]; } return value; }; filteredPacketFieldSpecs = _.map(rawFilteredPacketFieldSpecs, function(rfpfs) { var packetSpec = specification.getPacketSpecification(rfpfs.packetId); var packetFieldSpec = specification.getPacketFieldSpecification(packetSpec, rfpfs.fieldId); var name = rfpfs.name; if (typeof name === 'string') { name = { ref: name }; } return _.extend({}, rfpfs, { packetSpec: packetSpec, packetFieldSpec: packetFieldSpec, name: name, type: resolve(rfpfs.type, 'types'), conversions: rfpfs.conversions &amp;&amp; _.map(rfpfs.conversions, function(rawConversion) { return { factor: rawConversion.factor, offset: rawConversion.offset, sourceUnit: rawConversion.sourceUnit &amp;&amp; resolve(rawConversion.sourceUnit, 'units'), targetUnit: rawConversion.targetUnit &amp;&amp; resolve(rawConversion.targetUnit, 'units'), }; }), getRawValue: resolve(rfpfs.getRawValue, 'getRawValueFunctions'), setRawValue: resolve(rfpfs.setRawValue, 'setRawValueFunctions'), }); }); } var result = _.extend({}, specificationData, { filteredPacketFieldSpecs: filteredPacketFieldSpecs, }); return result; }, storeSpecificationData: function(options) { if (options === undefined) { options = {}; } if (options instanceof Specification) { options = { specification: options }; } var specification = options.specification || globalSpecification || {}; var specificationData = options.specificationData || specification.specificationData || globalSpecificationData || {}; var filteredPacketFieldSpecs = options.filteredPacketFieldSpecs || specificationData.filteredPacketFieldSpecs; var rawFilteredPacketFieldSpecs; if (filteredPacketFieldSpecs) { var link = function(value, valueIdKey, collectionKey) { var collection = specificationData [collectionKey]; var valueId; if (valueIdKey) { valueId = value [valueIdKey]; } if (!valueId) { valueId = _.findKey(collection, function(refValue) { return (value === refValue); }); } if (valueId &amp;&amp; _.has(collection, valueId) &amp;&amp; (collection [valueId] === value)) { value = valueId; } return value; }; rawFilteredPacketFieldSpecs = _.map(filteredPacketFieldSpecs, function(fpfs) { var rfpfs = { filteredPacketFieldId: fpfs.filteredPacketFieldId, packetId: fpfs.packetId, fieldId: fpfs.fieldId, name: fpfs.name, type: link(fpfs.type, 'typeId', 'types'), getRawValue: link(fpfs.getRawValue, null, 'getRawValueFunctions'), setRawValue: link(fpfs.setRawValue, null, 'setRawValueFunctions'), }; if (fpfs.conversions) { rfpfs.conversions = _.map(fpfs.conversions, function(conversion) { var rawConversion = {}; if (_.isNumber(conversion.factor)) { rawConversion.factor = conversion.factor; } if (_.isNumber(conversion.offset)) { rawConversion.offset = conversion.offset; } if (conversion.sourceUnit) { rawConversion.sourceUnit = link(conversion.sourceUnit, 'unitId', 'units'); } if (conversion.targetUnit) { rawConversion.targetUnit = link(conversion.targetUnit, 'unitId', 'units'); } return rawConversion; }); } return rfpfs; }); } var rawSpecificationData = { filteredPacketFieldSpecs: rawFilteredPacketFieldSpecs, }; return rawSpecificationData; }, getDefaultSpecification: function() { return globalSpecification; }, }); globalSpecification = new Specification(); module.exports = Specification; × Search results Close "},"configuration-optimizer.js.html":{"id":"configuration-optimizer.js.html","title":"Source: configuration-optimizer.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: configuration-optimizer.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var Q = require('q'); var extend = require('./extend'); /** * @typedef ConfigurationValue * @type {object} * @property {String} valueId Value ID * @property {number} valueIndex Value Index * @property {number} value Value * @property {number} priority Priority (higher numbers mean higher priority) * @property {boolean} pending Indicates that this value has to be tranceived. * @property {boolean} transceived Indicates that this value has been tranceived. */ /** * @typedef Configuration * @type {ConfigurationValue[]} */ var ConfigurationOptimizer = extend(null, /** @lends ConfigurationOptimizer# */ { constructor: function(options) { // nop }, /** * Converts the configurations provided into an array of {@see ConfigurationValue} objects. * The provided configurations can be either an array of partially initialized ConfigurationValue * objects or an object mapping value IDs as keys to values. * If no configuration is given a complete configuration set is returned. * * @param {array|object} configs... Configurations to complete. * @returns {Promise} A Promise that resolves to the completed array of values. */ completeConfiguration: function(config) { throw new Error('Must be implemented by sub-class'); }, /** * Gets the optimized array of values based on what values are already loaded. * * @param {array} config The array of values that has already been loaded. * @returns {Promise} A Promise that resolves to the array of values to load next. */ optimizeLoadConfiguration: function(config) { throw new Error('Must be implemented by sub-class'); }, /** * Gets the optimzed array of values to save to the controller. * * @param {array} newConfig The array of values to transfer. * @param {array} oldConfig The array of values that are assumed to be currently stored in the device. * @returns {Promise} A Promise that resolves to the array of values to save. */ optimizeSaveConfiguration: function(newConfig, oldConfig) { throw new Error('Must be implemented by sub-class'); }, /** * Get the array of `ConfigurationValue` objects to set the current date / time to the controller. * * @param {string} timezone Timezone the controller is in * @return {Promise} A Promise that resolves to the array of values to set the clock. */ generateClockConfiguration: function(timezone) { throw new Error('Must be implemented by sub-class'); }, }, { deviceAddress: null, /** * Get an array of possible options for calling this `ConfigurationOptimizer`'s constructor. * * @return {Promise} A promise that resolves to an array of constructor options. */ getOptimizerOptions: function() { var _this = this; return Q.fcall(function() { if (_this.deviceAddress !== null) { return [ null ]; } else { throw new Error('Must be implemented by sub-class'); } }); }, /** * Find settings for this `ConfigurationOptimizer`'s constructor that matches the given options best. * * @param {object} options Options to look for while searching a matching configuration optimizer. * @param {string} options.id The identifier for the `ConfigurationOptimizer`. * @param {number} options.deviceAddress The VBus address of the controller. * @param {string} options.version The version of the controller. * @param {Customizer} options.customizer A `Customizer` instance to query additional information with. * @return {Promise} A Promise that resolves to the best matching optimizer result or `null` if no match was found. */ matchOptimizer: function(options) { var _this = this; return Q.fcall(function() { if (_this.deviceAddress !== null) { var match = (options.deviceAddress === _this.deviceAddress) ? 1 : 0; return { match: match, Optimizer: _this, options: null, }; } else { throw new Error('Must be implemented by sub-class'); } }); }, }); module.exports = ConfigurationOptimizer; × Search results Close "},"configuration-optimizer-factory.js.html":{"id":"configuration-optimizer-factory.js.html","title":"Source: configuration-optimizer-factory.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: configuration-optimizer-factory.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var Q = require('q'); var utils = require('./utils'); var Promise = utils.promise; var optimizerClasses = [ // ====================================================================== // RESOL // ====================================================================== // DeltaSol BS4 v2 require('./configuration-optimizers/resol-deltasol-bs4v2-103-configuration-optimizer'), // DeltaSol BX Plus require('./configuration-optimizers/resol-deltasol-bx-plus-xxx-configuration-optimizer'), // DeltaSol CS Plus require('./configuration-optimizers/resol-deltasol-cs-plus-xxx-configuration-optimizer'), // DeltaSol MX require('./configuration-optimizers/resol-deltasol-mx-112-configuration-optimizer'), // DeltaSol SLT require('./configuration-optimizers/resol-deltasol-slt-102-configuration-optimizer'), // DeltaTherm HC require('./configuration-optimizers/resol-deltatherm-hc-xxx-configuration-optimizer'), ]; var ConfigurationOptimizerFactory = { /** * Find a `ConfigurationOptimizer` sub-class that matches the given options best. * * @param {object} options Options to look for while searching a matching configuration optimizer. * @param {number} options.deviceAddress The VBus address of the controller. * @param {string} options.version The version of the controller. * @param {Customizer} options.customizer A `Customizer` instance to query additional information with. * @return {Promise} A Promise that resolves to the best matching optimizer result or `null` if no match was found. */ matchOptimizer: function(options) { return new Promise(function(resolve, reject) { options = _.defaults({}, options); var result = { match: 0, Optimizer: null, options: null, }; var cache = { masterAddress: null, masterConfiguration: [], }; var index = 0; var nextOptimizer = function() { if (index &lt; optimizerClasses.length) { var Optimizer = optimizerClasses [index++]; Q.fcall(function() { return Optimizer.matchOptimizer(options, cache); }).then(function(refResult) { if ((refResult.match &gt; 0) &amp;&amp; (refResult.match &gt; result.match)) { result = refResult; } nextOptimizer(); }).then(null, reject).done(); } else { if (result.match &gt; 0) { resolve(result); } else { resolve(null); } } }; nextOptimizer(); }); }, /** * Find and create an instance of a `ConfigurationOptimizer` sub-class that matches the given options best. * * @param {object} options See {@link ConfigurationOptimizerFactory.matchOptimizer} for details. * @return {Promise} A promise that resolves to the `ConfigurationOptimizer` instance or `null` if no matching optimizer was found. */ createOptimizer: function(options) { return Q.fcall(function() { return ConfigurationOptimizerFactory.matchOptimizer(options); }).then(function(result) { var optimizer; if (result) { optimizer = new result.Optimizer(result.options); } else { optimizer = null; } return optimizer; }); }, /** * Get the configuration optimizer for the given device (identified by its address). * * @param {number} deviceAddress VBus address of the device * @returns {Promise} A Promise that resolvs to the optimizer for the given device or `null` if no optimizer was found. */ createOptimizerByDeviceAddress: function(deviceAddress) { return ConfigurationOptimizerFactory.createOptimizer({ deviceAddress: deviceAddress, }); }, _optimizerClasses: optimizerClasses, }; module.exports = ConfigurationOptimizerFactory; × Search results Close "},"connection.js.html":{"id":"connection.js.html","title":"Source: connection.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: connection.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var EventEmitter = require('events').EventEmitter; var Duplex = require('stream').Duplex; var _ = require('lodash'); var Q = require('q'); var extend = require('./extend'); var Header = require('./header'); var Packet = require('./packet'); var Datagram = require('./datagram'); var Telegram = require('./telegram'); var utils = require('./utils'); var states = _.reduce([ 'DISCONNECTED', 'CONNECTING', 'CONNECTED', 'INTERRUPTED', 'RECONNECTING', 'DISCONNECTING', ], function(memo, state) { memo ['STATE_' + state] = state; return memo; }, {}); var optionKeys = [ 'channel', 'selfAddress', ]; var Connection = extend(Duplex, /** @lends Connection# */ { /** * Creates a new Connection instance and optionally initializes its member with the given values. * * @constructs * @augments Duplex * @param {object} options Initialization values for this instance's members * @param {number} options.channel See {@link Connection#channel} * @param {number} options.selfAddress See {@link Connection#selfAddress} * * @classdesc * The `Connection` class is the abstract base class for all VBus live data connections. * It extends the `Duplex` stream class. Any data written to a `Connection` instance is * parsed according to the VBus Protocol Specification. Once a valid instance of one of the * `Header` sub-classes (`Packet`, `Datagram` or `Telegram`) * is created from the binary data stream, the respective event is emitted on * the `Connection` instance. * * In addition to receiving incoming data the `Connection` class * offers several helper methods e.g. to send data to the underlying VBus connection. * * The `Connection` class itself has no knowledge about the underlying VBus connection. * Several sub-classes exist that know how to contact different types of VBus live streams. * * See `SerialConnection` or `TcpConnection` for concrete implementations. * * @example * var connection = new SerialConnection({ path: '/dev/tty.usbserial' }); * connection.on('connectionState', function(state) { * console.log(state); * }); * connection.on('packet', function(packet) { * console.log(packet.getId()); * }); * connection.on('datagram', function(datagram) { * console.log(datagram.getId()); * }); * connection.connect(); */ constructor: function(options) { Duplex.call(this); _.extend(this, _.pick(options, optionKeys)); }, /** * Reference to this instance's DataSource. * @type {DataSource} */ dataSource: null, /** * The VBus channel that this connection is established to. * All `Header` instances created by this `Connection` instance will be assigned * this VBus channel. * @type {number} */ channel: 0, /** * The VBus address used for sending information over this connection. * @type {number} */ selfAddress: 0x0020, /** * The current connection state. * @type {string} */ connectionState: states.STATE_DISCONNECTED, /** * The internal receive buffer of this conneciton. * @type {Buffer} */ rxBuffer: null, /** * Establish underlying connection and start streaming data to the writable side * of this `Connection` instance's stream. * * @abstract * @returns {Promise} A promise that resolves once the connection has been established. */ connect: function(force) { throw new Error('Must be implemented by sub-class'); }, /** * Diconnect this instance. * @abstract */ disconnect: function() { throw new Error('Must be implemented by sub-class'); }, _write: function(chunk, encoding, callback) { this.receive(new Date(), chunk); if (callback) { callback(null); } }, receive: function(timestamp, chunk) { var _this = this; if (EventEmitter.listenerCount(this, 'rawData') &gt; 0) { this.emit('rawData', chunk, timestamp); } var buffer; if (this.rxBuffer) { buffer = Buffer.concat([ this.rxBuffer, chunk ]); } else { buffer = chunk; } var processed = 0; var reportJunk = function(index) { if (index &gt; processed) { if (EventEmitter.listenerCount(_this, 'junkData') &gt; 0) { var junkData = buffer.slice(processed, index); _this.emit('junkData', junkData, timestamp); } } }; // console.log('_write (start):', this.rxBuffer, chunk); var index = 0, start = null; while (index &lt; buffer.length) { var b = buffer [index] &amp; 255; if (b === 0xAA) { reportJunk(index); start = index; processed = index; } else if (b &gt;= 0x80) { start = null; } else if (start === null) { // skip junk } else if (index &gt;= start + 5) { var version = buffer [start + 5] &amp; 255; var majorVersion = version &gt;&gt; 4; var length; if (majorVersion === 1) { if (index &gt;= start + 8) { length = 10 + buffer [start + 8] * 6; } else { length = 10; } } else if (majorVersion === 2) { length = 16; } else if (majorVersion === 3) { if (index &gt;= start + 6) { length = 8 + Telegram.getFrameCountForCommand(buffer [start + 6]) * 9; } else { length = 8; } } else { length = 0; } if (index === start + length - 1) { var valid = true, frameIndex; if (version === 0x10) { if (!Header.calcAndCompareChecksumV0(buffer, start + 1, start + 9)) { // console.log('checksum error in header'); valid = false; } frameIndex = start + 10; while (valid &amp;&amp; (frameIndex &lt; start + length)) { if (!Header.calcAndCompareChecksumV0(buffer, frameIndex, frameIndex + 5)) { // console.log('checksum error in frame index ' + frameIndex); valid = false; } frameIndex += 6; } } else if (version === 0x20) { if (!Header.calcAndCompareChecksumV0(buffer, start + 1, start + 15)) { valid = false; } } else if (version === 0x30) { if (!Header.calcAndCompareChecksumV0(buffer, start + 1, start + 7)) { valid = false; } frameIndex = start + 8; while (valid &amp;&amp; (frameIndex &lt; start + length)) { if (!Header.calcAndCompareChecksumV0(buffer, frameIndex, frameIndex + 8)) { valid = false; } frameIndex += 9; } } else { valid = false; } if (valid) { if (majorVersion === 1) { if (EventEmitter.listenerCount(this, 'packet') &gt; 0) { var packet = Packet.fromLiveBuffer(buffer, start, index); packet.timestamp = new Date(timestamp); packet.channel = this.channel; this.emit('packet', packet); } } else if (majorVersion === 2) { if (EventEmitter.listenerCount(this, 'datagram') &gt; 0) { var datagram = Datagram.fromLiveBuffer(buffer, start, index); datagram.timestamp = new Date(timestamp); datagram.channel = this.channel; this.emit('datagram', datagram); } } else if (majorVersion === 3) { if (EventEmitter.listenerCount(this, 'telegram') &gt; 0) { var telegram = Telegram.fromLiveBuffer(buffer, start, index); telegram.timestamp = new Date(timestamp); telegram.channel = this.channel; this.emit('telegram', telegram); } } } else { reportJunk(index + 1); } start = null; processed = index + 1; } } index++; } var minProcessed = buffer.length - 1024; if (processed &lt; minProcessed) { reportJunk(minProcessed); processed = minProcessed; } if (processed &lt; buffer.length) { this.rxBuffer = buffer.slice(processed); } else { this.rxBuffer = null; } }, _read: function() { // nop }, _setConnectionState: function(newState) { if (this.connectionState !== newState) { this.connectionState = newState; this.rxBuffer = null; if (EventEmitter.listenerCount(this, 'connectionState') &gt; 0) { this.emit('connectionState', newState); } } }, /** * Send raw data over this Connection instance. * * @param {Header|Buffer} data The Header or Buffer instance to be sent. */ send: function(data) { if (data instanceof Header) { data = data.toLiveBuffer(); } return this.push(data); }, /** * Sends and / or receives a VBus data. * * @param {Header|Buffer} txData The Header or Buffer instance to be sent. * @param {object} options * @param {number} options.timeout Timeout in milliseconds after which the `txData` will be sent again * @param {number} options.timeoutIncr After each timeout retransmission the timeout value for the next try is increment by this value. * @param {number} options.tries After this number of tries the returned Promise will resolve with value `null`. * @param {?function} options.filterPacket Will be called when a Packet has been received with the Packet and a callback as arguments. * @param {?function} options.filterDatagram Will be called when a Datagram has been received with the Datagram and a callback as arguments. * @returns {Promise} A Promise that either resolves to the VBus data selected by one of the filter callbacks or `null` on timeout. */ transceive: function(txData, options) { var _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 0, tries: 1, }); var deferred = Q.defer(); var promise = deferred.promise; var timer, onPacket, onDatagram; var done = function(err, result) { if (timer) { clearTimeout(timer); timer = null; } if (onPacket) { _this.removeListener('packet', onPacket); onPacket = null; } if (onDatagram) { _this.removeListener('datagram', onDatagram); onDatagram = null; } if (deferred) { if (err) { deferred.reject(err); } else { deferred.resolve(result); } deferred = null; } }; if (options.filterPacket) { onPacket = function(rxPacket) { options.filterPacket(rxPacket, done); }; this.on('packet', onPacket); } if (options.filterDatagram) { onDatagram = function(rxDatagram) { options.filterDatagram(rxDatagram, done); }; this.on('datagram', onDatagram); } var tries = options.tries, timeout = options.timeout; var nextTry = function() { if (tries &gt; 0) { tries--; timer = setTimeout(nextTry, timeout); timeout += options.timeoutIncr; if (txData) { _this.send(txData); } } else { done(null, null); } }; process.nextTick(nextTry); return promise; }, /** * Waits for a VBus bus offering datagram (Command 0x0500). * * Returns a Promise that resolves with the Datagram or `null` if the method timed out. * @param {number} timeout=20000 Timeout in milliseconds * @returns {Promise} A Promise that resolves to the bus offering Datagram or `null` on timeout. */ waitForFreeBus: function(timeout) { var options = { tries: 1, timeout: timeout || 20000, }; options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.command === 0x0500) { done(null, rxDatagram); } }; return this.transceive(null, options); }, /** * Sends a VBus bus release datagram (Command 0x0600). * Returns a Promise that resolves with the first VBus packet received after the release or `null` on timeout. * * @param {number} address The VBus address of the master device to give the bus ownership back to. * @param {object} options * @param {number} options.tries=2 Number of tries to give the bus ownership back. * @param {number} options.timeout=1500 Time in milliseconds to wait between tries. */ releaseBus: function(address, options) { options = _.defaults({}, options, { tries: 2, timeout: 1500 }); var txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: 0x0600, valueId: 0, value: 0 }).toLiveBuffer(); options.filterPacket = function(rxPacket, done) { done(null, rxPacket); }; return this.transceive(txDatagram, options); }, /** * Sends a Datagram to get a value from a device. * Returns a Promise that resolves to the answer Datagram or `null` on timeout. * * @param {number} address The VBus address of the device to get the value from * @param {number} valueId The ID of the value to read from the device. * @param {object} options * @param {number} options.timeout=500 Time in milliseconds between tries. * @param {number} options.timeoutIncr=500 Additional time in milliseconds to increase the timeout per try. * @param {number} options.tries=3 Number of tries to get the value. * @returns {Promise} A promise that resolves to the received Datagram or `null` on timeout. */ getValueById: function(address, valueId, options) { var _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 500, tries: 3, }); var txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: 0x0300, valueId: valueId, value: 0 }).toLiveBuffer(); options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.destinationAddress !== _this.selfAddress) { // nop } else if (rxDatagram.sourceAddress !== address) { // nop } else if (rxDatagram.command !== 0x0100) { // nop } else if (rxDatagram.valueId !== valueId) { // nop } else { done(null, rxDatagram); } }; return this.transceive(txDatagram, options); }, /** * Sends a Datagram to set a value in a device. * Returns a Promise that resolves to the answer Datagram or `null` on timeout. * * @param {number} address The VBus address of the device to set the value in * @param {number} valueId The ID of the value to write to the device. * @param {number} value The value to write to the device. * @param {object} options * @param {number} options.timeout=500 Time in milliseconds between tries. * @param {number} options.timeoutIncr=500 Additional time in milliseconds to increase the timeout per try. * @param {number} options.tries=3 Number of tries to get the value. * @returns {Promise} A promise that resolves to the received Datagram or `null` on timeout. */ setValueById: function(address, valueId, value, options) { var _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 500, tries: 3, save: false }); var txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: options.save ? 0x0400 : 0x0200, valueId: valueId, value: value }).toLiveBuffer(); options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.destinationAddress !== _this.selfAddress) { // nop } else if (rxDatagram.sourceAddress !== address) { // nop } else if (rxDatagram.command !== 0x0100) { // nop } else if (rxDatagram.valueId !== valueId) { // nop } else { done(null, rxDatagram); } }; return this.transceive(txDatagram, options); }, /** * Sends a Datagram to lookup a value ID hash in a device. * Returns a Promise that resolves to the answer Datagram or `null` on timeout. * * @param {number} address The VBus address of the device to lookup the value in. * @param {number} valueId The ID of the value to lookup in the device. * @param {object} options * @param {number} options.timeout=500 Time in milliseconds between tries. * @param {number} options.timeoutIncr=500 Additional time in milliseconds to increase the timeout per try. * @param {number} options.tries=3 Number of tries to lookup the value. * @return {Promise} A Promise the resolves to the received Datagram or `null` on timeout. */ getValueIdHashById: function(address, valueId, options) { var _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 500, tries: 3, }); var txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: 0x1000, valueId: valueId, value: 0 }).toLiveBuffer(); options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.destinationAddress !== _this.selfAddress) { // nop } else if (rxDatagram.sourceAddress !== address) { // nop } else if (rxDatagram.command !== 0x0100) { // nop } else if (rxDatagram.valueId !== valueId) { // nop } else { done(null, rxDatagram); } }; return this.transceive(txDatagram, options); }, /** * Sends a Datagram to lookup a value ID in a device. * Returns a Promise that resolves to the answer Datagram or `null` on timeout. * * @param {number} address The VBus address of the device to lookup the value in. * @param {number} valueIdHash The ID hash of the value to lookup in the device. * @param {object} options * @param {number} options.timeout=500 Time in milliseconds between tries. * @param {number} options.timeoutIncr=500 Additional time in milliseconds to increase the timeout per try. * @param {number} options.tries=3 Number of tries to lookup the value. * @return {Promise} A Promise the resolves to the received Datagram or `null` on timeout. */ getValueIdByIdHash: function(address, valueIdHash, options) { var _this = this; options = _.defaults({}, options, { timeout: 500, timeoutIncr: 500, tries: 3, }); var txDatagram = new Datagram({ destinationAddress: address, sourceAddress: this.selfAddress, command: 0x1100, valueId: 0, value: valueIdHash }).toLiveBuffer(); options.filterDatagram = function(rxDatagram, done) { if (rxDatagram.destinationAddress !== _this.selfAddress) { // nop } else if (rxDatagram.sourceAddress !== address) { // nop } else if (rxDatagram.command !== 0x0100) { // nop } else if (rxDatagram.value !== valueIdHash) { // nop } else { done(null, rxDatagram); } }; return this.transceive(txDatagram, options); }, /** * Creates a promise that resolves when this Connection * instance is connected and rejects if it is disconnected. * If it is neither connected nor disconnected the promise * will stay pending until one of the states is entered. * * @returns {Promise} */ createConnectedPromise: function() { var _this = this; return utils.promise(function(resolve, reject) { var checkConnectionState = function(state) { if (state === Connection.STATE_DISCONNECTED) { reject(new Error(state)); return true; } else if (state === Connection.STATE_CONNECTED) { resolve(); return true; } else { return false; } }; if (!checkConnectionState(_this.connectionState)) { var onConnectionState = function(state) { if (checkConnectionState(state)) { _this.removeListener('connectionState', onConnectionState); } }; _this.on('connectionState', onConnectionState); } }); }, }, states); module.exports = Connection; × Search results Close "},"connection-customizer.js.html":{"id":"connection-customizer.js.html","title":"Source: connection-customizer.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: connection-customizer.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var Q = require('q'); var utils = require('./utils'); var Customizer = require('./customizer'); var optionKeys = [ 'connection', 'maxRounds', 'triesPerValue', 'timeoutPerValue', 'masterTimeout', ]; var ConnectionCustomizer = Customizer.extend(/** @lends ConnectionCustomizer# */ { /** * The connection to use for transfer of the configuration values. * @type {Connection} */ connection: null, /** * Maximum number of optimization rounds for {@link transceiveConfiguration}. * @type {number} * @default 10 */ maxRounds: 10, /** * Amount of retries to transceive one value. * Between two tries the VBus is released and then re-acquired. * @type {number} * @default 2 */ triesPerValue: 2, /** * Timeout in milliseconds after which the transceive times out. * @type {number} * @default 30000 */ timeoutPerValue: 30000, /** * Interval in milliseconds in which * the VBus master is contacted to reissue the VBus clearance. * @type {number} * @default 8000 */ masterTimeout: 8000, /** * Constructs a new ConnectionCustomizer instance and optionally initializes its * members with the given values. * * @constructs * @augments Customizer * @param {object} [options] Initialization values for this instance's members * @param {number} [options.connection] {@link ConnectionCustomizer#connection} * @param {number} [options.maxRounds] {@link ConnectionCustomizer#maxRounds} * @param {number} [options.triesPerValue] {@link ConnectionCustomizer#triesPerValue} * @param {number} [options.timeoutPerValue] {@link ConnectionCustomizer#timeoutPerValue} * @param {number} [options.masterTimeout] {@link ConnectionCustomizer#masterTimeout} * * @classdesc * A ConnectionCustomizer uses an established connection to a device * to transfer sets of configuration values over it. */ constructor: function(options) { Customizer.apply(this, arguments); _.extend(this, _.pick(options, optionKeys)); }, /** * Load a set of configuration values from a device. * * See {@link Customizer#loadConfiguration} for details. */ _loadConfiguration: function(configuration, options) { var _this = this; options = _.defaults({}, options, { action: 'get', }); return Q.fcall(function() { var callback = function(config, round) { if (options.optimize) { return _this._optimizeLoadConfiguration(config); } else { if (round === 1) { _.forEach(configuration, function(value) { value.pending = true; }); return configuration; } else { return config; } } }; return _this.transceiveConfiguration(options, callback); }); }, /** * Save a set of configuration values to a device. * * See {@link Customizer#saveConfiguration} for details. */ _saveConfiguration: function(newConfiguration, oldConfigurstion, options) { var _this = this; options = _.defaults({}, options, { action: 'set', actionOptions: { save: true, }, }); return Q.fcall(function() { var callback = function(config, round) { if (options.optimize) { if (round === 1) { return _this._optimizeSaveConfiguration(newConfiguration, oldConfigurstion); } else { return _this._optimizeSaveConfiguration(newConfiguration, config); } } else { if (round === 1) { _.forEach(newConfiguration, function(value) { value.pending = true; }); return newConfiguration; } else { return config; } } }; return _this.transceiveConfiguration(options, callback); }); }, /** * Transceives a controller configuration set, handling timeouts, retries etc. * * @param {object} options Options * @param {number} [options.maxRounds] {@link ConnectionCustomizer#maxRounds} * @param {number} [options.triesPerValue] {@link ConnectionCustomizer#triesPerValue} * @param {number} [options.timeoutPerValue] {@link ConnectionCustomizer#timeoutPerValue} * @param {number} [options.masterTimeout] {@link ConnectionCustomizer#masterTimeout} * @param {number} options.action Action to perform, can be `'get'` or `'set'`. * @param {number} [options.actionOptions] Options object to forward to the action to perform. * @return {object} Promise that resolves to the configuration or `null` on timeout. */ transceiveConfiguration: function(options, callback) { var _this = this; if (_.isFunction(options)) { callback = options; options = null; } options = _.defaults({}, options, { maxRounds: this.maxRounds, triesPerValue: this.triesPerValue, timeoutPerValue: this.timeoutPerValue, masterTimeout: this.masterTimeout, action: null, actionOptions: null, }); var connection = this.connection; var address = this.deviceAddress; return utils.cancelablePromise(function(resolve, reject, notify, checkCanceled) { var check = function(result) { return Q.fcall(function() { return checkCanceled(); }).then(function() { return connection.createConnectedPromise(); }).then(function() { return result; }); }; var config = null; var state = { masterAddress: null, masterLastContacted: null, }; var round = 0; var reportProgress = function(progress) { if (_.isString(progress)) { progress = { message: progress, }; } _.extend(progress, { round: round, }); notify(progress); }; var nextRound = function() { if (round &lt; options.maxRounds) { round++; Q.fcall(check).then(function() { reportProgress('OPTIMIZING_VALUES'); return callback(config, round); }).then(check).then(function(newConfig) { config = newConfig; var pendingValues = _.filter(config, function(value) { return value.pending; }); var index = 0; var nextValue = function() { if (index &lt; pendingValues.length) { var valueInfo = pendingValues [index++]; Q.fcall(check).then(function() { return _this.transceiveValue(valueInfo, valueInfo.value, { triesPerValue: options.triesPerValue, timeoutPerValue: options.timeoutPerValue, action: options.action, actionOptions: options.actionOptions, }, state).progress(function(progress) { progress = _.extend({}, progress, { valueId: valueInfo.valueId, valueIndex: valueInfo.valueIndex, valueIdHash: valueInfo.valueIdHash, valueNr: index, valueCount: pendingValues.length, }); reportProgress(progress); }); }).then(function(datagram) { valueInfo.pending = false; valueInfo.transceived = !!datagram; if (datagram) { valueInfo.value = datagram.value; } nextValue(); }).done(); } else { nextRound(config); } }; if (pendingValues.length &gt; 0) { process.nextTick(nextValue); } else { Q.fcall(function() { if (state.masterLastContacted !== null) { reportProgress('RELEASING_BUS'); return connection.releaseBus(address); } }).then(function() { resolve(config); }).done(); } }).fail(reject).done(); } else { resolve(null); } }; process.nextTick(nextRound); }); }, /** * Transceive a controller value over this connection, handling * timeouts, retries etc. * * @param {object|number} valueInfoOrIndex Value info object or value index * @param {number} valueInfo.valueIndex Value index * @param {number} valueInfo.valueIdHash Value ID hash * @param {number} value Value * @param {object} options Options * @param {number} options.triesPerValue {@link ConnectionCustomizer#triesPerValue} * @param {number} options.timeoutPerValue {@link ConnectionCustomizer#timeoutPerValue} * @param {number} options.masterTimeout {@link ConnectionCustomizer#masterTimeout} * @param {object} state State to share between multiple calls to this method. * @returns {object} Promise that resolves with the datagram received or `null` on timeout. */ transceiveValue: function(valueInfo, value, options, state) { if (!_.isObject(valueInfo)) { valueInfo = { valueIndex: valueInfo, }; } if (state === undefined) { state = {}; } options = _.defaults({}, options, { triesPerValue: this.triesPerValue, timeoutPerValue: this.timeoutPerValue, masterTimeout: this.masterTimeout, action: null, actionOptions: null, }); state = _.defaults(state, { masterAddress: this.deviceAddress, masterLastContacted: Date.now(), }); var connection = this.connection; var address = this.deviceAddress; return utils.cancelablePromise(function(resolve, reject, notify, checkCanceled) { var timer, onConnectionState; var done = function(err, result) { if (timer) { clearTimeout(timer); timer = null; } if (onConnectionState) { connection.removeListener('connectionState', onConnectionState); } if (err) { reject(err); } else { resolve(result); } }; var check = function(result) { return Q.fcall(function() { return checkCanceled(); }).then(function() { return connection.createConnectedPromise(); }).then(function() { return result; }); }; var tries = 0; var reportProgress = function(message) { notify({ message: message, tries: tries, valueIndex: valueInfo.valueIndex, valueInfo: valueInfo, }); }; var nextTry = function() { if (tries &lt; options.triesPerValue) { tries++; Q.fcall(check).then(function() { if ((tries &gt; 1) &amp;&amp; (state.masterLastContacted !== null)) { reportProgress('RELEASING_BUS'); state.masterLastContacted = null; return connection.releaseBus(state.masterAddress); } }).then(check).then(function() { if ((state.masterLastContacted === null) &amp;&amp; (options.masterTimeout !== null)) { reportProgress('WAITING_FOR_FREE_BUS'); return connection.waitForFreeBus().then(function(datagram) { // TODO: optional timeout? if (datagram) { state.masterAddress = datagram.sourceAddress; } else { state.masterAddress = null; } }); } }).then(check).then(function() { var contactMaster; if (state.masterAddress === null) { contactMaster = false; } else if (state.masterAddress === address) { contactMaster = false; } else if (state.masterLastContacted === null) { contactMaster = true; } else if ((Date.now() - state.masterLastContacted) &gt;= options.masterTimeout) { contactMaster = true; } else { contactMaster = false; } if (contactMaster) { reportProgress('CONTACTING_MASTER'); state.masterLastContacted = Date.now(); return connection.getValueById(state.masterAddress, 0, { timeout: 500, tries: 1, }); } }).then(check).then(function() { if (state.masterAddress === address) { state.masterLastContacted = Date.now(); } if (_.isNumber(valueInfo.valueIndex)) { // nop } else if (_.isNumber(valueInfo.valueIdHash)) { reportProgress('LOOKING_UP_VALUE'); return Q.fcall(function() { return connection.getValueIdByIdHash(address, valueInfo.valueIdHash, options.actionOptions); }).then(function(datagram) { if (datagram &amp;&amp; datagram.valueId) { valueInfo.valueIndex = datagram.valueId; } }); } }).then(check).then(function() { if (state.masterAddress === address) { state.masterLastContacted = Date.now(); } if (!_.isNumber(valueInfo.valueIndex)) { return null; } else if (options.action === 'get') { reportProgress('GETTING_VALUE'); return connection.getValueById(address, valueInfo.valueIndex, options.actionOptions); } else if (options.action === 'set') { reportProgress('SETTING_VALUE'); return connection.setValueById(address, valueInfo.valueIndex, value, options.actionOptions); } else { throw new Error('Unknown action &quot;' + options.action + '&quot;'); } }).then(function(datagram) { if (datagram) { done(null, datagram); } else { return nextTry(); } }).fail(function(reason) { done(reason); }).done(); } else { done(null, null); } }; var onTimeout = function() { done(null, null); }; process.nextTick(nextTry); timer = setTimeout(onTimeout, options.timeoutPerValue); }); } }); module.exports = ConnectionCustomizer; × Search results Close "},"customizer.js.html":{"id":"customizer.js.html","title":"Source: customizer.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: customizer.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var EventEmitter = require('events').EventEmitter; var _ = require('lodash'); var Q = require('q'); var extend = require('./extend'); var optionKeys = [ 'id', 'deviceAddress', 'optimizer', ]; var Customizer = extend(EventEmitter, /** @lends Customizer# */ { /** * An identifier for this customizer. * @type {string} */ id: null, /** * The VBus address of the device to customize. * @type {number} */ deviceAddress: 0, /** * A configuration optimizer. * @type {ConfigurationOptimizer} */ optimizer: null, /** * Creates a new Customizer instance and optionally initializes its members * with the given values. * * @constructs * @param {object} [options] Initialization values for this instance's members * @param {string} [options.id] {@link Customizer#id} * @param {string} [options.deviceAddress] {@link Customizer#deviceAddress} * @param {string} [options.optimizer] {@link Customizer#optimizer} * * @classdesc * A Customizer provides functionality to transfer a set of configuration * values from or to a device. */ constructor: function(options) { EventEmitter.call(this); _.extend(this, _.pick(options, optionKeys)); }, /** * Load a set of configuration values from a device. * * If the `Customizer` has an `optimizer` set, the `configuration` parameter * is passed to the optimizer's `completeConfiguration` method. Otherwise it must be an * array of `ConfigurationValue` objects. * * If `options.optimize` is &quot;truthy&quot; the list of `ConfigurationValue` objects is passed * into the optimizer's `optimizeLoadConfiguration` method to determine the minimal * set of values to transfer. If `options.optimize` is &quot;falsy&quot; all of the * `ConfigurationValue` objects will be loaded. * * @param {array} configuration The set of values to transfer. * @param {object} options * @returns {Promise} A Promise that resolves to the set of values transfered. */ loadConfiguration: function(configuration, options) { var _this = this; options = _.defaults({}, options, { optimize: true, }); return Q.fcall(function() { return _this._completeConfiguration(configuration); }).then(function(configuration) { return _this._loadConfiguration(configuration, options); }); }, _loadConfiguration: function(configuration, options) { throw new Error('Must be implemented by sub-class'); }, /** * Save a set of configuration values to a device. * * If the `Customizer` has an `optimizer` set, the `newConfiguration` parameter * is passed to the optimizer's `completeConfiguration` method. Otherwise it must be an * array of `ConfigurationValue` objects. * * If a `oldConfiguration` parameter is given, the same procedure as for the * `newConfiguration` is applied to it as well. * * If `options.optimize` is &quot;truthy&quot; the list of `ConfigurationValue` objects is passed * into the optimizer's `optimizeLoadConfiguration` method to determine the minimal * set of values to transfer. If `options.optimize` is &quot;falsy&quot; all of the * `ConfigurationValue` objects will be loaded. * * @param {array} newConfiguration The set of values to transfer. * @param {array} oldConfiguration The set of values to assume to be stored in the device. * @param {object} options * @returns {Promise} A Promise that resolves to the set of values transfered. */ saveConfiguration: function(newConfiguration, oldConfiguration, options) { var _this = this; options = _.defaults({}, options, { optimize: true, }); return Q.fcall(function() { return _this._completeConfiguration(newConfiguration); }).then(function(newConfiguration) { return Q.fcall(function() { if (oldConfiguration) { return _this._completeConfiguration(oldConfiguration); } else { return null; } }).then(function(oldConfiguration) { return _this._saveConfiguration(newConfiguration, oldConfiguration, options); }); }); }, _saveConfiguration: function(newConfiguration, oldConfiguration, options) { throw new Error('Must be implemented by sub-class'); }, /** * Converts the configuration provided into an array of {@see ConfigurationValue} objects. * The provided configuration can be either an array of partially initialized ConfigurationValue * objects or an object mapping value IDs as keys to values. * If no configuration is given a complete configuration set is returned. * * @param {undefined|null|array|object} config Configuration to complete. * @returns {Promise} A Promise that resolves to the completed array of values. */ _completeConfiguration: function(config) { if (this.optimizer) { return this.optimizer.completeConfiguration(config); } else { return Q(config); } }, /** * Gets the optimized array of values based on what values are already loaded. * * @param {array} config The array of values that has already been loaded. * @returns {Promise} A Promise that resolves to the array of values to load next. */ _optimizeLoadConfiguration: function(config) { return this.optimizer.optimizeLoadConfiguration(config); }, /** * Gets the optimzed array of values to save to the controller. * * @param {array} newConfig The array of values to transfer. * @param {array} oldConfig The array of values that are assumed to be currently stored in the device. * @returns {Promise} A Promise that resolves to the array of values to save. */ _optimizeSaveConfiguration: function(newConfig, oldConfig) { return this.optimizer.optimizeSaveConfiguration(newConfig, oldConfig); }, }); module.exports = Customizer; × Search results Close "},"converter.js.html":{"id":"converter.js.html","title":"Source: converter.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: converter.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var util = require('util'); var Duplex = require('stream').Duplex; var _ = require('lodash'); var Q = require('q'); var Header = require('./header'); var HeaderSet = require('./header-set'); var utils = require('./utils'); var extend = require('./extend'); var optionKeys = [ 'objectMode', ]; /** * @typedef RawData * @type {object} * @property {Number} channel VBus Channel number * @property {Date} startTimestamp Timestamp of the start of reception of this data * @property {Date} endTimestamp Timestamp of the end of reception of this data * @property {Buffer} buffer The VBus raw data buffer */ var Converter = extend(Duplex, /** @lends Converter# */ { /** * Specifies whether the underlying stream operates in object mode. * @type {boolean} */ objectMode: false, finishedPromise: null, /** * Creates a new Converter instance and optionally initializes its members with the given values. * * @constructs * @augments Duplex * @param {object} options Initialization values * @param {boolean} options.objectMode See {@link Converter#objectMode} * * @classdesc * Converter instances are streams that convert VBus models (Packet, Datagram and Telegram instances) and / or * Headerset instances to another representation. Optionally some Converter sub-classes support parsing that * representation back to the model instances. Converter sub-classes include VBusRecordingConverter (for * parsing and generating according to the VBus Recording File Format) and TextConverter that creates * character-separated text representations. */ constructor: function(options) { var _this = this; options = _.defaults({}, options); Duplex.call(this, { objectMode: options.objectMode, }); _.extend(this, _.pick(options, optionKeys)); this.finishedPromise = utils.promise(function(resolve) { // we have to add a data event handler to enable getting end event var onData = function() {}; _this.on('data', onData); _this.once('end', function() { _this.removeListener('data', onData); resolve(); }); }); }, /** * This method resets the converter. It should be used e.g. if the converter output switches between files (allows * some Converter sub-classes to correctly write a header). */ reset: function() { // nop }, /** * This method signals that no additional VBus Header or HeaderSet models will * be converted. It returns a promise that resolves when all data has been * consumed. * * @return {Promise} A Promise that resolves when all data has been consumed. */ finish: function() { var _this = this; return Q.fcall(function() { _this.push(null); return _this.finishedPromise; }); }, /** * This method queues a VBus raw data chunk from conversion. * Not all Converter sub-classes support this method. * * @param {RawData} rawData The VBus raw data chunk to queue for conversion. */ convertRawData: function(rawData) { if (this.objectMode) { this.push(rawData); } else { throw new Error('Must be implemented by sub-class'); } }, /** * This method queues a VBus Header model (Packet, Datagram or Telegram) for conversion. * Not all Converter sub-classes support this method. * * @param {Header} header The Header to queue for conversion. */ convertHeader: function(header) { if (this.objectMode) { this.push(header); } else { throw new Error('Must be implemented by sub-class'); } }, /** * This method queues a VBus HeaderSet instance for conversion. * Not all Converter sub-classes support this method. * * @param {HeaderSet} headerSet The HeaderSet to queue for conversion. */ convertHeaderSet: function(headerSet) { if (this.objectMode) { this.push(headerSet); } else { throw new Error('Must be implemented by sub-class'); } }, _read: function() { if (this.objectMode) { // nop } else { throw new Error('Must be implemented by sub-class'); } }, _write: function(chunk, encoding, callback) { if (this.objectMode) { if (chunk instanceof HeaderSet) { this.emit('headerSet', chunk); } else if (chunk instanceof Header) { this.emit('header', chunk); } else { throw new Error('Unsupported object found: ' + util.inspect(chunk)); } callback(); } else { throw new Error('Must be implemented by sub-class'); } }, }); module.exports = Converter; × Search results Close "},"datagram.js.html":{"id":"datagram.js.html","title":"Source: datagram.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: datagram.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var sprintf = require('sprintf').sprintf; var Header = require('./header'); var optionKeys = [ 'command', 'valueId', 'value', ]; var Datagram = Header.extend(/** @lends Datagram# */ { /** * The command field of this VBus datagram. See the VBus Protocol Specification for details. * @type {number} */ command: 0, /** * The value ID field of this VBus datagram. * @type {number} */ valueId: 0, /** * The value field of this VBus datagram. * @type {number} */ value: 0, /** * Creates a new Datagram instance and optionally initializes its members with the given values. * * @constructs * @augments Header * @param {object} options Initialization values for this instance's members * @param {number} options.command {@link Datagram#command} * @param {number} options.valueId {@link Datagram#valueId} * @param {Buffer} options.value {@link Datagram#value} * @see Header#constructor * * @classdesc * The Datagram sub-class provides access to all properties and methods applicable for VBus version 2 datagrams. * In addition to the packet header it may contain a command, a value ID and a value. * The value ID is a device-specific reference to one of the values presented in the device's menu interface. */ constructor: function(options) { Header.call(this, options); _.extend(this, _.pick(options, optionKeys)); }, toLiveBuffer: function(origBuffer, start, end) { var length = 16; var buffer; if (origBuffer === undefined) { buffer = new Buffer(length); } else { buffer = origBuffer.slice(start, end); } if (buffer.length &lt; length) { throw new Error('Buffer too small'); } buffer [0] = 0xAA; buffer.writeUInt16LE(this.destinationAddress &amp; 0x7F7F, 1); buffer.writeUInt16LE(this.sourceAddress &amp; 0x7F7F, 3); buffer [5] = 0x20; buffer.writeUInt16LE(this.command &amp; 0x7F7F, 6); var frameData = new Buffer(6); frameData.writeUInt16LE(this.valueId, 0); frameData.writeInt32LE(this.value, 2); Datagram.extractSeptett(frameData, 0, 6, buffer, 8); Datagram.calcAndSetChecksumV0(buffer, 1, 15); return buffer; }, getProtocolVersion: function() { return 0x20; }, getInfo: function() { var info; if (this.command === 0x0900) { info = this.valueId; } else { info = 0; } return info; }, getId: function() { var baseId = Header.prototype.getId.call(this); var info = this.getInfo(); return sprintf('%s_%04X_%04X', baseId, this.command, info); }, compareTo: function(that) { var result = Header.prototype.compareTo.apply(this, arguments); if (result === 0) { result = this.command - that.command; } if (result === 0) { result = this.getInfo() - that.getInfo(); } return result; }, }, { fromLiveBuffer: function(buffer, start, end) { var frameData = new Buffer(6); Header.injectSeptett(buffer, start + 8, start + 14, frameData, 0); return new Datagram({ destinationAddress: buffer.readUInt16LE(start + 1), sourceAddress: buffer.readUInt16LE(start + 3), command: buffer.readUInt16LE(start + 6), valueId: frameData.readUInt16LE(0), value: frameData.readInt32LE(2) }); } }); module.exports = Datagram; × Search results Close "},"header.js.html":{"id":"header.js.html","title":"Source: header.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: header.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var sprintf = require('sprintf').sprintf; var extend = require('./extend'); var optionKeys = [ 'timestamp', 'channel', 'destinationAddress', 'sourceAddress', ]; var Header = extend(null, /** @lends Header# */ { /** * Timestamp of this header * @type {Date} * @default now */ timestamp: null, /** * VBus channel of this header * @type {number} * @default 0 */ channel: 0, /** * VBus address of this header's destination * @type {number} * @default 0 */ destinationAddress: 0, /** * VBus address of this header's source * @type {number} * @default */ sourceAddress: 0, /** * Creates a new Header instance and optionally initializes its members * with the given values * * @constructs * @param {object} [options] Initialization values for this instance's members * @param {Date} [options.timestamp] {@link Header#timestamp} * @param {number} [options.channel] {@link Header#channel} * @param {number} [options.destinationAddress] {@link Header#destinationAddress} * @param {number} [options.sourceAddress] {@link Header#sourceAddress} * * @classdesc * All VBus models are sub-classes of this Header class. The Header class provides * a generic interface and the common properties that all (currently three) * different types of VBus models can use. * * Header instances can either be created by calling the constructor function or * by passing a Buffer object containing the binary VBus data to the class method * `HeaderSubClass.fromLiveBuffer`. * * @see Packet * @see Datagram * @see Telegram */ constructor: function(options) { _.extend(this, _.pick(options, optionKeys)); if (!this.timestamp) { this.timestamp = new Date(); } }, /** * Creates a representation of this Header instance that can be * transmitted over a Connection. If no buffer is given as an * arguments, it creates a new one that is big enough to hold * the representation. * * Must be implemented by sub-class. * * @abstract * @param {Buffer} [buffer] Buffer object to store data in * @param {number} [start] Start index in the buffer * @param {number} [end] End index in the buffer * @returns {Buffer} Buffer object containing the data */ toLiveBuffer: function(/* buffer, start, end */) { throw new Error('Must be implemented by sub-class'); }, /** * Returns the protocol version of this Header instance as a 8-bit * number. The high nibble is used for the major version, the low * nibble for the minor version. For example: a header with protocol * version 2.0 would return `0x20`. * * Must be implemented by sub-class. * * @abstract * @returns {number} Protocol version */ getProtocolVersion: function() { throw new Error('Must be implemented by sub-class'); }, /** * Returns an info number about this Header instance. It can be used * for sorting purposes (to distinguish Header objects that would * otherwise compare as equal). * * @returns {number} Info value */ getInfo: function() { return 0; }, /** * Returns a string identifier describing this Header instance. * It contains at least: * * - channel * - destination address * - source address * - protocol version * * Sub-classes can extend that information. The structure of this * identifier is implementation specific, do not rely on it! * * @returns {string} Identifier */ getId: function() { return sprintf('%02X_%04X_%04X_%02X', this.channel, this.destinationAddress, this.sourceAddress, this.getProtocolVersion()); }, /** * Compares this Header instance to another one. * * Sub-classes can extend the comparison to include specific * information. * * @param {Header} that Another Header instance to compare to. * @returns {number} Returns a number * * - less than 0 if `this &lt; that` * - greater than 0 if `this &gt; that` * - equal to to if `this == that` */ compareTo: function(that) { var result = this.channel - that.channel; if (result === 0) { result = this.destinationAddress - that.destinationAddress; } if (result === 0) { result = this.sourceAddress - that.sourceAddress; } if (result === 0) { result = this.getProtocolVersion() - that.getProtocolVersion(); } return result; }, }, /** @lends Header */ { /** * Creates a Header instance from a representation that was * received over a Connection. * * Must be implemented by sub-class. * * @abstract * @param {Buffer} buffer Buffer that contains the representation * @param {number} start Start index in the buffer * @param {number} end End index in the buffer * @returns {Header} Header instance created from the representation */ fromLiveBuffer: function(/* buffer, start, end */) { throw new Error('Must be implemented by sub-class'); }, /** * Calculates the VBus checksum (according to version x.0 specification) * over a part of a Buffer instance. * * @param {Buffer} buffer Buffer to calc checksum for * @param {number} start Start index in the buffer * @param {number} end End index in the buffer * @returns {number} Calculated checksum */ calcChecksumV0: function(buffer, start, end) { var checksum = 0; for (var index = start; index &lt; end; index++) { checksum = (checksum + buffer [index]) &amp; 0x7F; } checksum = (0x7F - checksum); return checksum; }, /** * Calculates the VBus checksum (according to version x.0 specification) * over a part of a Buffer instance and compares it the checksum byte * stored at the `end` position. * * @param {Buffer} buffer Buffer to calc and compare checksum for * @param {number} start Start index in the buffer * @param {number} end End index in the buffer * @returns {boolean} Result whether calculated and stored checksum match */ calcAndCompareChecksumV0: function(buffer, start, end) { var checksum = this.calcChecksumV0(buffer, start, end); return (buffer [end] === checksum); }, /** * Calculates the VBus checksum (according to version x.0 specification) * over a part of the Buffer instance and stores it at the `end` position. * * @param {Buffer} buffer Buffer to calc and store checksum for * @param {number} start Start index in the buffer * @param {number} end End index in the buffer * @returns {number} Calculated checksum */ calcAndSetChecksumV0: function(buffer, start, end) { var checksum = this.calcChecksumV0(buffer, start, end); buffer [end] = checksum; return checksum; }, /** * Copies a part of the source Buffer instance to the destination Buffer * instance, injecting the MSBs stored in the septett byte during the process. * * @param {Buffer} srcBuffer Buffer to copy from * @param {number} srcStart Start index in the source buffer * @param {number} srcEnd End index in the source buffer * @param {Buffer} dstBuffer Buffer to copy to * @param {number} dstStart Start index in the destination buffer */ injectSeptett: function(srcBuffer, srcStart, srcEnd, dstBuffer, dstStart) { var srcIndex = srcStart, dstIndex = dstStart, mask = 1, septett = srcBuffer [srcEnd]; while (srcIndex &lt; srcEnd) { var b = srcBuffer [srcIndex]; if (septett &amp; mask) { b |= 0x80; } dstBuffer [dstIndex] = b; srcIndex++; dstIndex++; mask = mask &lt;&lt; 1; } }, /** * Copies a part of the source Buffer instance to the destination Buffer * instance, extracting the MSBs during the process and storing the septett * byte to the destination buffer's end position. * * @param {Buffer} srcBuffer Buffer to copy from * @param {number} srcStart Start index in the source buffer * @param {number} srcEnd End index in the source buffer * @param {Buffer} dstBuffer Buffer to copy to * @param {number} dstStart Start index in the destination buffer */ extractSeptett: function(srcBuffer, srcStart, srcEnd, dstBuffer, dstStart) { var srcIndex = srcStart, dstIndex = dstStart, mask = 1, septett = 0; while (srcIndex &lt; srcEnd) { var b = srcBuffer [srcIndex]; if (b &amp; 0x80) { b &amp;= 0x7F; septett |= mask; } dstBuffer [dstIndex] = b; srcIndex++; dstIndex++; mask = mask &lt;&lt; 1; } dstBuffer [dstIndex] = septett; } }); module.exports = Header; × Search results Close "},"dlx-json-converter.js.html":{"id":"dlx-json-converter.js.html","title":"Source: dlx-json-converter.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: dlx-json-converter.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var HeaderSet = require('./header-set'); var Specification = require('./specification'); var Converter = require('./converter'); var optionKeys = [ 'specification', 'statsOnly', ]; var DLxJsonConverter = Converter.extend(/** @lends DLxJsonConverter# */ { /** * Reference to the Specification instance that is used for the binary -&gt; text conversion. * @type {Specification} */ specification: null, statsOnly: false, allHeaderSet: null, emittedStart: false, stats: null, /** * Creates a new DLxJsonConverter instance and optionally initializes its members with the given values. * * @constructs * @augments Converter * @param {object} options Initialization values * @param {object} options.specification See {@link DLxJsonConverter#specification} * * @classdesc * The DLxJsonConverter class takes HeaderSet instances, converts them into JSON * representation and then publishes that on the readable stream side * of itself. The format of the JSON data is similar to the one that is generated * by the Dataloggers DL2 and DL3. * * It does not support parsing JSON content back into HeaderSet instances (the * writable stream side). */ constructor: function(options) { Converter.call(this, options); _.extend(this, _.pick(options, optionKeys)); if (!this.specification) { this.specification = new Specification({ language: options &amp;&amp; options.language || 'en' }); } this.allHeaderSet = new HeaderSet(); this.reset(); }, reset: function() { this.allHeaderSet.removeAllHeaders(); this.emittedStart = false; this.stats = { headerSetCount: 0, minTimestamp: null, maxTimestamp: null, }; }, finish: function() { this._emitEnd(); return Converter.prototype.finish.apply(this, arguments); }, convertHeaderSet: function(headerSet) { var headers = headerSet.getHeaders(); this.allHeaderSet.addHeaders(headers); if (!this.statsOnly) { this._convertHeaderSetToJson(headerSet); } var spec = this.specification; var i18n = spec.i18n; var now = i18n.moment(headerSet.timestamp); var timestamp = now.valueOf(); this.stats.headerSetCount++; if ((this.stats.minTimestamp === null) || (this.stats.minTimestamp &gt; timestamp)) { this.stats.minTimestamp = timestamp; } if ((this.stats.maxTimestamp === null) || (this.stats.maxTimestamp &lt; timestamp)) { this.stats.maxTimestamp = timestamp; } }, _convertHeaderSetToJson: function(headerSet) { var spec = this.specification; var i18n = spec.i18n; var headers = headerSet.getHeaders(); var packetFields = spec.getPacketFieldsForHeaders(headers); var now = i18n.moment(headerSet.timestamp); var allHeaders = this.allHeaderSet.getHeaders(); var packetInfoList = _.map(allHeaders, function(header, headerIndex) { return { header: header, headerIndex: headerIndex, packetFields: [], }; }); _.forEach(packetFields, function(packetField) { var headerIndex = allHeaders.indexOf(packetField.packet); if (headerIndex &gt;= 0) { var packetInfo = packetInfoList [headerIndex]; packetInfo.packetFields.push(packetField); } }); var noneUnit = spec.getUnitById('None'); var numberType = spec.getTypeById('Number'); var packetData = _.reduce(packetInfoList, function(memo, packetInfo) { if (packetInfo.packetFields.length &gt;= 0) { var fieldData = _.map(packetInfo.packetFields, function(packetField, packetFieldIndex) { var rawValue = packetField.rawValue; var precision = packetField.packetFieldSpec.type.precision; var numberValue = spec.formatTextValueFromRawValueInternal(rawValue, noneUnit, numberType, precision, noneUnit); rawValue = + numberValue; return { field_index: packetFieldIndex, raw_value: rawValue, value: packetField.formatTextValue('None'), }; }); memo.push({ header_index: packetInfo.headerIndex, timestamp: packetInfo.header.timestamp / 1000.0, field_values: fieldData, }); } return memo; }, []); var timestamp = now.valueOf(); var headerSetData = { timestamp: timestamp / 1000.0, packets: packetData, }; this._emitStart(); var content = [ (this.stats.headerSetCount &gt; 0) ? ',' : '', JSON.stringify(headerSetData), ].join(''); this.push(content); }, _emitStart: function() { if (!this.emittedStart) { this.emittedStart = true; this.push('{&quot;headersets&quot;:['); } }, _emitEnd: function() { var spec = this.specification; var allHeaders = this.allHeaderSet.getHeaders(); var allPacketFields = spec.getPacketFieldsForHeaders(allHeaders); var packetInfoList = _.map(allHeaders, function(header, headerIndex) { return { header: header, headerIndex: headerIndex, packetSpec: spec.getPacketSpecification(header), packetFields: [], }; }); _.forEach(allPacketFields, function(packetField) { var headerIndex = allHeaders.indexOf(packetField.packet); if (headerIndex &gt;= 0) { var packetInfo = packetInfoList [headerIndex]; packetInfo.packetFields.push(packetField); } }); var headersData = _.reduce(packetInfoList, function(memo, packetInfo, packetInfoIndex) { if (packetInfo.packetFields.length &gt;= 0) { var fieldsData = _.map(packetInfo.packetFields, function(packetField, packetFieldIndex) { return { id: packetField.packetFieldSpec.fieldId, filteredId: packetField.packetFieldSpec.filteredPacketFieldId, name: packetField.name, unit: packetField.packetFieldSpec.type.unit.unitText, unit_code: packetField.packetFieldSpec.type.unit.unitCode, }; }); var md; var packetSpec = packetInfo.packetSpec; var id = packetSpec.packetId; if ((md = /^(.._...._....)_10(_....)$/.exec(id)) !== null) { id = md [1] + md [2]; } var description = packetSpec.fullName; if ((md = /^(VBus )#([0-9]+:.*)$/.exec(description)) !== null) { description = md[1] + md [2]; } else { description = 'VBus 0: ' + description; } memo.push({ id: id, description: description, channel: packetSpec.channel, destination_address: packetSpec.destinationAddress, source_address: packetSpec.sourceAddress, protocol_version: packetSpec.protocolVersion, command: packetSpec.command, info: packetSpec.info, destination_name: packetSpec.destinationDevice.name, source_name: packetSpec.sourceDevice.name, fields: fieldsData, }); } return memo; }, []); var statsData = { headerset_count: this.stats.headerSetCount, min_timestamp : this.stats.minTimestamp / 1000.0, max_timestamp: this.stats.maxTimestamp / 1000.0, }; this._emitStart(); var content = [ '],&quot;headerset_stats&quot;:', JSON.stringify(statsData), ',&quot;headers&quot;:', JSON.stringify(headersData), ',&quot;language&quot;:&quot;', spec.i18n.language, '&quot;}' ].join(''); this.push(content); this.push(null); }, _read: function() { // nop }, }); module.exports = DLxJsonConverter; × Search results Close "},"dlx-recorder.js.html":{"id":"dlx-recorder.js.html","title":"Source: dlx-recorder.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: dlx-recorder.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var moment = require('moment'); var Q = require('q'); var request = require('request'); var utils = require('./utils'); var VBusRecordingConverter = require('./vbus-recording-converter'); var Recorder = require('./recorder'); var optionKeys = [ 'urlPrefix', 'username', 'password', ]; var DLxRecorder = Recorder.extend( /** @lends DLxRecorder# */ { /** * The root URL to access the DLx. * @type {string} */ urlPrefix: null, /** * The username to login to the web interface. * @type {string} */ username: 'admin', /** * The password to login to the web interface. * @type {string} */ password: 'admin', /** * Creates a new DLxRecorder instance. * @constructs * @augments Recorder * * @classdesc * DLxRecorder is a recorder that can play back data recorded by a Datalogger. */ constructor: function(options) { Recorder.call(this, options); _.extend(this, _.pick(options, optionKeys)); }, _getOptions: function() { var options = Recorder.prototype._getOptions.call(this); return _.extend(options, _.pick(this, optionKeys)); }, _playback: function(headerSetConsolidator, options) { var _this = this; var converter = new VBusRecordingConverter(); converter.on('headerSet', function(headerSet) { headerSetConsolidator.processHeaderSet(headerSet); }); return Q.fcall(function() { if (options.apiAccess) { return _this._playbackApi(converter, options); } else { return _this._playbackRaw(converter, options); } }).then(function() { converter.end(); }); }, _playbackRaw: function(converter, options) { var _this = this; var minFilename = moment.utc(options.minTimestamp).format('[/log/]YYYYMMDD'); var maxFilename = moment.utc(options.maxTimestamp).format('[/log/]YYYYMMDD'); return Q.fcall(function() { return _this.getRecordingFilenames(options); }).then(function(filenames) { return _.reduce(filenames, function(memo, filename) { var filenamePrefix = filename.slice(0, minFilename.length); if ((filenamePrefix &gt;= minFilename) &amp;&amp; (filenamePrefix &lt;= maxFilename)) { memo.push(filename); } return memo; }, []); }).then(function(filenames) { var promise = Q(); _.forEach(filenames, function(filename) { promise = promise.then(function() { var urlString = options.urlPrefix + filename; var urlOptions = { auth: { username: options.username, password: options.password, }, }; return _this.downloadToStream(urlString, urlOptions, converter); }); }); return promise; }); }, _playbackApi: function(converter, options) { var urlString = options.urlPrefix + '/dlx/download/download'; var urlOptions = { qs: { sessionAuthUsername: options.username, sessionAuthPassword: options.password, source: 'log', inputType: 'packets', outputType: 'vbus', sieveInterval: Math.round(options.interval / 1000) || 1, startDate: moment(options.minTimestamp).format('MM/DD/YYYY'), endDate: moment(options.maxTimestamp).format('MM/DD/YYYY'), dataLanguage: 'en', }, auth: { username: options.username, password: options.password, }, }; return Q.fcall(function() { return this.downloadToStream(urlString, urlOptions, converter); }); }, _playbackSyncJob: function(stream, syncJob) { var _this = this; if (!stream.objectMode) { throw new Error('Stream must be in object mode'); } /*var syncState =*/ this._getSyncState(syncJob, 'source', 'DLxRecorder'); return Q.fcall(function() { return _this.getLazyRecordingRanges(); }).then(function(availableRanges) { var ranges = Recorder.performRangeSetOperation(availableRanges, syncJob.syncStateDiffs, syncJob.interval, 'intersection'); var playedBackRanges = []; var promise = Q(); _.forEach(ranges, function(range) { var options = _.extend({}, syncJob, { minTimestamp: range.minTimestamp, maxTimestamp: range.maxTimestamp, end: false, }); promise = promise.then(function() { return _this.playback(stream, options); }).then(function(ranges) { playedBackRanges = Recorder.performRangeSetOperation(playedBackRanges, ranges, syncJob.interval, 'union'); }); }); promise = promise.then(function() { var handledRanges = playedBackRanges; if (handledRanges.length &gt; 0) { var maxTimestamp; if (syncJob.markGapsAsUnsynced) { maxTimestamp = handledRanges [0].minTimestamp; } else { maxTimestamp = handledRanges [handledRanges.length - 1].minTimestamp; } var notAvailableRanges = [{ minTimestamp: new Date(Date.UTC(2001, 0)), maxTimestamp: maxTimestamp, }]; handledRanges = Recorder.performRangeSetOperation(handledRanges, notAvailableRanges, syncJob.interval, 'union'); } _this._markSourceSyncRanges(handledRanges, syncJob); return playedBackRanges; }); return promise; }); }, getLazyRecordingRanges: function() { var _this = this; return Q.fcall(function() { return _this.getRecordingFilenames(); }).then(function(filenames) { var ranges = _.map(filenames, function(filename) { var minTimestamp = moment.utc(filename.slice(5, 13), 'YYYYMMDD'); var maxTimestamp = moment.utc(minTimestamp).add({ hours: 24 }); return { minTimestamp: minTimestamp.toDate(), maxTimestamp: maxTimestamp.toDate(), }; }); ranges = Recorder.performRangeSetOperation(ranges, [], 86400000, 'union'); return ranges; }); }, getRecordingFilenames: function() { return utils.promise(function(resolve, reject) { var rxBuffer = null; var filenames = []; var onResponse = function(res) { }; var onData = function(chunk) { var buffer; if (rxBuffer) { buffer = Buffer.concat([ rxBuffer, chunk ]); } else { buffer = chunk; } var string = buffer.toString('utf8'); var re = /&lt;a href=&quot;([0-9]{8}_[a-z]+.vbus)&quot;&gt;/g; var md, index; while ((md = re.exec(string)) !== null) { filenames.push('/log/' + md [1]); index = re.lastIndex; } string = string.slice(index); rxBuffer = new Buffer(string, 'utf8'); }; var onEnd = function() { resolve(filenames.sort()); }; var onError = function(err) { reject(err); }; var urlOptions = { auth: { username: this.username, password: this.password, }, }; var stream = this._request(this.urlPrefix + '/log/', urlOptions); stream.on('response', onResponse); stream.on('data', onData); stream.on('end', onEnd); stream.on('error', onError); }, this); }, getRecordingInfo: function(filename) { return utils.promise(function(resolve, reject) { var info = {}; var onResponse = function(res) { info.size = res.headers ['content-length'] | 0; info.etag = res.headers.etag; }; var onEnd = function() { resolve(info); }; var onError = function(err) { reject(err); }; var urlOptions = { method: 'HEAD', auth: { username: this.username, password: this.password, }, }; var stream = this._request(this.urlPrefix + filename, urlOptions); stream.resume(); stream.on('response', onResponse); stream.on('end', onEnd); stream.on('error', onError); }, this); }, downloadToStream: function(urlString, urlOptions, stream) { return utils.promise(function(resolve, reject) { var onEnd = function() { resolve(); }; var onError = function(err) { reject(err); }; var req = this._request(urlString, urlOptions); req.pipe(stream, { end: false }); req.on('end', onEnd); req.on('error', onError); }, this); }, _request: function() { return request.apply(undefined, arguments); }, }); module.exports = DLxRecorder; × Search results Close "},"recorder.js.html":{"id":"recorder.js.html","title":"Source: recorder.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: recorder.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var EventEmitter = require('events').EventEmitter; var _ = require('lodash'); var Q = require('q'); var extend = require('./extend'); var Header = require('./header'); var HeaderSet = require('./header-set'); var HeaderSetConsolidator = require('./header-set-consolidator'); var utils = require('./utils'); var optionKeys = [ 'id', 'minTimestamp', 'maxTimestamp', 'interval', 'timeToLive', ]; var Recorder = extend(EventEmitter, /** @lends Recorder# */ { /** * Identifier for this recorder instance. It may be used to reference * recorders, for example in sync data storage. * @type {string} */ id: null, /** * Minimum timestamp to use as a default during playback and * synchronization. * @type {Date} * @default '2001-01-01T00:00:00.000Z' */ minTimestamp: null, /** * Maximum timestamp to use as a default during playback and * synchronization. * @type {Date} * @default '2038-01-01T00:00:00.000Z' */ maxTimestamp: null, /** * Interval to be used as a default during playback and * synchronization. * @type {number} * @default 0 */ interval: 0, /** * Creates a new Recorder instance and optionally initializes * its members with the given values. * * @constructs * @param {object} options Initialization values for this instance's members * @param {string} options.id {@link Recorder#id} * @param {Date} options.minTimestamp {@link Recorder#minTimestamp} * @param {Date} options.maxTimestamp {@link Recorder#maxTimestamp} * @param {number} options.interval {@link Recorder#interval} * * @classdesc * A Recorder provides access to HeaderSet stores (e.g. dataloggers) by * allowing to either playback the HeaderSets in the store, record * HeaderSets to the store or synchronize two Recorders. * * The playback and record operation both use the VBusRecordingConverter * to serialize the HeaderSets to and from Node.js streams. * * The synchronization operation builds on top of this two operations * and is able to find unsynced HeaderSets in the source Recorder. * Thoses unsynced HeaderSets are then played back from the source Recorder * and recorded in the destination Recorder. * * The storage mechanism and format of the Recorder sub-classes is * implementation-specific to this class. */ constructor: function(options) { EventEmitter.call(this); _.extend(this, _.pick(options, optionKeys)); if (!this.id) { this.id = utils.generateGUID(); } if (!this.minTimestamp) { this.minTimestamp = new Date(Date.UTC(2001, 0)); } if (!this.maxTimestamp) { this.maxTimestamp = new Date(Date.UTC(2038, 0)); } }, _getOptions: function() { return _.extend({}, _.pick(this, optionKeys)); }, /** * Plays back a given range of HeaderSets. The stream must be in object mode. * * @param {Writable} stream A writable stream * @param {object} options Options to select and filter HeaderSets * @param {Date} [options.minTimestamp] {@link Recorder#minTimestamp} * @param {Date} [options.maxTimestamp] {@link Recorder#maxTimestamp} * @param {number} [options.interval] {@link Recorder#interval} * @param {boolean} [options.end=true] Whether the stream should be `end()`ed when the playback is complete */ playback: function(stream, options) { var _this = this; options = _.defaults({}, options, this._getOptions(), { end: true }); if (!stream.objectMode) { throw new Error('Stream must be in object mode'); } var headerSetConsolidator = new HeaderSetConsolidator({ minTimestamp: options.minTimestamp, maxTimestamp: options.maxTimestamp, interval: options.interval, }); var playedBackRanges = []; headerSetConsolidator.on('headerSet', function(headerSet) { var timestamp = headerSet.timestamp; var headerSetRange = { minTimestamp: timestamp, maxTimestamp: timestamp, }; playedBackRanges = Recorder.performRangeSetOperation(playedBackRanges, [ headerSetRange ], options.interval, 'union'); stream.write(headerSet); }); return Q.fcall(function() { return _this._playback(headerSetConsolidator, options); }).then(function() { if (options.end) { return utils.promise(function(resolve) { stream.end(function() { resolve(); }); }); } }).then(function() { return playedBackRanges; }); }, _playback: function(headerSetConsolidator, options) { throw new Error('Must be implemented by sub-class'); }, /** * Records a given range of HeaderSet instances. The stream must be in object mode. * * @param {Readable} stream A readable stream in object mode. * @param {object} options Options to select and filter HeaderSet instances. * @param {Date} [options.minTimestamp] See {@link Recorder#minTimestamp} * @param {Date} [options.maxTimestamp] See {@link Recorder#maxTimestamp} * @param {number} [options.interval] See {@link Recorder#interval} * @return {Promise} A Promise that resolves to the recorded ranges. */ record: function(stream, options) { var _this = this; options = _.defaults({}, options, this._getOptions(), { }); if (!stream.objectMode) { throw new Error('Stream must be in object mode'); } var headerSetConsolidator = new HeaderSetConsolidator({ minTimestamp: options.minTimestamp, maxTimestamp: options.maxTimestamp, interval: options.interval, timeToLive: options.timeToLive, }); var recordedRanges = []; headerSetConsolidator.on('headerSet', function(headerSet) { var timestamp = headerSet.timestamp; var headerSetRange = { minTimestamp: timestamp, maxTimestamp: timestamp, }; recordedRanges = Recorder.performRangeSetOperation(recordedRanges, [ headerSetRange ], options.interval, 'union'); }); var recordingJob = _.defaults({}, options, { recordedRanges: recordedRanges, }); return Q.fcall(function() { return _this._startRecording(headerSetConsolidator, recordingJob); }).then(function(recording) { return Q.fcall(function() { return utils.promise(function(resolve, reject) { var onData, onEnd, onError; var cleanup = function() { stream.removeListener('data', onData); stream.removeListener('end', onEnd); stream.removeListener('error', onError); }; onData = function(obj) { if (obj instanceof Header) { headerSetConsolidator.addHeader(obj); } else if (obj instanceof HeaderSet) { headerSetConsolidator.processHeaderSet(obj); } else { throw new Error('Unsupported object received by Recorder'); } }; onEnd = function() { cleanup(); resolve(); }; onError = function(err) { cleanup(); reject(err); }; stream.on('data', onData); stream.on('end', onEnd); stream.on('error', onError); stream.resume(); }); }).finally(function() { return _this._endRecording(headerSetConsolidator, recordingJob, recording); }); }).then(function() { return recordedRanges; }); }, _startRecording: function(headerSetConsolidator, recordingJob) { throw new Error('Must be implemented by sub-class'); }, _endRecording: function(headerSetConsolidator, recordingJob, recording) { throw new Error('Must be implemented by sub-class'); }, /** * Synchronize this Recorder's HeaderSets to another Recorder. * * @param {Recorder} recorder Destination Recorder * @param {object} options Options to select and filter HeaderSets * @param {Date} [options.minTimestamp] {@link Recorder#minTimestamp} * @param {Date} [options.maxTimestamp] {@link Recorder#maxTimestamp} * @param {number} [options.interval] {@link Recorder#interval} * @returns {Promise} Promise resolving with a list of ranges that were synchronized. */ synchronizeTo: function(recorder, options) { var _this = this; options = _.extend({}, this._getOptions(), options); return Q.fcall(function() { return recorder._getCurrentSyncState(options); }).then(function(oldSyncState) { oldSyncState = _.cloneDeep(oldSyncState); if (!oldSyncState.sourceSyncState) { oldSyncState.sourceSyncState = {}; } if (!oldSyncState.destinationSyncState) { oldSyncState.destinationSyncState = {}; } return _this._getSyncJob(oldSyncState, options); }).then(function(syncJob) { return recorder._recordSyncJob(_this, syncJob); }); }, _getCurrentSyncState: function(options) { throw new Error('Must be implemented by sub-class'); }, _getSyncJob: function(oldSyncState, options) { var syncJob = _.extend({}, options, { syncId: utils.generateGUID(), syncState: oldSyncState, syncStateDiffs: [], }); var syncState = this._getSyncState(syncJob, 'source', 'Recorder'); // migrate var syncVersion = syncState.version || 0; if (syncVersion === 0) { syncVersion = 1; syncState.rangesByInterval = {}; } syncState.version = syncVersion; if (!syncState.rangesByInterval [options.interval]) { syncState.rangesByInterval [options.interval] = []; } // find diffs var syncStateDiffs = syncJob.syncStateDiffs; syncStateDiffs.push({ minTimestamp: options.minTimestamp, maxTimestamp: options.maxTimestamp, }); _.forEach(syncState.rangesByInterval, function(ranges, rangesKey) { var interval = rangesKey | 0; if ((options.interval % interval) === 0) { ranges = _.map(ranges, function(range) { return { minTimestamp: Recorder.alignTimestampToInterval(range.minTimestamp, interval), maxTimestamp: Recorder.alignTimestampToInterval(range.maxTimestamp, interval) + interval, }; }); syncStateDiffs = Recorder.performRangeSetOperation(syncStateDiffs, ranges, interval, 'difference'); } }); syncJob.syncStateDiffs = syncStateDiffs; return Q(syncJob); }, /** * Starts a playback of the provided recorder, recording its data and returning a * Promise that resolves to the recorded ranges. * * @param {Recorder} recorder The recorder to use for playback * @param {RecorderSyncJob} syncJob The synchronization job to perform. * @returns {Promise} Promise resolving with a list of ranges that were synchronized. */ _recordSyncJob: function(recorder, syncJob) { throw new Error('Must be implemented by sub-class'); }, /** * Plays back the requested synchronization job, piping the resulting data into the * provided stream. Returns a Promise that resolves to the played back ranges. * * @param {Stream} stream The stream (in object mode) to pipe data into * @param {RecorderSyncJob} syncJob The synchronization job to perform. * @returns {Promise} Promise resolving with a list of ranges that were synchronized. */ _playbackSyncJob: function(stream, syncJob) { throw new Error('Must be implemented by sub-class'); }, _getSyncState: function(syncJobOrState, which, type) { var syncState; if (_.has(syncJobOrState, 'syncState') &amp;&amp; _.has(syncJobOrState, 'syncId')) { syncState = syncJobOrState.syncState; } else { syncState = syncJobOrState; } var syncStateKey = which + 'SyncState'; if (!_.has(syncState, syncStateKey)) { syncState [syncStateKey] = {}; } var syncStateRoot = syncState [syncStateKey]; if (!_.has(syncStateRoot, type)) { syncStateRoot [type] = {}; } return syncStateRoot [type]; }, _markSourceSyncRanges: function(ranges, syncJob) { var syncState = this._getSyncState(syncJob, 'source', 'Recorder'); var handledRanges = syncState.rangesByInterval [syncJob.interval]; handledRanges = Recorder.performRangeSetOperation(handledRanges, ranges, syncJob.interval, 'union'); syncState.rangesByInterval [syncJob.interval] = handledRanges; }, }, /** @lends Recorder. */ { alignTimestampToInterval: function(timestamp, interval) { if (typeof timestamp.getTime === 'function') { timestamp = timestamp.getTime(); } else if (typeof timestamp === 'string') { timestamp = new Date(timestamp).getTime(); } else if (typeof timestamp !== 'number') { throw new Error('Invalid timestamp &quot;' + timestamp + '&quot; (type &quot;' + typeof timestamp + '&quot;'); } if (_.isNumber(interval) &amp;&amp; (interval &gt; 0)) { return Math.floor(timestamp / interval) * interval; } else { return timestamp; } }, /** * Performs operations on two sets of timestamp ranges. * * Timestamp ranges are objects with two properties: `minTimestamp` and `maxTimestamp`. * * The operations correspond to the operations in mathematic's set theory. * Currently supported are union, difference and intersection. * * See [http://en.wikipedia.org/wiki/Set_theory]() for details. * * @param {Array} rangesA Set A containing timestamp ranges * @param {Array} rangesB Set B containing timestamp ranges * @param {number} interval Interval to allow between adjacent timestamp ranges * @param {string} operation Operation to perform, can be `'union'`, `'difference'` or `'intersection'` * @returns {Array} Set containing timestamp ranges after the operation */ performRangeSetOperation: function(rangesA, rangesB, interval, operation) { var newInfos = []; var calcBaseTimestamp = function(timestamp) { if (interval &gt; 0) { return Math.floor(timestamp / interval) * interval; } else { return timestamp; } }; var rangeToInfo = function(range) { var minTimestamp = range.minTimestamp; if (typeof minTimestamp.getTime === 'function') { minTimestamp = minTimestamp.getTime(); } else if (typeof minTimestamp === 'string') { minTimestamp = new Date(minTimestamp).getTime(); } else if (typeof minTimestamp !== 'number') { throw new Error('Invalid minTimestamp &quot;' + minTimestamp + '&quot; (type &quot;' + typeof minTimestamp + '&quot;'); } var maxTimestamp = range.maxTimestamp; if (typeof maxTimestamp.getTime === 'function') { maxTimestamp = maxTimestamp.getTime(); } else if (typeof maxTimestamp === 'string') { maxTimestamp = new Date(maxTimestamp).getTime(); } else if (typeof maxTimestamp !== 'number') { throw new Error('Invalid maxTimestamp &quot;' + maxTimestamp + '&quot; (type &quot;' + typeof maxTimestamp + '&quot;'); } var minBaseTimestamp = calcBaseTimestamp(minTimestamp); var maxBaseTimestamp = calcBaseTimestamp(maxTimestamp + interval); return { minTimestamp: minTimestamp, maxTimestamp: maxTimestamp, minBaseTimestamp: minBaseTimestamp, maxBaseTimestamp: maxBaseTimestamp, valid: true, }; }; var infoToRange = function(info) { var range; if (info &amp;&amp; info.valid) { range = { minTimestamp: new Date(info.minTimestamp), maxTimestamp: new Date(info.maxTimestamp), }; } return range; }; var processInfo = function(refInfo, operation) { if (!refInfo || !refInfo.valid || (refInfo.minTimestamp &gt; refInfo.maxTimestamp)) { return; } for (var i = 0; i &lt;= newInfos.length; i++) { var newInfo = newInfos [i]; var nextInfo; for (var j = i + 1; j &lt; newInfos.length; j++) { if (newInfos [j].valid) { nextInfo = newInfos [j]; break; } } var insert = false, deleteThis = false; if (newInfo &amp;&amp; !newInfo.valid) { // skip } else if (operation === 'union') { if (i === newInfos.length) { // append insert = true; } else if (refInfo.minBaseTimestamp &gt; newInfo.maxBaseTimestamp) { // skip } else if (refInfo.maxBaseTimestamp &lt; newInfo.minBaseTimestamp) { // insert insert = true; } else if (nextInfo &amp;&amp; (refInfo.maxBaseTimestamp &gt;= nextInfo.minBaseTimestamp)) { // union into next info if (refInfo.minTimestamp &gt; newInfo.minTimestamp) { refInfo.minTimestamp = newInfo.minTimestamp; } if (refInfo.minBaseTimestamp &gt; newInfo.minBaseTimestamp) { refInfo.minBaseTimestamp = newInfo.minBaseTimestamp; } newInfo.valid = false; } else { // union into this info if (newInfo.minTimestamp &gt; refInfo.minTimestamp) { newInfo.minTimestamp = refInfo.minTimestamp; } if (newInfo.maxTimestamp &lt; refInfo.maxTimestamp) { newInfo.maxTimestamp = refInfo.maxTimestamp; } if (newInfo.minBaseTimestamp &gt; refInfo.minBaseTimestamp) { newInfo.minBaseTimestamp = refInfo.minBaseTimestamp; } if (newInfo.maxBaseTimestamp &lt; refInfo.maxBaseTimestamp) { newInfo.maxBaseTimestamp = refInfo.maxBaseTimestamp; } break; } } else if (operation === 'difference') { if (i === newInfos.length) { // skip } else if (refInfo.minBaseTimestamp &gt; newInfo.maxBaseTimestamp) { // skip } else if (refInfo.maxBaseTimestamp &lt; newInfo.minBaseTimestamp) { // skip } else if (refInfo.minBaseTimestamp &lt;= newInfo.minBaseTimestamp) { if (refInfo.maxBaseTimestamp &gt;= newInfo.maxBaseTimestamp) { deleteThis = true; } else { if (newInfo.minTimestamp &lt; refInfo.maxTimestamp + 1) { newInfo.minTimestamp = refInfo.maxTimestamp + 1; } newInfo.minBaseTimestamp = refInfo.maxBaseTimestamp + 1; } } else if (refInfo.maxBaseTimestamp &gt;= newInfo.maxBaseTimestamp) { if (newInfo.maxTimestamp &gt; refInfo.minTimestamp - 1) { newInfo.maxTimestamp = refInfo.minTimestamp - 1; } newInfo.maxBaseTimestamp = refInfo.minBaseTimestamp - 1; } else { // split var splitInfo = { minTimestamp: newInfo.minTimestamp, maxTimestamp: refInfo.minTimestamp - 1, minBaseTimestamp: newInfo.minBaseTimestamp, maxBaseTimestamp: refInfo.minBaseTimestamp - 1, valid: true, }; newInfos.splice(i, 0, splitInfo); newInfo.minTimestamp = refInfo.maxBaseTimestamp + 1; newInfo.minBaseTimestamp = refInfo.maxBaseTimestamp + 1; break; } } else { throw new Error('Unknown set operation &quot;' + operation + '&quot;'); } if (insert) { newInfos.splice(i, 0, _.clone(refInfo)); break; } else if (deleteThis) { newInfo.valid = false; } } }; var processInfos = function(infos, operation) { _.forEach(_.clone(infos), function(info, index) { processInfo(info, operation); }); }; var infosA = _.map(rangesA, rangeToInfo); var infosB = _.map(rangesB, rangeToInfo); if (operation === 'intersection') { processInfos(infosA, 'union'); processInfos(infosB, 'difference'); var infosAMinusB = newInfos; newInfos = []; processInfos(infosB, 'union'); processInfos(infosA, 'difference'); var infosBMinusA = newInfos; newInfos = []; processInfos(infosA, 'union'); processInfos(infosB, 'union'); processInfos(infosAMinusB, 'difference'); processInfos(infosBMinusA, 'difference'); } else { _.forEach(infosA, function(info) { processInfo(info, 'union'); }); _.forEach(infosB, function(info) { processInfo(info, operation); }); } var newRanges = []; _.forEach(newInfos, function(newInfo) { var newRange = infoToRange(newInfo); if (newRange) { newRanges.push(newRange); } }); return newRanges; }, }); module.exports = Recorder; × Search results Close "},"extend.js.html":{"id":"extend.js.html","title":"Source: extend.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: extend.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); /** * A helper method for classical inheritance. * * @param {?function} parent Parent class constructor * @param {?object} protoProps Properties to be mixed-in the prototype of * the child class * @param {?object} staticProps Properties to be mixed-in the constructor * function of the child class * @returns {function} Child class constructor */ var extend = function(parent, protoProps, staticProps) { var child; if (protoProps &amp;&amp; _.has(protoProps, 'constructor')) { child = protoProps.constructor; } else if (parent) { child = function() { return parent.apply(this, arguments); }; } else { child = function() { // nop }; } _.extend(child, parent, staticProps); var Surrogate = function() { this.constructor = child; }; if (parent) { Surrogate.prototype = parent.prototype; } child.prototype = new Surrogate(); if (protoProps) { _.extend(child.prototype, protoProps); } if (parent) { child.__super__ = parent.prototype; } if (!_.has(child, 'extend')) { child.extend = function(protoProps, staticProps) { return extend(this, protoProps, staticProps); }; } return child; }; module.exports = extend; × Search results Close "},"header-set.js.html":{"id":"header-set.js.html","title":"Source: header-set.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: header-set.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var crypto = require('crypto'); var EventEmitter = require('events').EventEmitter; var _ = require('lodash'); var extend = require('./extend'); var idHashes = {}; var optionKeys = [ 'timestamp', ]; var HeaderSet = extend(EventEmitter, /** @lends HeaderSet# */ { /** * Timestamp of the youngest Header instance added to this set. * @type {Date} */ timestamp: null, /** * Array of Header instances in this set. * @type {Header[]} */ headerList: null, /** * Creates a new header set instance and optionally initializes its members with the given values. * * @constructs * @augments EventEmitter * @param {object} options Initialization values for this instance's members * @param {Date} options.timestamp {@link HeaderSet#timestamp} * @param {Header[]} options.headers Array of Headers to add to this instance */ constructor: function(options) { EventEmitter.call(this); this.headerList = []; _.extend(this, _.pick(options, optionKeys)); if (!this.timestamp) { this.timestamp = new Date(); } if (_.has(options, 'headers')) { this.addHeaders(options.headers); } }, _findIndex: function(header) { return _.findIndex(this.headerList, function(refHeader) { return (refHeader.compareTo(header) === 0); }); }, /** * Returns `true` if a Header of the same kind is already added to the HeaderSet. * * @params {Header} header The Header instance to check for. * @returns {boolean} `true` if a Header of the same kind is already in the HeaderSet, `false` otherwise. */ containsHeader: function(header) { var index = this._findIndex(header); return (index &gt;= 0); }, /** * Adds a Header instance to this set, replacing a previously added Header of same kind. * * @param {Header} header The Header instance to add to this set. */ addHeader: function(header) { var index = this._findIndex(header); if (index &gt;= 0) { this.headerList [index] = header; } else { this.headerList.push(header); } if (this.timestamp.getTime() &lt; header.timestamp.getTime()) { this.timestamp = header.timestamp; } /** * This event is fired whenever a Header instance is added to this set. * * @event HeaderSet#addHeader * @type {Header} */ this.emit('addHeader', header); }, /** * Adds a list of Header instances to this set, replacing previously added Headers of same kind. * * @param {Header[]} headers The list of Header instances to add. */ addHeaders: function(headers) { var _this = this; _.forEach(headers, function(header) { _this.addHeader(header); }); }, _removeHeader: function(header) { var index = this._findIndex(header); if (index &gt;= 0) { /** * This event is fired whenever a Header is removed from this set. * * @event HeaderSet#removeHeader * @type {Header} */ this.emit('removeHeader', this.headerList [index]); this.headerList.splice(index, 1); } }, _removeHeaders: function(headers) { var _this = this; _.forEach(headers, function(header) { _this._removeHeader(header); }); }, /** * Removes all Header instances from this set. */ removeAllHeaders: function() { this._removeHeaders(this.headerList.slice(0)); }, /** * Removes all Header instances from this set which are older than the given timestamp. * * @param {number|Date} timestamp Timestamp to compare Header instances against. */ removeHeadersOlderThan: function(timestamp) { var time; if (typeof timestamp === 'number') { time = timestamp; } else { time = timestamp.getTime(); } var headers = []; _.forEach(this.headerList, function(header) { if (header.timestamp.getTime() &lt; time) { headers.push(header); } }); this._removeHeaders(headers); }, /** * Returns the count of Header instances currently stored in this set. * * @returns {number} Number of Header instances in this set. */ getHeaderCount: function() { return this.headerList.length; }, /** * Returns an unsorted list of Header instances stored in this set. * * @returns {Header[]} List of headers stored in this set. */ getHeaders: function() { return this.headerList.slice(0); }, /** * Returns a sorted list of Header instances stored in this set. * * @returns {Header[]} List of headers stored in this set. */ getSortedHeaders: function() { var sortedHeaders = this.headerList.slice(0).sort(function(left, right) { return left.compareTo(right); }); return sortedHeaders; }, getSortedHeaderSet: function() { var headerSet = new HeaderSet({ headers: this.getSortedHeaders(), }); headerSet.timestamp = this.timestamp; return headerSet; }, /** * Returns an ID composed of the IDs of all headers stored in this set. * * @returns {string} ID of this HeaderSet. */ getId: function() { var sortedHeaders = this.getSortedHeaders(); var sortedIds = _.map(sortedHeaders, function(header) { return header.getId(); }); var id = sortedIds.join(','); return id; }, /** * Returns an ID hash for this HeaderSet instance. * * @returns {string} ID hash for this HeaderSet */ getIdHash: function() { var id = this.getId(); if (!_.has(idHashes, id)) { var shasum = crypto.createHash('sha256'); shasum.update(id); idHashes [id] = shasum.digest('hex'); } return idHashes [id]; }, }); module.exports = HeaderSet; × Search results Close "},"header-set-consolidator.js.html":{"id":"header-set-consolidator.js.html","title":"Source: header-set-consolidator.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: header-set-consolidator.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var HeaderSet = require('./header-set'); var optionKeys = [ 'interval', 'timeToLive', 'minTimestamp', 'maxTimestamp', ]; var HeaderSetConsolidator = HeaderSet.extend(/** @lends HeaderSetConsolidator# */ { /** * The interval in which the `headerSet` event should be emitted. * @type {number} */ interval: 0, /** * Header instances that are older then this duration are removed from the set. * @type {number} */ timeToLive: 0, /** * HeaderSet instances from a time before this Date are ignored. * @type {Date} */ minTimestamp: null, /** * HeaderSet instances from a time after this Date are ignored. * @type {Date} */ maxTimestamp: null, lastIntervalTime: 0, timer: null, /** * Creates a new instances and optionally initializes its members to the given values. * * @constructs * @augments HeaderSet * * @param {object} options * @param {number} options.interval See {@link HeaderSetConsolidator#interval} * @param {number} options.timeToLive See {@link HeaderSetConsolidator#timeToLive} * @param {number} options.minTimestamp See {@link HeaderSetConsolidator#minTimestamp} * @param {number} options.maxTimestamp See {@link HeaderSetConsolidator#maxTimestamp} * * @classdesc * The HeaderSetConsolidator extends the functionality of the HeaderSet class * by allowing to filter and organize the Header instances added to it. * * There are two common use cases for this class: * * The first use case is in combination with a Connection. As live Header instances * are reported by their corresponding event they are aded to the HeaderSetConsolidator * instance using `addHeader` or `addHeaders` methods. The `startTimer` method * is used to start a background timer that fires a `headerSet` event every * time the given interval has passed. * * The second use case is in combination with Recorders. In that case no timer * has to be started because the data is not received in real time. As recorded HeaderSet * instances are played back they are can be handed over to the `processHeaderSet` * method. This method will fire a `headerSet` event every time the recorded data * belong to a different interval. * * @example * * // --- use case 1: live data --- * var connection = createConnection(); * * // create a HeaderSetConsolidator that fires a headerSet event every minute * var hsc = new HeaderSetConsolidator({ interval: 1 * 60 * 1000 }); * * // add an event handlers to the connection that adds incoming headers to the consolidator * var onHeader = function(header) { * hsc.addHeader(header); * }; * * connection.on('packet', onHeader); * connection.on('datagram', onHeader); * connection.on('telegram', onHeader); * * // add an event handler to the consolidator * hsc.on('headerSet', function(headerSet) { * console.log(headerSet); * }); * * // start the timer * hsc.startTimer(); * * * * // --- use case 2: recorded data --- * var stream = getRecordedDataStream(); * * var converter = new VBusRecordingConverter(); * * // create a HeaderSetConsolidator that sieves incoming headers * var hsc = new HeaderSetConsolidator({ interval: 60 * 60 * 1000 }); * * // add an event handler to the converter that processes incoming header sets in the consolidator * converter.on('headerSet', function(headerSet) { * hsc.processHeaderSet(headerSet); * }); * * // add an event handler to the consolidator * hsc.on('headerSet', function(headerSet) { * console.log(headerSet); * }); * * // start the conversion * stream.pipe(converter); */ constructor: function(options) { HeaderSet.call(this, options); _.extend(this, _.pick(options, optionKeys)); }, /** * Starts a timer that processes live HeaderSets automatically. */ startTimer: function() { this.stopTimer(); this.lastIntervalTime = Date.now(); this._handleInterval(); }, /** * Stops the timer that was started by `startTimer`. */ stopTimer: function() { if (this.timer) { clearTimeout(this.timer); this.timer = null; } }, /** * Process the given HeaderSet instance. The Header instances in it are * added to the HeaderSetConsolidator. * * @param {HeaderSet} headerSet The HeaderSet instance to process. */ processHeaderSet: function(headerSet) { var now = headerSet.timestamp.getTime(); this.addHeaders(headerSet.getHeaders()); this._processHeaderSet(now); }, _handleInterval: function() { var _this = this; var now = Date.now(); this._processHeaderSet(now); var interval = 1000 - (now % 1000); this.timer = setTimeout(function() { _this._handleInterval(); }, interval); }, _processHeaderSet: function(now) { var include = true; if (this.minTimestamp) { if (now &lt; this.minTimestamp) { include = false; } } if (this.maxTimestamp) { if (now &gt; this.maxTimestamp) { include = false; } } if (this.interval &gt; 0) { var lastInterval = Math.floor(this.lastIntervalTime / this.interval); var currentInterval = Math.floor(now / this.interval); var diff = currentInterval - lastInterval; if ((diff &gt;= -1) &amp;&amp; (diff &lt;= 0)) { include = false; } } if (include) { if (this.timeToLive &gt; 0) { this.removeHeadersOlderThan(now - this.timeToLive); } this.timestamp = new Date(now); this.emit('headerSet', this); this.lastIntervalTime = now; } }, }); module.exports = HeaderSetConsolidator; × Search results Close "},"i18n.js.html":{"id":"i18n.js.html","title":"Source: i18n.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: i18n.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var moment = require('moment-timezone'); var numeral = require('numeral'); var sprintf = require('sprintf').sprintf; var extend = require('./extend'); var knownLanguages = { 'de': { moment: 'de', numeral: 'de', }, 'en': { moment: 'en', numeral: 'en', }, }; var resources = { dev: { translation: require('./locales/dev.json') }, de: { translation: require('./locales/de.json') }, }; numeral.language('de', require('numeral/languages/de')); var I18N = extend(null, /** @lends I18N# */ { language: null, languageData: null, timezone: null, /** * Creates a new I18N instance for the given language code. * * @constructs * @param {string} [language='en'] Language code (ISO 639-1) */ constructor: function(language) { if (!language || !_.has(knownLanguages, language)) { language = 'en'; } this.language = language; this.languageData = knownLanguages [language]; }, /** * Formats a string using a `printf(3)` compatible format string and * variadic arguments (comparable to `sprintf(3)`) and returns it. * * @param {string} fmt Format string * @param {...mixed} args Arguments to format * @returns {string} Formatted string * * @see http://linux.die.net/man/3/sprintf * @see http://www.diveintojavascript.com/projects/javascript-sprintf * * @example * // outputs: VBus #3: DeltaSol MX * console.log(i18n.sprintf('VBus #%d: %s', 3, 'DeltaSol MX')); * * // outputs: DeltaSol MX * console.log(i18n.sprintf('%2$s', 3, 'DeltaSol MX')); */ sprintf: function() { return sprintf.apply(null, arguments); }, /** * Formats a string using a `printf(3)` compatible format string and * a arguments array (comparable to `vsprintf(3)`) and returns it. * * @param {string} fmt Format string * @param {Array} argv Arguments to format * @returns {string} Formatted string * * @example * // outputs: VBus #3: DeltaSol MX * console.log(i18n.vsprintf('VBus #%d: %s', [ 3, 'DeltaSol MX' ])); * * // outputs: DeltaSol MX * console.log(i18n.vsprintf('%2$s', [ 3, 'DeltaSol MX' ])); */ vsprintf: function(fmt, argv) { var args = argv.slice(0); args.splice(0, 0, fmt); return sprintf.apply(null, args); }, /** * Get a translation for the given key. If more than one argument is * given, the translation is then used as a format string for the * {@link I18N#sprintf} method. * * @param {string} key Key for the translation * @param {...mixed} args Arguments to format * @return {string} Formatted string * * @example * var i18n = new I18N('de'); * * // outputs: Unbekanntes Gerät (0x%1$04X) * console.log(i18n.t('specification.unknownDevice')); * * // outputs: Unbekanntes Gerät (0x7E11) * console.log(i18n.t('specification.unknownDevice', 0x7e11)); */ t: function(key) { var parts = key.split('.'); var languages = [ this.language, 'dev' ]; var value; for (var i = 0; i &lt; languages.length; i++) { value = resources [languages [i]]; value = value &amp;&amp; value.translation; var j = 0; while (value &amp;&amp; (j &lt; parts.length)) { value = value [parts [j]]; j++; } if (value) { break; } } var text = value ? value : key; if (arguments.length &gt; 1) { var args = _.toArray(arguments).slice(1); text = this.vsprintf(text, args); } return text; }, /** * Wrapper for a moment.js date object that is setup to use this * instance's language code. * * @param {...mixed} args Arguments to be passed to `moment()` function * @returns {mixed} Result of calling the `moment()` function * * @see http://momentjs.com/docs/ */ moment: function() { var m = moment.apply(null, arguments).locale(this.languageData.moment); if (this.timezone) { m = m.tz(this.timezone); } return m; }, /** * Wrapper for a moment.js UTC date object that is setup to use this * instance's language code. * * @param {...mixed} args Arguments to be passed to `moment.utc()` function * @returns {mixed} Result of calling the `moment.utc()` function * * @see http://momentjs.com/docs/ */ momentUtc: function() { var m = moment.utc.apply(null, arguments).locale(this.languageData.moment); return m; }, momentTz: function() { var m = moment.tz.apply(moment, arguments).locale(this.languageData.moment); return m; }, momentTzZone: function() { var z = moment.tz.zone.apply(moment.tz, arguments); return z; }, /** * Wrapper for a numeral.js number object that is setup to use this * instance's language code. * * @param {...mixed} args Arguments to be passes to `numeral()` function * @returns {mixes} Result of calling the `numeral()` function * * @see http://numeraljs.com/ */ numeral: function() { numeral.language(this.languageData.numeral); return numeral.apply(null, arguments); }, }); module.exports = I18N; × Search results Close "},"packet.js.html":{"id":"packet.js.html","title":"Source: packet.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: packet.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var sprintf = require('sprintf').sprintf; var Header = require('./header'); var optionKeys = [ 'command', 'frameCount', ]; var Packet = Header.extend(/** @lends Packet# */ { /** * The command field of this VBus packet. See the VBus Protocol specification for details. * @type {number} */ command: 0, /** * The number of frames of this VBus packet. Each frame can hold four bytes of payload. * @type {number} */ frameCount: 0, /** * The buffer containing the frame data of this VBus packet. */ frameData: null, /** * Creates a new Packet instance and optionally initializes its members with the given values. * * @constructs * @augments Header * @param {object} options Initialization values for this instance's members * @param {number} options.command {@link Packet#command} * @param {number} options.frameCount {@link Packet#frameCount} * @param {Buffer} options.frameData {@link Packet#frameData} * @see Header#constructor * * @classdesc * The Packet sub-class provides access to all properties and methods applicable for VBus version 1 packets. * In addition to the packet header it may contain up to 508 bytes of payload data. * The structure of the payload depends on the combination of destination and source addresses as well as * the command of the packet. The different payloads are described in further detail * in Chapter H of the VBus Protocol Specification and can be decoded using a Specification instance. * * @see Specification */ constructor: function(options) { Header.call(this, options); _.extend(this, _.pick(options, optionKeys)); if (_.has(options, 'frameData') &amp;&amp; _.has(options, 'dontCopyFrameData') &amp;&amp; options.dontCopyFrameData) { this.frameData = options.frameData; } else { this.frameData = new Buffer(127 * 4); this.frameData.fill(0); if (_.has(options, 'frameData')) { var minLength = Math.min(this.frameData.length, options.frameData.length); options.frameData.copy(this.frameData, 0, 0, minLength); } } }, toLiveBuffer: function(origBuffer, start, end) { var length = 10 + this.frameCount * 6; var buffer; if (origBuffer === undefined) { buffer = new Buffer(length); } else if (start + length &lt;= end) { buffer = origBuffer.slice(start, start + length); } else { throw new Error('Buffer too small'); } buffer [0] = 0xAA; buffer.writeUInt16LE(this.destinationAddress &amp; 0x7F7F, 1); buffer.writeUInt16LE(this.sourceAddress &amp; 0x7F7F, 3); buffer [5] = 0x10; buffer.writeUInt16LE(this.command &amp; 0x7F7F, 6); buffer [8] = this.frameCount &amp; 0x7F; Packet.calcAndSetChecksumV0(buffer, 1, 9); for (var i = 0; i &lt; this.frameCount; i++) { var srcStart = 4 * i; var dstStart = 10 + 6 * i; Packet.extractSeptett(this.frameData, srcStart, srcStart + 4, buffer, dstStart); Packet.calcAndSetChecksumV0(buffer, dstStart, dstStart + 5); } return buffer; }, getProtocolVersion: function() { return 0x10; }, getId: function() { var baseId = Header.prototype.getId.call(this); return sprintf('%s_%04X', baseId, this.command); }, compareTo: function(that) { var result = Header.prototype.compareTo.apply(this, arguments); if (result === 0) { result = this.command - that.command; } return result; }, }, /** @lends Packet */ { fromLiveBuffer: function(buffer, start, end) { var frameCount = buffer [start + 8]; var frameData = new Buffer(127 * 4); frameData.fill(0); for (var frameIndex = 0; frameIndex &lt; frameCount; frameIndex++) { var sourceStart = start + 10 + frameIndex * 6; var targetStart = frameIndex * 4; Packet.injectSeptett(buffer, sourceStart, sourceStart + 4, frameData, targetStart); } return new Packet({ destinationAddress: buffer.readUInt16LE(start + 1), sourceAddress: buffer.readUInt16LE(start + 3), command: buffer.readUInt16LE(start + 6), frameCount: frameCount, frameData: frameData, dontCopyFrameData: true }); } }); module.exports = Packet; × Search results Close "},"serial-connection.js.html":{"id":"serial-connection.js.html","title":"Source: serial-connection.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: serial-connection.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var Q = require('q'); var SerialPort; try { SerialPort = require('serialport'); } catch (ex) { // eat it } var Connection = require('./connection'); var optionKeys = [ 'path', ]; var SerialConnection = Connection.extend(/** @lends SerialConnection# */ { /** * The path to the serial port. * @type {string} */ path: null, /** * Timeout in milliseconds to way between reconnection retries. * @type {number} */ reconnectTimeout: 0, /** * Value to increment timeout after every unsuccessful reconnection retry. * @type {number} */ reconnectTimeoutIncr: 10000, /** * Maximum timeout value between unsuccessful reconnection retry. * @type {number} */ reconnectTimeoutMax: 60000, serialPort: null, /** * Creates a new SerialConnection instance and optionally initialized its member with the given values. * * @constructs * @augments Connection * @param {object} options Initialization values * @param {string} options.path See {@link SerialConnection#path} * * @classdesc * The SerialConnection class provides asscess to a VBus live data stream using a serial port. */ constructor: function(options) { Connection.call(this, options); _.extend(this, _.pick(options, optionKeys)); }, connect: function() { if (this.connectionState !== SerialConnection.STATE_DISCONNECTED) { throw new Error('Connection is not disconnected (' + this.connectionState + ')'); } this._setConnectionState(SerialConnection.STATE_CONNECTING); return this._connect(); }, disconnect: function() { if (this.connectionState !== SerialConnection.STATE_DISCONNECTED) { var previousConnectionState = this.connectionState; this._setConnectionState(SerialConnection.STATE_DISCONNECTING); if (this.serialPort &amp;&amp; (previousConnectionState !== SerialConnection.STATE_CONNECTING)) { this.serialPort.close(); } else { this._setConnectionState(SerialConnection.STATE_DISCONNECTED); } } }, _connect: function() { var _this = this; var serialPort; var deferred = Q.defer(); var promise = deferred.promise; var done = function(err, result) { if (deferred) { if (err) { deferred.reject(err); } else { deferred.resolve(result); } deferred = null; } }; var onConnectionData = function(chunk) { serialPort.write(chunk); }; var onSerialPortData = function(chunk) { _this._write(chunk); }; var onSerialPortTermination = function() { _this.removeListener('data', onConnectionData); if (_this.serialPort !== serialPort) { // nop } else if (_this.connectionState === SerialConnection.STATE_CONNECTING) { _this._setConnectionState(SerialConnection.STATE_DISCONNECTED); _this.serialPort = null; done(new Error('Unable to connect')); } else if (_this.connectionState === SerialConnection.STATE_DISCONNECTING) { _this._setConnectionState(SerialConnection.STATE_DISCONNECTED); _this.serialPort = null; } else { _this._setConnectionState(SerialConnection.STATE_INTERRUPTED); _this.serialPort = null; var timeout = _this.reconnectTimeout; if (_this.reconnectTimeout &lt; _this.reconnectTimeoutMax) { _this.reconnectTimeout += _this.reconnectTimeoutIncr; } setTimeout(function() { _this._setConnectionState(SerialConnection.STATE_RECONNECTING); _this._connect(); }, timeout); } }; var onEnd = function() { onSerialPortTermination(); }; var onError = function() { serialPort.close(); onSerialPortTermination(); }; var onConnectionEstablished = function() { _this.reconnectTimeout = 0; _this._setConnectionState(SerialConnection.STATE_CONNECTED); done(); }; this.on('data', onConnectionData); var onCompletion = function(err) { if (err) { done(err); } }; var onDisconnect = function() { onError(); }; var options = { baudrate: 9600, databits: 8, stopbits: 1, parity: 'none', disconnectedCallback: onDisconnect, }; serialPort = this._createSerialPort(this.path, options, onCompletion); serialPort.once('open', function() { serialPort.on('data', onSerialPortData); serialPort.on('end', onEnd); serialPort.on('error', onError); onConnectionEstablished(); }); this.serialPort = serialPort; return promise; }, _createSerialPort: function(path, options, onCompletion) { return new SerialPort(path, options, null, onCompletion); } }, { hasSerialPortSupport: !!SerialPort, }); module.exports = SerialConnection; × Search results Close "},"serial-data-source.js.html":{"id":"serial-data-source.js.html","title":"Source: serial-data-source.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: serial-data-source.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var Q = require('q'); var DataSource = require('./data-source'); var SerialConnection = require('./serial-connection'); var optionKeys = [ 'path', ]; var SerialDataSource = DataSource.extend(/** @lends SerialDataSource# */ { /** * The path to the serial port. */ path: null, /** * Creates a new SerialDataSource. * * @constructs * @augments DataSource */ constructor: function(options) { DataSource.call(this, options); _.extend(this, _.pick(options, optionKeys)); }, connectLive: function(options) { var defaultOptions = { path: this.path, }; options = _.extend(defaultOptions, options, { provider: this.provider, dataSource: this.id, }); var connection = new SerialConnection(options); return Q.fcall(function() { return connection.connect(); }).then(function() { return connection; }); } }); module.exports = SerialDataSource; × Search results Close "},"tcp-connection.js.html":{"id":"tcp-connection.js.html","title":"Source: tcp-connection.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: tcp-connection.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var net = require('net'); var _ = require('lodash'); var Q = require('q'); var Connection = require('./connection'); var optionKeys = [ 'host', 'port', 'viaTag', 'password', 'channel', 'rawVBusDataOnly', ]; var TcpConnection = Connection.extend( /** @lends TcpConnection# */ { /** * Host name or IP address of the connection target. * @type {string} */ host: null, /** * Port number of the connection target. * @type {number} */ port: 7053, /** * Via tag if connection target is accessed using the VBus.net service. * @type {string} */ viaTag: null, /** * Password needed to connect to target. * @type {string} */ password: null, /** * Channel number to connect to. * @type {string|number} */ channel: 0, /** * Indicates that connection does not need to perform login handshake. * Useful for serial-to-LAN converters. * @type {boolean} */ rawVBusDataOnly: false, /** * Timeout in milliseconds to way between reconnection retries. * @type {number} */ reconnectTimeout: 0, /** * Value to increment timeout after every unsuccessful reconnection retry. * @type {number} */ reconnectTimeoutIncr: 10000, /** * Maximum timeout value between unsuccessful reconnection retry. * @type {number} */ reconnectTimeoutMax: 60000, /** * Creates a new TcpConnection instance and optionally initializes its * members to the given values. * * @constructs * @augments Connection * @param {object} options Initialization values * @param {string} options.host See {@link TcpConnection#host} * @param {number} options.port See {@link TcpConnection#port} * @param {string} options.viaTag See {@link TcpConnection#viaTag} * @param {string} options.password See {@link TcpConnection#password} * @param {boolean} options.rawVBusDataOnly See {@link TcpConnection#rawVBusDataOnly} * * @classdesc * The TcpConnection class is primarily designed to provide access to VBus live data * using the VBus-over-TCP specification. That includes the VBus/LAN adapter, the * Dataloggers (DL2 and DL3) and VBus.net. * In addition to that it can be used to connect to a raw VBus data stream using TCP * (for example provided by a serial-to-LAN gateway). */ constructor: function(options) { Connection.call(this, options); _.extend(this, _.pick(options, optionKeys)); }, connect: function(force) { if (this.connectionState !== TcpConnection.STATE_DISCONNECTED) { throw new Error('Connection is not disconnected (' + this.connectionState + ')'); } this._setConnectionState(TcpConnection.STATE_CONNECTING); return this._connect(force); }, disconnect: function() { if (this.connectionState === TcpConnection.STATE_DISCONNECTING) { if (this.socket) { this.socket.destroy(); this.socket = null; } this._setConnectionState(TcpConnection.STATE_DISCONNECTED); } else if (this.connectionState !== TcpConnection.STATE_DISCONNECTED) { this._setConnectionState(TcpConnection.STATE_DISCONNECTING); if (this.socket) { this.socket.end(); } else { this._setConnectionState(TcpConnection.STATE_DISCONNECTED); } } }, _connect: function(force) { var _this = this; var socket; var deferred = Q.defer(); var promise = deferred.promise; var done = function(err, result) { if (deferred) { if (err) { deferred.reject(err); } else { deferred.resolve(result); } deferred = null; } }; var options = { host: this.host, port: this.port }; var phase = this.rawVBusDataOnly ? 1000 : 0; var rxBuffer = null; var write = function() { return socket.write.apply(socket, arguments); }; var onConnectionEstablished = function() { _this.reconnectTimeout = 0; _this._setConnectionState(TcpConnection.STATE_CONNECTED); done(); }; var onConnect = function() { if (phase === 1000) { onConnectionEstablished(); } }; var channelList = []; var onLine = function(line) { var newPhase = -1; if (line [0] === '+') { if (phase === 0) { if (_this.viaTag) { // CONNECT ... newPhase = 20; } else { // PASS ... newPhase = 40; } } else if (phase === 20) { newPhase = 40; } else if (phase === 40) { if (_this.channelListCallback) { newPhase = 60; } else if (_this.channel) { newPhase = 80; } else { newPhase = 900; } } else if (phase === 60) { newPhase = 70; _this.channelListCallback(channelList, function(err, channel) { if (err) { done(err); } else { if (channel !== undefined) { if (_.isNumber(channel)) { _this.channel = channel; } else if (_.isString(channel)) { _this.channel = parseInt(channel); } else if (_.isObject(channel) &amp;&amp; _.has(channel, 'channel')) { _this.channel = channel.channel; } else { done(new Error('Invalid channel selection ' + JSON.stringify(channel))); } } if (_this.channel) { newPhase = 80; } else { newPhase = 900; } } }); } else if (phase === 80) { newPhase = 900; } else if (phase === 900) { newPhase = 1000; } } else if (line [0] === '-') { newPhase = 800; done(new Error('Remote side responded with ' + JSON.stringify(line))); } else if (line [0] === '*') { if (phase === 60) { var md = /^\\*([\\d]+):(.*)$/.exec(line); if (md) { channelList.push({ channel: md [1], name: md [2], }); } } } else { // nop } if (newPhase &gt;= 0) { phase = newPhase; if (phase === 20) { // CONNECT write('CONNECT ' + _this.viaTag + '\\r\\n'); } else if (phase === 40) { // PASS write('PASS ' + _this.password + '\\r\\n'); } else if (phase === 60) { // CHANNELLIST write('CHANNELLIST\\r\\n'); } else if (phase === 80) { // CHANNEL write('CHANNEL ' + _this.channel + '\\r\\n'); } else if (phase === 800) { // QUIT write('QUIT\\r\\n'); } else if (phase === 900) { // DATA write('DATA\\r\\n'); } else if (phase === 1000) { onConnectionEstablished(); } } }; var onSocketData = function(chunk) { // console.log('onData'); if (phase &lt; 1000) { // console.log(chunk.toString('utf8')); var buffer; if (rxBuffer) { buffer = Buffer.concat([ rxBuffer, chunk ]); } else { buffer = chunk; } var start = 0, index = 0; while ((index &lt; buffer.length) &amp;&amp; (phase &lt; 1000)) { if ((buffer [index] === 13) || (buffer [index] === 10)) { if (start &lt; index) { var line = buffer.toString('utf8', start, index); onLine(line); } start = index + 1; } index++; } if (start &lt; buffer.length) { if (phase &gt;= 1000) { _this._write(buffer.slice(start)); rxBuffer = null; } else { rxBuffer = buffer.slice(start); } } else { rxBuffer = null; } } else { _this._write(chunk); } }; var onConnectionData = function(chunk) { write(chunk); }; var onSocketTermination = function() { _this.removeListener('data', onConnectionData); if (_this.socket !== socket) { // nop } else if (!force &amp;&amp; (_this.connectionState === TcpConnection.STATE_CONNECTING)) { // failed to connect _this._setConnectionState(TcpConnection.STATE_DISCONNECTED); _this.socket = null; done(new Error('Unable to connect')); } else if (_this.connectionState === TcpConnection.STATE_DISCONNECTING) { _this._setConnectionState(TcpConnection.STATE_DISCONNECTED); _this.socket = null; } else { _this._setConnectionState(TcpConnection.STATE_INTERRUPTED); _this.socket = null; var timeout = _this.reconnectTimeout; if (_this.reconnectTimeout &lt; _this.reconnectTimeoutMax) { _this.reconnectTimeout += _this.reconnectTimeoutIncr; } setTimeout(function() { _this._setConnectionState(TcpConnection.STATE_RECONNECTING); _this._connect(); }, timeout); } }; var onEnd = function() { onSocketTermination(); }; var onError = function(err) { socket.destroy(); onSocketTermination(); }; var onTimeout = function() { socket.destroy(); onSocketTermination(); }; this.on('data', onConnectionData); socket = net.connect(options, onConnect); socket.on('data', onSocketData); socket.on('end', onEnd); socket.on('error', onError); socket.setTimeout(30000, onTimeout); socket.setKeepAlive(true, 60000); this.socket = socket; return promise; }, }); module.exports = TcpConnection; × Search results Close "},"tcp-connection-endpoint.js.html":{"id":"tcp-connection-endpoint.js.html","title":"Source: tcp-connection-endpoint.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: tcp-connection-endpoint.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var EventEmitter = require('events').EventEmitter; var net = require('net'); var _ = require('lodash'); var Q = require('q'); var extend = require('./extend'); var optionKeys = [ 'port', 'channels', ]; var TcpConnectionEndpoint = extend(EventEmitter, /** @lends TcpConnectionEndpoint# */ { /** * The port number to listen on for incoming connections. * @type {number} */ port: 7053, /** * The list of channels to return if the CHANNELLIST command is received. * @type {string[]} */ channels: null, /** * The Server instance used for listening for incoming connections. * @type {net.Server} */ server: null, /** * Creates a new instance and optionally initializes its members. * * @constructs * @augments EventEmitter * @param {object} options The initialization values for this instance. * @param {number} options.port See {@link TcpConnectionEndpoint#port} * @param {number} options.channels See {@link TcpConnectionEndpoint#channels} * * @classdesc * The TcpConnectionEndpoint can act as the remote side for a TcpConnection. * It supports all the commands that a DL3 connected via VBus.net would * provide as well. * * A `connection` event is emitted whenever an incoming connection passes * the VBus-over-TCP handshake. */ constructor: function(options) { EventEmitter.call(this); _.extend(this, _.pick(options, optionKeys)); if (!_.has(this, 'channels')) { this.channels = [ 'VBus' ]; } }, /** * Starts the server to listen for incoming connections. * * @return {Promise} A promise that resolves when the server is started. */ start: function() { var _this = this; var deferred = Q.defer(); var promise = deferred.promise; var done = function(err, result) { if (deferred) { if (err) { deferred.reject(err); } else { deferred.resolve(result); } deferred = null; } }; var server = net.createServer(function(socket) { _this._onConnection(socket); }); server.listen(this.port, function() { if (_this.port === 0) { _this.port = server.address().port; } done(null, true); }); server.on('error', function(err) { done(err); }); this.server = server; return promise; }, stop: function() { if (this.server) { this.server.close(); this.server = null; } }, _onConnection: function(socket) { var _this = this; var connectionInfo = { socket: socket, }; var phase = 0; var rxBuffer = null; var write = function() { return socket.write.apply(socket, arguments); }; var onData = function(chunk) { if (phase &lt; 1000) { var buffer; if (rxBuffer) { buffer = Buffer.concat([ rxBuffer, chunk ]); } else { buffer = chunk; } var start = 0, index = 0; var processNextLine; var callback = function(err, result, transition) { if (err) { write('-ERROR: ' + JSON.stringify(err.toString()) + '\\r\\n'); } else { write(result.toString() + '\\r\\n'); if (transition === false) { socket.end(); connectionInfo.socket = null; } else if (transition === true) { phase = 1000; _this.emit('connection', connectionInfo); } processNextLine(); } }; var processLine = function(line) { var md; if ((md = /^CONNECT (.*)$/.exec(line))) { connectionInfo.viaTag = md [1]; callback(null, '+OK'); } else if ((md = /^PASS (.*)$/.exec(line))) { connectionInfo.password = md [1]; callback(null, '+OK'); } else if ((md = /^CHANNELLIST$/.exec(line))) { var response = _.reduce(_this.channels, function(memo, channel, index) { if (channel) { memo.push('*' + index + ':' + channel); } return memo; }, []).join('\\r\\n'); callback(null, response + '\\r\\n+OK'); } else if ((md = /^CHANNEL (.*)$/.exec(line))) { connectionInfo.channel = md [1]; callback(null, '+OK'); } else if ((md = /^QUIT$/.exec(line))) { callback(null, '+OK', false); } else if ((md = /^DATA$/.exec(line))) { callback(null, '+OK', true); } else { callback('Unknown command'); } }; processNextLine = function() { if ((index &lt; buffer.length) &amp;&amp; (phase &lt; 1000)) { while (index &lt; buffer.length) { if ((buffer [index] === 13) || (buffer [index] === 10)) { if (start &lt; index) { var line = buffer.toString('utf8', start, index); start = index + 1; processLine(line); break; } else { start = index + 1; } } index++; } } else { if (start &lt; buffer.length) { if (phase &gt;= 1000) { // _this._write(buffer.slice(start)); rxBuffer = null; } else { rxBuffer = buffer.slice(start); } } else { rxBuffer = null; } } }; processNextLine(); // } else { // _this._write(chunk); } }; var onEnd = function() { }; var onError = function() { }; var onTimeout = function() { }; socket.on('data', onData); socket.on('end', onEnd); socket.on('error', onError); socket.setTimeout(30000, onTimeout); socket.setKeepAlive(true, 60000); write('+HELLO: This is TcpConnectionEndpoint, at your service!\\r\\n'); }, }); module.exports = TcpConnectionEndpoint; × Search results Close "},"tcp-data-source.js.html":{"id":"tcp-data-source.js.html","title":"Source: tcp-data-source.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: tcp-data-source.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var Q = require('q'); var DataSource = require('./data-source'); var TcpConnection = require('./tcp-connection'); var optionKeys = [ 'host', 'liveChannel', 'livePassword', ]; var TcpDataSource = DataSource.extend(/** @lends TcpDataSource# */ { /** * The host to connect to. * @type {string} */ host: null, /** * The port to connect to. * @type {number} */ port: 7053, /** * The channel to connect to live. * @type {number} */ liveChannel: 0, /** * The password to connect live. * @type {string} */ livePassword: 'vbus', /** * Creates a new TcpDataSource instance. * * @constructs * @augments DataSource */ constructor: function(options) { DataSource.call(this, options); _.extend(this, _.pick(options, optionKeys)); this.options = options; }, connectLive: function(options) { var defaultOptions = { host: this.host, port: this.port, viaTag: this.viaTag, password: this.livePassword, channel: this.liveChannel, }; options = _.extend(defaultOptions, options, { provider: this.provider, dataSource: this.id, }); var connection = new TcpConnection(options); return Q.fcall(function() { return connection.connect(); }).then(function() { return connection; }); } }); module.exports = TcpDataSource; × Search results Close "},"tcp-data-source-provider.js.html":{"id":"tcp-data-source-provider.js.html","title":"Source: tcp-data-source-provider.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: tcp-data-source-provider.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var dgram = require('dgram'); var http = require('http'); var url = require('url'); var _ = require('lodash'); var Q = require('q'); var TcpDataSource = require('./tcp-data-source'); var utils = require('./utils'); var DataSourceProvider = require('./data-source-provider'); var optionKeys = [ 'broadcastAddress', 'broadcastPort', ]; var TcpDataSourceProvider = DataSourceProvider.extend(/** @lends TcpDataSourceProvider# */ { id: 'tcp-data-source-provider', name: 'TCP VBus Data Source Provider', description: 'Data source provider for TCP connected VBus devices', broadcastAddress: '255.255.255.255', broadcastPort: 7053, /** * Creates a new TcpDataSourceProvider instance. * * @constructs * @augments DataSourceProvider */ constructor: function(options) { DataSourceProvider.call(this, options); _.extend(this, _.pick(options, optionKeys)); }, discoverDataSources: function() { var _this = this; var options = { broadcastAddress: this.broadcastAddress, broadcastPort: this.broadcastPort, }; return Q.fcall(function() { return TcpDataSourceProvider.discoverDevices(options); }).then(function(results) { return _.map(results, function(result) { var options = _.extend({}, result, { host: result.__address__ }); return _this.createDataSource(options); }); }); }, createDataSource: function(options) { options = _.extend({}, options, { provider: this.id, id: options.__address__, name: options.name || options.__address__, host: options.__address__, }); return new TcpDataSource(options); }, }, /** @lends TcpDataSourceProvider */ { /** * Discovers devices on the local network. * * @params {object} options * @params {string} options.broadcastAddress IP address to broadcast to * @params {number} options.broadcastPort Port number to broadcast to. * @returns {Promise} A Promise that resolves to an array of device information objects. */ discoverDevices: function(options) { return TcpDataSourceProvider.sendBroadcast(options).then(function(promises) { return Q.allSettled(promises); }).then(function(results) { return _.reduce(results, function(memo, result) { if (result.state === 'fulfilled') { memo.push(result.value); } return memo; }, []); }); }, sendBroadcast: function(options) { var deferred = Q.defer(); var promise = deferred.promise; var done = function(err, result) { if (deferred) { if (err) { deferred.reject(err); } else { deferred.resolve(result); } deferred = null; } }; options = _.defaults({}, options, { broadcastAddress: '255.255.255.255', broadcastPort: 7053, tries: 3, timeout: 500, }); if (options.fetchCallback === undefined) { options.fetchCallback = function(address) { return TcpDataSourceProvider.fetchDeviceInformation(address); }; } var bcastAddress = options.broadcastAddress; var bcastPort = options.broadcastPort; var addressMap = {}; var queryString = '---RESOL-BROADCAST-QUERY---'; var replyString = '---RESOL-BROADCAST-REPLY---'; var tries = 0; var socket = dgram.createSocket('udp4'); var sendQuery = function() { if (tries &lt; options.tries) { tries++; var queryBuffer = new Buffer(queryString); socket.send(queryBuffer, 0, queryBuffer.length, bcastPort, bcastAddress); setTimeout(sendQuery, options.timeout); } else { var keys = _.keys(addressMap).sort(); var result = _.map(keys, function(key) { return addressMap [key]; }); socket.close(); done(null, result); } }; socket.bind(0, function() { socket.setBroadcast(true); sendQuery(); }); socket.on('message', function(msg, rinfo) { if ((rinfo.family === 'IPv4') &amp;&amp; (rinfo.port === 7053) &amp;&amp; (msg.length &gt;= replyString.length)) { var msgString = msg.slice(0, replyString.length).toString(); if (msgString === replyString) { var address = rinfo.address; if (!_.has(addressMap, address)) { addressMap [address] = options.fetchCallback(address); } } } }); socket.on('error', function(err) { socket.close(); done(err); }); return promise; }, fetchDeviceInformation: function(address, port) { if (port === undefined) { return Q.fcall(function() { return TcpDataSourceProvider.fetchDeviceInformation(address, 80); }).fail(function() { return TcpDataSourceProvider.fetchDeviceInformation(address, 3000); }); } else { return utils.promise(function(resolve, reject) { var portSuffix; if (port !== 80) { portSuffix = ':' + port; } else { portSuffix = ''; } var reqUrl = url.parse('http://' + address + portSuffix + '/cgi-bin/get_resol_device_information'); var req = http.get(reqUrl, function(res) { if (res.statusCode === 200) { var buffer = new Buffer(0); res.on('data', function(chunk) { buffer = Buffer.concat([ buffer, chunk ]); }); res.on('end', function() { var bodyString = buffer.toString(); var info = _.extend(TcpDataSourceProvider.parseDeviceInformation(bodyString), { __address__: address, }); resolve(info); }); res.on('error', function(err) { reject(err); }); } else { reject(new Error('HTTP request returned status ' + res.statusCode)); } }); req.on('error', function(err) { reject(err); }); req.setTimeout(10000, function() { reject(new Error('HTTP request timed out')); }); }); } }, parseDeviceInformation: function(string) { var result = {}; var re = /([\\w]+)[\\s]*=[\\s]*&quot;([^&quot;\\r\\n]*)&quot;/g; var md; while ((md = re.exec(string)) !== null) { result [md [1]] = md [2]; } return result; }, }); module.exports = TcpDataSourceProvider; × Search results Close "},"telegram.js.html":{"id":"telegram.js.html","title":"Source: telegram.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: telegram.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var sprintf = require('sprintf').sprintf; var Header = require('./header'); var optionKeys = [ 'command', ]; var Telegram = Header.extend(/** @lends Telegram# */ { /** * The VBus command of this Telegram instance. * @type {number} */ command: 0, frameData: null, /** * Creates a new Telegram instance. * * @constructs * @augments Header * @param {object} options Initialization options. */ constructor: function(options) { Header.call(this, options); _.extend(this, _.pick(options, optionKeys)); if (_.has(options, 'frameData') &amp;&amp; _.has(options, 'dontCopyFrameData') &amp;&amp; options.dontCopyFrameData) { this.frameData = options.frameData; } else { this.frameData = new Buffer(3 * 7); this.frameData.fill(0); if (_.has(options, 'frameData')) { var minLength = Math.min(this.frameData.length, options.frameData.length); options.frameData.copy(this.frameData, 0, 0, minLength); } } }, toLiveBuffer: function(origBuffer, start, end) { var frameCount = this.getFrameCount(); var length = 8 + frameCount * 9; var buffer; if (origBuffer === undefined) { buffer = new Buffer(length); } else if (start + length &lt;= end) { buffer = origBuffer.slice(start, start + length); } else { throw new Error('Buffer too small'); } buffer [0] = 0xAA; buffer.writeUInt16LE(this.destinationAddress &amp; 0x7F7F, 1); buffer.writeUInt16LE(this.sourceAddress &amp; 0x7F7F, 3); buffer [5] = 0x30; buffer [6] = this.command &amp; 0x7F; Telegram.calcAndSetChecksumV0(buffer, 1, 7); for (var i = 0; i &lt; frameCount; i++) { var srcStart = 7 * i; var dstStart = 8 + 9 * i; Telegram.extractSeptett(this.frameData, srcStart, srcStart + 7, buffer, dstStart); Telegram.calcAndSetChecksumV0(buffer, dstStart, dstStart + 8); } return buffer; }, getProtocolVersion: function() { return 0x30; }, getId: function() { var baseId = Header.prototype.getId.call(this); return sprintf('%s_%02X', baseId, this.command); }, compareTo: function(that) { var result = Header.prototype.compareTo.apply(this, arguments); if (result === 0) { result = this.command - that.command; } return result; }, getFrameCount: function() { return Telegram.getFrameCountForCommand(this.command); }, }, /** @lends Telegram */ { fromLiveBuffer: function(buffer, start, end) { var frameCount = this.getFrameCountForCommand(buffer [start + 6]); var frameData = new Buffer(3 * 7); frameData.fill(0); for (var i = 0; i &lt; frameCount; i++) { var srcStart = start + 8 + 9 * i; var dstStart = 7 * i; Telegram.injectSeptett(buffer, srcStart, srcStart + 7, frameData, dstStart); } return new Telegram({ destinationAddress: buffer.readUInt16LE(start + 1), sourceAddress: buffer.readUInt16LE(start + 3), command: buffer [start + 6], frameData: frameData, dontCopyFrameData: true }); }, getFrameCountForCommand: function(command) { return ((command &gt;&gt; 5) &amp; 0x03); } }); module.exports = Telegram; × Search results Close "},"text-converter.js.html":{"id":"text-converter.js.html","title":"Source: text-converter.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: text-converter.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var Converter = require('./converter'); var HeaderSet = require('./header-set'); var Packet = require('./packet'); var Specification = require('./specification'); var optionKeys = [ 'columnSeparator', 'lineSeparator', 'separateDateAndTime', 'specification', ]; var TextConverter = Converter.extend(/** @lends TextConverter# */ { /** * Column separator, defaults to tab * @type {string} */ columnSeparator: '\\t', /** * Line separator, defaults to CR+NL * @type {string} */ lineSeparator: '\\r\\n', /** * Specifies whether date and time columns should be output separately * @type {boolean} */ separateDateAndTime: false, /** * VBus specification * @type {Specification} */ specification: null, /** * List of packet IDs converted last time, enables decision whether a * new header line pair must be output. * @type {string} */ lastIdList: null, knownPackets: null, /** * Create a new TextConverter instance given the set of options. * @constructs * @augments Converter * * @classdesc * The TextConverter class takes header sets, converts them into text * representation and then publishes that on the readable stream side * of itself. * * It does not support parsing text content back into header sets (the * writable stream side). */ constructor: function(options) { Converter.call(this, options); _.extend(this, _.pick(options, optionKeys)); if (!this.specification) { this.specification = new Specification({ language: options &amp;&amp; options.language || 'en' }); } if (options &amp;&amp; options.knownHeaderSet) { var knownPackets = []; _.forEach(options.knownHeaderSet.getHeaders(), function(header) { if (header instanceof Packet) { var packet = new Packet({ timestamp: new Date(0), channel: header.channel, destinationAddress: header.destinationAddress, sourceAddress: header.sourceAddress, command: header.command, frameCount: 0, }); knownPackets.push(packet); } }); this.knownPackets = knownPackets; } }, /** * Resets the converter, resulting in a ne pair of header lines * generated on next header set conversion. */ reset: function() { this.lastIdList = null; }, /** * Converts a header set into text representation. * * @param {HeaderSet} headerSet */ convertHeaderSet: function(inHeaderSet) { var _this = this; var spec = this.specification; var i18n = spec.i18n; var headerSet; if (this.knownPackets) { headerSet = new HeaderSet(); headerSet.addHeaders(this.knownPackets); headerSet.addHeaders(inHeaderSet.getHeaders()); headerSet.timestamp = inHeaderSet.timestamp; } else { headerSet = inHeaderSet; } var headers = headerSet.getSortedHeaders(); var packetFields = spec.getPacketFieldsForHeaders(headers); var now = i18n.moment(headerSet.timestamp); var idList = _.pluck(packetFields, 'id').join(','); var content = '', columns; var appendDateAndTimeColumns = function(date, time, join) { columns = []; if (_this.separateDateAndTime) { columns.push(date); columns.push(time); } else { columns.push(date + join + time); } }; var appendColumnsToContent = function() { content += columns.join(_this.columnSeparator) + _this.lineSeparator; }; var needHeaderLines = false; if (this.lastIdList !== idList) { this.lastIdList = idList; needHeaderLines = true; } if (needHeaderLines) { // packet spec header line var lastPacketSpec = null; appendDateAndTimeColumns('', '', ''); _.forEach(packetFields, function(packetField) { var packetDesc; if (lastPacketSpec !== packetField.packetSpec) { lastPacketSpec = packetField.packetSpec; if (packetField.packetSpec) { packetDesc = packetField.packetSpec.fullName || ''; } else { packetDesc = ''; } } else { packetDesc = ''; } columns.push(packetDesc); }); appendColumnsToContent(); // packet field spec header line appendDateAndTimeColumns(i18n.t('textConverter.date'), i18n.t('textConverter.time'), ' / '); _.forEach(packetFields, function(packetField) { var columnDesc = packetField.name; if (packetField.packetFieldSpec) { var type = packetField.packetFieldSpec.type; if (type &amp;&amp; type.unit &amp;&amp; type.unit.unitText) { columnDesc += ' [' + type.unit.unitText + ']'; } } else { columnDesc = ''; } columns.push(columnDesc); }); appendColumnsToContent(); } // value line appendDateAndTimeColumns(now.format('L'), now.format('HH:mm:ss'), ' '); _.forEach(packetFields, function(packetField) { var textValue = packetField.formatTextValue('None'); columns.push(textValue); }); appendColumnsToContent(); return this.push(content); }, _read: function() { // nop }, }); module.exports = TextConverter; × Search results Close "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: utils.js /*! resol-vbus | Copyright (c) 2013-2015, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var Q = require('q'); var utils = { /** * @see http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript */ generateGUID: function() { var s4 = function() { return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); }; var guid = [ s4(), s4(), '-', s4(), '-', s4(), '-', s4(), '-', s4(), s4(), s4(), ].join(''); return guid; }, cancelablePromise: function(callback, thisArg) { var cancelDeferred = Q.defer(); var cancelPromise = cancelDeferred.promise; var isCanceled = false; var cancel = function(reason) { if (!isCanceled) { cancelPromise.then(function(result) { result.cancel(reason); }); isCanceled = true; } }; var checkCanceled = function(result) { if (!isCanceled) { return result; } else { throw new Error('Canceled'); } }; var promise = utils.promise(function(resolve, reject, notify) { if (cancelDeferred) { cancelDeferred.resolve({ cancel: reject }); cancelDeferred = null; } return Q.fcall(function() { return cancelPromise; }).then(function() { return callback.call(thisArg, resolve, reject, notify, checkCanceled); }); }); promise.cancel = cancel; return promise; }, roundNumber: function(value, exp) { if ((value === undefined) || (exp === undefined) || (+exp === 0)) { return value; } value = +value; exp = +exp; if (_.isNaN(value) || (exp % 1 !== 0)) { return NaN; } var valueParts = value.toString().split('e'); var baseExp = valueParts [1] ? +valueParts [1] : 0; value = Math.round(+(valueParts [0] + 'e' + (baseExp - exp))); valueParts = value.toString().split('e'); baseExp = valueParts [1] ? +valueParts [1] : 0; value = +(valueParts [0] + 'e' + (baseExp + exp)); return value; }, deepFreezeObjectTree: function(root) { var freezingObjects = []; var deepFreezeObject = function(obj) { if (Object.isFrozen(obj)) { return obj; } if (freezingObjects.indexOf(obj) &gt;= 0) { throw new Error('Circular reference while deep freezing'); } freezingObjects.push(obj); var keys = Object.getOwnPropertyNames(obj); keys.forEach(function(key) { var value = obj [key]; if ((typeof value === 'object') &amp;&amp; (value !== null)) { deepFreezeObject(value); } }); freezingObjects.pop(); return Object.freeze(obj); }; return deepFreezeObject(root); }, }; var Promise = function(callback, thisArg) { var deferred = Q.defer(); var promise = deferred.promise; var resolve = function(result) { if (deferred) { deferred.resolve(result); deferred = null; } }; var reject = function(reason) { if (deferred) { deferred.reject(reason); deferred = null; } }; var notify = function(value) { if (deferred) { deferred.notify(value); } }; try { callback.call(thisArg, resolve, reject, notify); } catch (ex) { reject(ex); } return promise; }; Promise.resolve = function(value) { return new Promise(function(resolve) { resolve(value); }); }; Promise.reject = function(reason) { return new Promise(function(resolve, reject) { reject(reason); }); }; utils.Promise = Promise; // NOTE(daniel): Legacy naming utils.promise = Promise; module.exports = utils; × Search results Close "},"vbus-recording-converter.js.html":{"id":"vbus-recording-converter.js.html","title":"Source: vbus-recording-converter.js","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Source: vbus-recording-converter.js /*! resol-vbus | Copyright (c) 2013-2014, Daniel Wippermann | MIT license */ 'use strict'; var _ = require('lodash'); var moreints = require('buffer-more-ints'); var HeaderSet = require('./header-set'); var Packet = require('./packet'); var Converter = require('./converter'); var optionKeys = [ 'topologyScanOnly', ]; var VBusRecordingConverter = Converter.extend(/** @lends VBusRecordingConverter# */ { topologyScanOnly: false, rxBuffer: null, headerSet: null, headerSetTimestamp: null, currentChannel: 0, knownHeaderIds: null, /** * Creates a new VBusRecordingConverter instance. * * @constructs * @augments Converter * * @classdesc * This Converter subclass converts Header and HeaderSet instances to and from a binary stream that * conforms to the VBus Recording File Format (the binary file format used e.g. to store data on the * Datalogger devices). */ constructor: function(options) { Converter.call(this, options); _.extend(this, _.pick(options, optionKeys)); this.knownHeaderIds = {}; }, reset: function() { this.rxBuffer = null; }, end: function() { var _this = this; if (this.objectMode) { // nop } else if (this.topologyScanOnly) { this._processBuffer(new Buffer(0), true, function(record) { _this._processRecordForTopologyScan(record); }); this._constructTopologyHeaderSet(); } else { this._processBuffer(new Buffer(0), true, function(record) { _this._processRecord(record); }); } this._emitHeaderSet(); return Converter.prototype.end.apply(this, arguments); }, convertRawData: function(rawData) { if (this.objectMode) { return Converter.prototype.convertRawData.apply(this, arguments); } else { var buffers = []; var createBuffer = function(type, length, timestamp) { var buffer = new Buffer(length); buffer.fill(0); buffer [0] = 0xA5; buffer [1] = (type &amp; 0x0F) | ((type &amp; 0x0F) &lt;&lt; 4); buffer.writeUInt16LE(length, 2); buffer.writeUInt16LE(length, 4); moreints.writeUInt64LE(buffer, timestamp.getTime(), 6); return buffer; }; var buffer; if (rawData.channel !== this.currentChannel) { buffer = createBuffer(7, 16, new Date(0)); buffer.writeUInt16LE(rawData.channel, 14); buffers.push(buffer); this.currentChannel = rawData.channel; } buffer = createBuffer(8, 22 + rawData.buffer.length, rawData.startTimestamp); moreints.writeUInt64LE(buffer, rawData.endTimestamp.getTime(), 14); rawData.buffer.copy(buffer, 22, 0, rawData.buffer.length); buffers.push(buffer); buffer = Buffer.concat(buffers); return this.push(buffer); } }, convertHeader: function(header) { if (this.objectMode) { return Converter.prototype.convertHeader.apply(this, arguments); } else { return this._convertHeaders(header.timestamp, [ header ]); } }, convertHeaderSet: function(headerSet) { if (this.objectMode) { return Converter.prototype.convertHeaderSet.apply(this, arguments); } else { return this._convertHeaders(headerSet.timestamp, headerSet.getSortedHeaders()); } }, _convertHeaders: function(timestamp, headers) { var buffers = []; var createBuffer = function(type, length, timestamp) { var buffer = new Buffer(length); buffer.fill(0); buffer [0] = 0xA5; buffer [1] = (type &amp; 0x0F) | ((type &amp; 0x0F) &lt;&lt; 4); buffer.writeUInt16LE(length, 2); buffer.writeUInt16LE(length, 4); moreints.writeUInt64LE(buffer, timestamp.getTime(), 6); return buffer; }; var buffer = createBuffer(4, 14, timestamp); buffers.push(buffer); var currentChannel = 0; _.forEach(headers, function(header) { var majorVersion = header.getProtocolVersion() &gt;&gt; 4; var dataLength; if (majorVersion === 1) { dataLength = header.frameCount * 4; } else { dataLength = -1; } if (dataLength &gt;= 0) { var buffer; if (currentChannel !== header.channel) { currentChannel = header.channel; buffer = createBuffer(7, 16, new Date(0)); buffer.writeUInt16LE(header.channel, 14); buffers.push(buffer); } buffer = createBuffer(6, 26 + dataLength, header.timestamp); buffer.writeUInt16LE(header.destinationAddress, 14); buffer.writeUInt16LE(header.sourceAddress, 16); buffer.writeUInt16LE(header.getProtocolVersion(), 18); if (majorVersion === 1) { buffer.writeUInt16LE(header.command, 20); buffer.writeUInt16LE(dataLength, 22); buffer.writeUInt16LE(0, 24); header.frameData.copy(buffer, 26, 0, dataLength); } buffers.push(buffer); } }); buffer = Buffer.concat(buffers); return this.push(buffer); }, _read: function() { // nop }, _write: function(chunk, encoding, callback) { var _this = this; if (this.objectMode) { return Converter.prototype._write.apply(this, arguments); } else if (this.topologyScanOnly) { this._processBuffer(chunk, false, function(record) { _this._processRecordForTopologyScan(record); }); callback(); } else { this._processBuffer(chunk, false, function(record) { _this._processRecord(record); }); callback(); } }, _processBuffer: function(chunk, endOfStream, processRecord) { var buffer; if (this.rxBuffer) { buffer = Buffer.concat([ this.rxBuffer, chunk ]); } else { buffer = chunk; } var getRecordLength = function(index) { var length; if (index &gt; buffer.length - 6) { length = -1; } else if (buffer [index] !== 0xA5) { length = 0; } else if ((buffer [index + 1] &gt;&gt; 4) !== (buffer [index + 1] &amp; 15)) { length = 0; } else if (buffer [index + 2] !== buffer [index + 4]) { length = 0; } else if (buffer [index + 3] !== buffer [index + 5]) { length = 0; } else { length = buffer.readUInt16LE(index + 2); if ((index + length) &gt; buffer.length) { length = -1; } } return length; }; var currentIndex = 0, currentLength = getRecordLength(0), nextIndex, nextLength, start = 0; while ((currentLength &gt;= 0) &amp;&amp; (currentIndex &lt; buffer.length)) { if (currentLength &gt; 0) { nextIndex = currentIndex + currentLength; } else { nextIndex = currentIndex + 1; } nextLength = getRecordLength(nextIndex); if ((nextLength &lt; 0) &amp;&amp; !endOfStream) { break; } if ((currentLength &gt; 0) &amp;&amp; ((nextLength &gt; 0) || (nextIndex === buffer.length))) { var record = buffer.slice(currentIndex, nextIndex); processRecord(record); start = nextIndex; } else if (nextIndex !== (currentIndex + 1)) { nextIndex = currentIndex + 1; nextLength = getRecordLength(nextIndex); if (nextLength &lt; 0) { break; } } currentIndex = nextIndex; currentLength = nextLength; } var maxLength = 65536; if (buffer.length - start &gt;= maxLength) { start = buffer.length - maxLength; } if (start &lt; buffer.length) { this.rxBuffer = new Buffer(buffer.slice(start)); } else { this.rxBuffer = null; } }, _processRecord: function(buffer) { var type = buffer [1] &amp; 0x0F; var timestamp = moreints.readUInt64LE(buffer, 6); if (type === 3) { this._processType3Record(buffer, timestamp); } else if (type === 4) { this._emitHeaderSet(); this.headerSet = new HeaderSet(); this.headerSetTimestamp = new Date(timestamp); this.currentChannel = 0; } else if ((type === 6) &amp;&amp; (buffer.length &gt;= 20)) { var destinationAddress = buffer.readUInt16LE(14); var sourceAddress = buffer.readUInt16LE(16); var protocolVersion = buffer.readUInt16LE(18); var majorVersion = protocolVersion &gt;&gt; 4; if ((majorVersion === 1) &amp;&amp; (buffer.length &gt;= 26)) { var command = buffer.readUInt16LE(20); var dataLength = buffer.readUInt16LE(22); if (buffer.length &gt;= 26 + dataLength) { var frameCount = Math.floor(dataLength / 4); var frameData = new Buffer(127 * 4); buffer.copy(frameData, 0, 26, 26 + dataLength); var header = new Packet({ timestamp: new Date(timestamp), channel: this.currentChannel, destinationAddress: destinationAddress, sourceAddress: sourceAddress, command: command, frameCount: frameCount, frameData: frameData, dontCopyFrameData: true, }); if (this.headerSet) { this.headerSet.addHeader(header); } this.emit('header', header); } } } else if ((type === 7) &amp;&amp; (buffer.length &gt;= 16)) { this.currentChannel = buffer [14]; } else if ((type === 8) &amp;&amp; (buffer.length &gt;= 22)) { var endTimestamp = moreints.readUInt64LE(buffer, 14); var rawBuffer = new Buffer(buffer.length - 22); buffer.copy(rawBuffer, 0, 22, buffer.length); this.emit('rawData', { startTimestamp: new Date(timestamp), endTimestamp: new Date(endTimestamp), channel: this.currentChannel, buffer: rawBuffer, }); } }, _processType3Record: function(buffer, timestamp) { var destinationAddress = buffer.readUInt16LE(14); var sourceAddress = buffer.readUInt16LE(16); var protocolVersion = buffer.readUInt16LE(18); var majorVersion = protocolVersion &gt;&gt; 4; if ((majorVersion === 1) &amp;&amp; (buffer.length &gt;= 26)) { var command = buffer.readUInt16LE(20); var dataLength = buffer.readUInt16LE(22); if (buffer.length &gt;= 26 + dataLength) { var frameCount = Math.floor(dataLength / 4); var frameData = new Buffer(127 * 4); buffer.copy(frameData, 0, 26, 26 + dataLength); var header = new Packet({ timestamp: new Date(timestamp), channel: this.currentChannel, destinationAddress: destinationAddress, sourceAddress: sourceAddress, command: command, frameCount: frameCount, frameData: frameData, dontCopyFrameData: true, }); if (destinationAddress === 0x0010) { this._emitHeaderSet(); } else if (this.headerSet &amp;&amp; this.headerSet.containsHeader(header)) { this._emitHeaderSet(); } if (!this.headerSet) { this.headerSet = new HeaderSet(); this.headerSet.timestamp = header.timestamp; } this.headerSet.addHeader(header); this.emit('header', header); } } }, _emitHeaderSet: function() { if (this.headerSet) { if (this.headerSetTimestamp) { this.headerSet.timestamp = this.headerSetTimestamp; } this.emit('headerSet', this.headerSet); this.headerSet = null; } }, _processRecordForTopologyScan: function(buffer) { var type = buffer [1] &amp; 0x0F; var destinationAddress = 0, sourceAddress = 0, protocolVersion = 0, command = 0, hasHeader = false; if (((type === 3) || (type === 6)) &amp;&amp; (buffer.length &gt;= 20)) { destinationAddress = buffer.readUInt16LE(14); sourceAddress = buffer.readUInt16LE(16); protocolVersion = buffer.readUInt16LE(18); var majorVersion = protocolVersion &gt;&gt; 4; if ((majorVersion === 1) &amp;&amp; (buffer.length &gt;= 26)) { command = buffer.readUInt16LE(20); hasHeader = true; } } else if (type === 4) { this.currentChannel = 0; } else if ((type === 7) &amp;&amp; (buffer.length &gt;= 16)) { this.currentChannel = buffer [14]; } if (hasHeader) { var headerIdBuffer = new Buffer(8); headerIdBuffer [0] = this.currentChannel; headerIdBuffer.writeUInt16LE(destinationAddress, 1); headerIdBuffer.writeUInt16LE(sourceAddress, 3); headerIdBuffer [5] = protocolVersion; headerIdBuffer.writeUInt16LE(command, 6); var headerId = headerIdBuffer.toString('hex'); this.knownHeaderIds [headerId] = true; } }, _constructTopologyHeaderSet: function() { var headerSet = new HeaderSet(); var timestamp = new Date(0); _.forEach(_.keys(this.knownHeaderIds), function(headerId) { var headerIdBuffer = new Buffer(headerId, 'hex'); var channel = headerIdBuffer [0]; var destinationAddress = headerIdBuffer.readUInt16LE(1); var sourceAddress = headerIdBuffer.readUInt16LE(3); var protocolVersion = headerIdBuffer [5]; var command = headerIdBuffer.readUInt16LE(6); var majorVersion = (protocolVersion &gt;&gt; 4); if (majorVersion === 1) { var packet = new Packet({ timestamp: timestamp, channel: channel, destinationAddress: destinationAddress, sourceAddress: sourceAddress, command: command, frameCount: 0, }); headerSet.addHeader(packet); } else { throw new Error('Unsupported major version'); } }); headerSet.timestamp = timestamp; this.headerSet = headerSet; }, }); module.exports = VBusRecordingConverter; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Global Methods extend(parent, protoProps, staticProps) A helper method for classical inheritance. Parameters: Name Type Argument Description parent function &lt;nullable&gt; Parent class constructor protoProps object &lt;nullable&gt; Properties to be mixed-in the prototype of the child class staticProps object &lt;nullable&gt; Properties to be mixed-in the constructor function of the child class Source: extend.js Returns: Child class constructor Type function getOptimizerOptions() Get an array of possible options for calling this ConfigurationOptimizer's constructor. Source: configuration-optimizer.js Returns: A promise that resolves to an array of constructor options. Type Promise matchOptimizer(options) Find settings for this ConfigurationOptimizer's constructor that matches the given options best. Parameters: Name Type Description options object Options to look for while searching a matching configuration optimizer. Properties Name Type Description id string The identifier for the ConfigurationOptimizer. deviceAddress number The VBus address of the controller. version string The version of the controller. customizer Customizer A Customizer instance to query additional information with. Source: configuration-optimizer.js Returns: A Promise that resolves to the best matching optimizer result or null if no match was found. Type Promise Type Definitions BlockTypeSection Type: object Properties: Name Type Description sectionId string Section identifier surrogatePacketId string Surrogate packet identifier packet Packet Packet object packetSpec PacketSpecification PacketSpecification object startOffset number Offset of section start within Packet frame data endOffset number Offset of section end within Packet frame data type number Section type payloadCount number Count of payload elements frameCount number Count of frames frameData Buffer Frame data Source: specification.js Configuration Type: Array.&lt;ConfigurationValue&gt; Source: configuration-optimizer.js ConfigurationValue Type: object Properties: Name Type Description valueId String Value ID valueIndex number Value Index value number Value priority number Priority (higher numbers mean higher priority) pending boolean Indicates that this value has to be tranceived. transceived boolean Indicates that this value has been tranceived. Source: configuration-optimizer.js DeviceSpecification Type: object Properties: Name Type Description deviceId string Device identifier channel number VBus channel selfAddress number VBus address of the device itself peerAddress number VBus address of the device's peer name string Name of the device fullName string Name of the device optionally prefixed with VBus channel (if it is not 0) Source: specification.js FilteredPacketFieldSpecification Type: object Properties: Name Type Description filteredPacketFieldId string packetId string fieldId string name string type string getRawValue string Source: specification.js PacketField Type: object Properties: Name Type Description id string Packet field identifier packet Packet Packet packetSpec PacketSpecification packetFieldSpec PacketFieldSpecification origPacketFieldSpec PacketFieldSpecification name string rawValue number Raw value formatTextValue function Function to format this packet field's raw value into textual form Source: specification.js packetFieldGetRawValue(buffer, start, end) Parameters: Name Type Description buffer Buffer Buffer object start number Start index in the buffer end number End index in the buffer Source: specification.js PacketFieldSpecification Type: object Properties: Name Type Description fieldId string Field identifier name object Object containing names by language code type TypeSpecification TypeSpecification object getRawValue packetFieldGetRawValue Function to get raw value from a buffer Source: specification.js PacketSpecification Type: object Properties: Name Type Description packetId string Packet identifier channel number VBus channel destinationAddress number VBus address of the destination device sourceAddress number VBus address of the source device protocolVersion number VBus protocol version command number VBus command info number Additional info for sorting purposes destinationDevice DeviceSpecification DeviceSpecification object of the destination device sourceDevice DeviceSpecification DeviceSpecification object of the source device packetFields Array.&lt;PacketFieldSpecification&gt; Array of PacketFieldSpecification objects Source: specification.js RawData Type: object Properties: Name Type Description channel Number VBus Channel number startTimestamp Date Timestamp of the start of reception of this data endTimestamp Date Timestamp of the end of reception of this data buffer Buffer The VBus raw data buffer Source: converter.js TypeSpecification Type: object Properties: Name Type Description typeId String Type identifier rootTypeId String Root type identifier precision number Precision for numeral values unit UnitSpecification Unit object Source: specification.js UnitSpecification Type: object Properties: Name Type Description unitId String Unit identifier unitCode String Unit code unitFamily String Unit family unitText String Unit text Source: specification.js × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Classes Classes Connection ConnectionCustomizer Converter Customizer Datagram DLxJsonConverter DLxRecorder Header HeaderSet HeaderSetConsolidator I18N Packet Recorder SerialConnection SerialDataSource Specification TcpConnection TcpConnectionEndpoint TcpDataSource TcpDataSourceProvider Telegram TextConverter VBusRecordingConverter Events addHeader This event is fired whenever a Header instance is added to this set. Type: Header Source: header-set.js removeHeader This event is fired whenever a Header is removed from this set. Type: Header Source: header-set.js addHeader This event is fired whenever a Header instance is added to this set. Type: Header Inherited From: HeaderSet#event:addHeader Source: header-set.js removeHeader This event is fired whenever a Header is removed from this set. Type: Header Inherited From: HeaderSet#event:removeHeader Source: header-set.js × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer resol-vbusA JavaScript library for processing RESOL VBus data. Features Connects to various RESOL VBus devices Processes live and recorded VBus data streams Discovers LAN-enabled RESOL devices on the local network Allows to send parameterization commands to a controller Synchronizes recorded VBus data from a RESOL datalogger to your local file system Converts recorded VBus data into human or machine readable formats, optionally allowing to filter the output DocumentationYou can find the work-in-progress documentation for this project here: http://danielwippermann.github.io/resol-vbus/ The JSDoc-generated documentation is located here: http://danielwippermann.github.io/resol-vbus/jsdoc/classes.list.html InstallationIf you want to use this module in your own application, you can just install it from the npm registry: ⌘ npm install --save resol-vbusIf you want to contribute to it you might want to check out the latest version from GitHub: ⌘ git clone https://github.com/danielwippermann/resol-vbus.git ⌘ cd resol-vbus ⌘ npm installRunning the console examples⌘ node examples/&lt;name&gt;/index.jsRunning the testsTo start a single run of the test suite just enter the following commandinto your shell: ⌘ gulpIn addition to that the project is configured to watch its own files formodification and rerun the documentation generator and test suite everytime you hit save on a file. To run that just enter the following commandinto your shell: ⌘ gulp watchSupported Devices &amp; Services All current RESOL controllers with VBus RESOL DL2 Datalogger RESOL DL3 Datalogger RESOL VBus/LAN interface adapter RESOL VBus/USB interface adapter RESOL VBus.net Technical Information &amp; Specifications RESOL VBus Google Group RESOL VBus Protocol Specification RESOL VBus Packet List RESOL VBus Recording File Format RESOL VBus Specification File Format v1 RESOL VBus over TCP Specification RESOL DL2 (v1) Data Download API RESOL DL2 (v2) &amp; DL3 Data Download API Known issues The FileSystemRecorder class sometimes writes invalid JSON into its &quot;SyncState.json&quot; file causing it to notbeing able to restore and recover from that when the app using the recorder restarts (e.g. the &quot;vbustouch-proxy&quot;example). The ConfigurationOptimizers do not yet detect the firmware version running on the controller to be configured.That sometimes causes configuration loads and saves to fail because unknown values are read from or written to(e.g. using the &quot;customizer&quot; example on a DeltaSol MX with firmware version 1.11 or below). ChangelogVersion 0.15.0 (2016-03-30) Update VBus specification data Several minor bug fixes Version 0.14.0 (2015-10-29) Improve configuration optimizers and their discovery Update VBus specification data Version 0.13.0 (2015-05-14) Add configuration optimizers for RESOL DeltaSol SLT Add BlockType support Version 0.12.2 (2015-05-05) Update VBus specification data Version 0.12.1 (2015-04-27) Add configuration optimizers for RESOL DeltaSol MX and BS/4 v2 Add a simple JSON live data server example Add some documentation Several bug fixes Version 0.12.0 (2015-02-28) Add vbustouch-proxy example Add support for rounding floating point numbers Version 0.11.1 (2014-11-04) Fix a floating point bug caused by setRawValue Version 0.11.0 (2014-10-29) Added support for setting packet field values Several bug fixes Version 0.10.0 (2014-04-26) Finalized support for customizing controller configuration. Several bug fixes. Version 0.9.0 (2014-03-16) Completed Recorder class by adding support for recording Added unit conversion to VBus specification Several bug fixes. Version 0.8.0 (2014-03-03) Extended Converter and VBusRecordingConverter to support object mode in stream (for performance reason) Fixed several bugs Increased test coverage and completed documentation. Version 0.7.0 (2014-02-17)First release to the NPM registry. Contributors Thorsten Müller Paul Hanna Legal NoticesRESOL, VBus, VBus.net and others are trademarks or registered trademarksof RESOL - Elektronische Regelungen GmbH. All other trademarks are the property of their respective owners. LicenseThe MIT License (MIT) Copyright (c) 2013-2016, Daniel Wippermann. Permission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the &quot;Software&quot;), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE. × Search results Close "},"Connection.html":{"id":"Connection.html","title":"Class: Connection","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Connection Connection The Connection class is the abstract base class for all VBus live data connections.It extends the Duplex stream class. Any data written to a Connection instance isparsed according to the VBus Protocol Specification. Once a valid instance of one of theHeader sub-classes (Packet, Datagram or Telegram)is created from the binary data stream, the respective event is emitted onthe Connection instance. In addition to receiving incoming data the Connection classoffers several helper methods e.g. to send data to the underlying VBus connection. The Connection class itself has no knowledge about the underlying VBus connection.Several sub-classes exist that know how to contact different types of VBus live streams. See SerialConnection or TcpConnection for concrete implementations. new Connection(options) Creates a new Connection instance and optionally initializes its member with the given values. Parameters: Name Type Description options object Initialization values for this instance's members Properties Name Type Description channel number See Connection#channel selfAddress number See Connection#selfAddress Source: connection.js Example var connection = new SerialConnection({ path: '/dev/tty.usbserial' }); connection.on('connectionState', function(state) { console.log(state); }); connection.on('packet', function(packet) { console.log(packet.getId()); }); connection.on('datagram', function(datagram) { console.log(datagram.getId()); }); connection.connect(); Extends Duplex Members channel :number The VBus channel that this connection is established to.All Header instances created by this Connection instance will be assignedthis VBus channel. Type: number Source: connection.js connectionState :string The current connection state. Type: string Source: connection.js dataSource :DataSource Reference to this instance's DataSource. Type: DataSource Source: connection.js rxBuffer :Buffer The internal receive buffer of this conneciton. Type: Buffer Source: connection.js selfAddress :number The VBus address used for sending information over this connection. Type: number Source: connection.js Methods &lt;abstract&gt; connect() Establish underlying connection and start streaming data to the writable sideof this Connection instance's stream. Source: connection.js Returns: A promise that resolves once the connection has been established. Type Promise createConnectedPromise() Creates a promise that resolves when this Connectioninstance is connected and rejects if it is disconnected.If it is neither connected nor disconnected the promisewill stay pending until one of the states is entered. Source: connection.js Returns: Type Promise &lt;abstract&gt; disconnect() Diconnect this instance. Source: connection.js getValueById(address, valueId, options) Sends a Datagram to get a value from a device.Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to get the value from valueId number The ID of the value to read from the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to get the value. Source: connection.js Returns: A promise that resolves to the received Datagram or null on timeout. Type Promise getValueIdByIdHash(address, valueIdHash, options) Sends a Datagram to lookup a value ID in a device.Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to lookup the value in. valueIdHash number The ID hash of the value to lookup in the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise getValueIdHashById(address, valueId, options) Sends a Datagram to lookup a value ID hash in a device.Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to lookup the value in. valueId number The ID of the value to lookup in the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise releaseBus(address, options) Sends a VBus bus release datagram (Command 0x0600).Returns a Promise that resolves with the first VBus packet received after the release or null on timeout. Parameters: Name Type Description address number The VBus address of the master device to give the bus ownership back to. options object Properties Name Type Default Description tries number 2 Number of tries to give the bus ownership back. timeout number 1500 Time in milliseconds to wait between tries. Source: connection.js send(data) Send raw data over this Connection instance. Parameters: Name Type Description data Header | Buffer The Header or Buffer instance to be sent. Source: connection.js setValueById(address, valueId, value, options) Sends a Datagram to set a value in a device.Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to set the value in valueId number The ID of the value to write to the device. value number The value to write to the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to get the value. Source: connection.js Returns: A promise that resolves to the received Datagram or null on timeout. Type Promise transceive(txData, options) Sends and / or receives a VBus data. Parameters: Name Type Description txData Header | Buffer The Header or Buffer instance to be sent. options object Properties Name Type Argument Description timeout number Timeout in milliseconds after which the txData will be sent again timeoutIncr number After each timeout retransmission the timeout value for the next try is increment by this value. tries number After this number of tries the returned Promise will resolve with value null. filterPacket function &lt;nullable&gt; Will be called when a Packet has been received with the Packet and a callback as arguments. filterDatagram function &lt;nullable&gt; Will be called when a Datagram has been received with the Datagram and a callback as arguments. Source: connection.js Returns: A Promise that either resolves to the VBus data selected by one of the filter callbacks or null on timeout. Type Promise waitForFreeBus(timeout) Waits for a VBus bus offering datagram (Command 0x0500). Returns a Promise that resolves with the Datagram or null if the method timed out. Parameters: Name Type Default Description timeout number 20000 Timeout in milliseconds Source: connection.js Returns: A Promise that resolves to the bus offering Datagram or null on timeout. Type Promise × Search results Close "},"ConnectionCustomizer.html":{"id":"ConnectionCustomizer.html","title":"Class: ConnectionCustomizer","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: ConnectionCustomizer ConnectionCustomizer A ConnectionCustomizer uses an established connection to a deviceto transfer sets of configuration values over it. new ConnectionCustomizer( [options]) Constructs a new ConnectionCustomizer instance and optionally initializes itsmembers with the given values. Parameters: Name Type Argument Description options object &lt;optional&gt; Initialization values for this instance's members Properties Name Type Argument Description connection number &lt;optional&gt; ConnectionCustomizer#connection maxRounds number &lt;optional&gt; ConnectionCustomizer#maxRounds triesPerValue number &lt;optional&gt; ConnectionCustomizer#triesPerValue timeoutPerValue number &lt;optional&gt; ConnectionCustomizer#timeoutPerValue masterTimeout number &lt;optional&gt; ConnectionCustomizer#masterTimeout Source: connection-customizer.js Extends Customizer Members connection :Connection The connection to use for transfer of the configuration values. Type: Connection Source: connection-customizer.js deviceAddress :number The VBus address of the device to customize. Type: number Inherited From: Customizer#deviceAddress Source: customizer.js id :string An identifier for this customizer. Type: string Inherited From: Customizer#id Source: customizer.js masterTimeout :number Interval in milliseconds in whichthe VBus master is contacted to reissue the VBus clearance. Type: number Default Value: 8000 Source: connection-customizer.js maxRounds :number Maximum number of optimization rounds for transceiveConfiguration. Type: number Default Value: 10 Source: connection-customizer.js optimizer :ConfigurationOptimizer A configuration optimizer. Type: ConfigurationOptimizer Inherited From: Customizer#optimizer Source: customizer.js timeoutPerValue :number Timeout in milliseconds after which the transceive times out. Type: number Default Value: 30000 Source: connection-customizer.js triesPerValue :number Amount of retries to transceive one value.Between two tries the VBus is released and then re-acquired. Type: number Default Value: 2 Source: connection-customizer.js Methods _completeConfiguration(config) Converts the configuration provided into an array of {@see ConfigurationValue} objects.The provided configuration can be either an array of partially initialized ConfigurationValueobjects or an object mapping value IDs as keys to values.If no configuration is given a complete configuration set is returned. Parameters: Name Type Description config undefined | null | array | object Configuration to complete. Inherited From: Customizer#_completeConfiguration Source: customizer.js Returns: A Promise that resolves to the completed array of values. Type Promise _loadConfiguration() Load a set of configuration values from a device. See Customizer#loadConfiguration for details. Source: connection-customizer.js _optimizeLoadConfiguration(config) Gets the optimized array of values based on what values are already loaded. Parameters: Name Type Description config array The array of values that has already been loaded. Inherited From: Customizer#_optimizeLoadConfiguration Source: customizer.js Returns: A Promise that resolves to the array of values to load next. Type Promise _optimizeSaveConfiguration(newConfig, oldConfig) Gets the optimzed array of values to save to the controller. Parameters: Name Type Description newConfig array The array of values to transfer. oldConfig array The array of values that are assumed to be currently stored in the device. Inherited From: Customizer#_optimizeSaveConfiguration Source: customizer.js Returns: A Promise that resolves to the array of values to save. Type Promise _saveConfiguration() Save a set of configuration values to a device. See Customizer#saveConfiguration for details. Source: connection-customizer.js loadConfiguration(configuration, options) Load a set of configuration values from a device. If the Customizer has an optimizer set, the configuration parameteris passed to the optimizer's completeConfiguration method. Otherwise it must be anarray of ConfigurationValue objects. If options.optimize is &quot;truthy&quot; the list of ConfigurationValue objects is passedinto the optimizer's optimizeLoadConfiguration method to determine the minimalset of values to transfer. If options.optimize is &quot;falsy&quot; all of theConfigurationValue objects will be loaded. Parameters: Name Type Description configuration array The set of values to transfer. options object Inherited From: Customizer#loadConfiguration Source: customizer.js Returns: A Promise that resolves to the set of values transfered. Type Promise saveConfiguration(newConfiguration, oldConfiguration, options) Save a set of configuration values to a device. If the Customizer has an optimizer set, the newConfiguration parameteris passed to the optimizer's completeConfiguration method. Otherwise it must be anarray of ConfigurationValue objects. If a oldConfiguration parameter is given, the same procedure as for thenewConfiguration is applied to it as well. If options.optimize is &quot;truthy&quot; the list of ConfigurationValue objects is passedinto the optimizer's optimizeLoadConfiguration method to determine the minimalset of values to transfer. If options.optimize is &quot;falsy&quot; all of theConfigurationValue objects will be loaded. Parameters: Name Type Description newConfiguration array The set of values to transfer. oldConfiguration array The set of values to assume to be stored in the device. options object Inherited From: Customizer#saveConfiguration Source: customizer.js Returns: A Promise that resolves to the set of values transfered. Type Promise transceiveConfiguration(options) Transceives a controller configuration set, handling timeouts, retries etc. Parameters: Name Type Description options object Options Properties Name Type Argument Description maxRounds number &lt;optional&gt; ConnectionCustomizer#maxRounds triesPerValue number &lt;optional&gt; ConnectionCustomizer#triesPerValue timeoutPerValue number &lt;optional&gt; ConnectionCustomizer#timeoutPerValue masterTimeout number &lt;optional&gt; ConnectionCustomizer#masterTimeout action number Action to perform, can be 'get' or 'set'. actionOptions number &lt;optional&gt; Options object to forward to the action to perform. Source: connection-customizer.js Returns: Promise that resolves to the configuration or null on timeout. Type object transceiveValue(valueInfoOrIndex, value, options, state) Transceive a controller value over this connection, handlingtimeouts, retries etc. Parameters: Name Type Description valueInfoOrIndex object | number Value info object or value index valueInfo.valueIndex number Value index valueInfo.valueIdHash number Value ID hash value number Value options object Options Properties Name Type Description triesPerValue number ConnectionCustomizer#triesPerValue timeoutPerValue number ConnectionCustomizer#timeoutPerValue masterTimeout number ConnectionCustomizer#masterTimeout state object State to share between multiple calls to this method. Source: connection-customizer.js Returns: Promise that resolves with the datagram received or null on timeout. Type object × Search results Close "},"Converter.html":{"id":"Converter.html","title":"Class: Converter","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Converter Converter Converter instances are streams that convert VBus models (Packet, Datagram and Telegram instances) and / orHeaderset instances to another representation. Optionally some Converter sub-classes support parsing thatrepresentation back to the model instances. Converter sub-classes include VBusRecordingConverter (forparsing and generating according to the VBus Recording File Format) and TextConverter that createscharacter-separated text representations. new Converter(options) Creates a new Converter instance and optionally initializes its members with the given values. Parameters: Name Type Description options object Initialization values Properties Name Type Description objectMode boolean See Converter#objectMode Source: converter.js Extends Duplex Members objectMode :boolean Specifies whether the underlying stream operates in object mode. Type: boolean Source: converter.js Methods convertHeader(header) This method queues a VBus Header model (Packet, Datagram or Telegram) for conversion.Not all Converter sub-classes support this method. Parameters: Name Type Description header Header The Header to queue for conversion. Source: converter.js convertHeaderSet(headerSet) This method queues a VBus HeaderSet instance for conversion.Not all Converter sub-classes support this method. Parameters: Name Type Description headerSet HeaderSet The HeaderSet to queue for conversion. Source: converter.js convertRawData(rawData) This method queues a VBus raw data chunk from conversion.Not all Converter sub-classes support this method. Parameters: Name Type Description rawData RawData The VBus raw data chunk to queue for conversion. Source: converter.js finish() This method signals that no additional VBus Header or HeaderSet models willbe converted. It returns a promise that resolves when all data has beenconsumed. Source: converter.js Returns: A Promise that resolves when all data has been consumed. Type Promise reset() This method resets the converter. It should be used e.g. if the converter output switches between files (allowssome Converter sub-classes to correctly write a header). Source: converter.js × Search results Close "},"Customizer.html":{"id":"Customizer.html","title":"Class: Customizer","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Customizer Customizer A Customizer provides functionality to transfer a set of configurationvalues from or to a device. new Customizer( [options]) Creates a new Customizer instance and optionally initializes its memberswith the given values. Parameters: Name Type Argument Description options object &lt;optional&gt; Initialization values for this instance's members Properties Name Type Argument Description id string &lt;optional&gt; Customizer#id deviceAddress string &lt;optional&gt; Customizer#deviceAddress optimizer string &lt;optional&gt; Customizer#optimizer Source: customizer.js Members deviceAddress :number The VBus address of the device to customize. Type: number Source: customizer.js id :string An identifier for this customizer. Type: string Source: customizer.js optimizer :ConfigurationOptimizer A configuration optimizer. Type: ConfigurationOptimizer Source: customizer.js Methods _completeConfiguration(config) Converts the configuration provided into an array of {@see ConfigurationValue} objects.The provided configuration can be either an array of partially initialized ConfigurationValueobjects or an object mapping value IDs as keys to values.If no configuration is given a complete configuration set is returned. Parameters: Name Type Description config undefined | null | array | object Configuration to complete. Source: customizer.js Returns: A Promise that resolves to the completed array of values. Type Promise _optimizeLoadConfiguration(config) Gets the optimized array of values based on what values are already loaded. Parameters: Name Type Description config array The array of values that has already been loaded. Source: customizer.js Returns: A Promise that resolves to the array of values to load next. Type Promise _optimizeSaveConfiguration(newConfig, oldConfig) Gets the optimzed array of values to save to the controller. Parameters: Name Type Description newConfig array The array of values to transfer. oldConfig array The array of values that are assumed to be currently stored in the device. Source: customizer.js Returns: A Promise that resolves to the array of values to save. Type Promise loadConfiguration(configuration, options) Load a set of configuration values from a device. If the Customizer has an optimizer set, the configuration parameteris passed to the optimizer's completeConfiguration method. Otherwise it must be anarray of ConfigurationValue objects. If options.optimize is &quot;truthy&quot; the list of ConfigurationValue objects is passedinto the optimizer's optimizeLoadConfiguration method to determine the minimalset of values to transfer. If options.optimize is &quot;falsy&quot; all of theConfigurationValue objects will be loaded. Parameters: Name Type Description configuration array The set of values to transfer. options object Source: customizer.js Returns: A Promise that resolves to the set of values transfered. Type Promise saveConfiguration(newConfiguration, oldConfiguration, options) Save a set of configuration values to a device. If the Customizer has an optimizer set, the newConfiguration parameteris passed to the optimizer's completeConfiguration method. Otherwise it must be anarray of ConfigurationValue objects. If a oldConfiguration parameter is given, the same procedure as for thenewConfiguration is applied to it as well. If options.optimize is &quot;truthy&quot; the list of ConfigurationValue objects is passedinto the optimizer's optimizeLoadConfiguration method to determine the minimalset of values to transfer. If options.optimize is &quot;falsy&quot; all of theConfigurationValue objects will be loaded. Parameters: Name Type Description newConfiguration array The set of values to transfer. oldConfiguration array The set of values to assume to be stored in the device. options object Source: customizer.js Returns: A Promise that resolves to the set of values transfered. Type Promise × Search results Close "},"Datagram.html":{"id":"Datagram.html","title":"Class: Datagram","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Datagram Datagram The Datagram sub-class provides access to all properties and methods applicable for VBus version 2 datagrams.In addition to the packet header it may contain a command, a value ID and a value.The value ID is a device-specific reference to one of the values presented in the device's menu interface. new Datagram(options) Creates a new Datagram instance and optionally initializes its members with the given values. Parameters: Name Type Description options object Initialization values for this instance's members Properties Name Type Description command number Datagram#command valueId number Datagram#valueId value Buffer Datagram#value Source: datagram.js See: Header#constructor Extends Header Members channel :number VBus channel of this header Type: number Inherited From: Header#channel Default Value: 0 Source: header.js command :number The command field of this VBus datagram. See the VBus Protocol Specification for details. Type: number Source: datagram.js destinationAddress :number VBus address of this header's destination Type: number Inherited From: Header#destinationAddress Default Value: 0 Source: header.js sourceAddress :number VBus address of this header's source Type: number Inherited From: Header#sourceAddress Source: header.js timestamp :Date Timestamp of this header Type: Date Inherited From: Header#timestamp Default Value: now Source: header.js value :number The value field of this VBus datagram. Type: number Source: datagram.js valueId :number The value ID field of this VBus datagram. Type: number Source: datagram.js Methods compareTo(that) Compares this Header instance to another one. Sub-classes can extend the comparison to include specificinformation. Parameters: Name Type Description that Header Another Header instance to compare to. Inherited From: Header#compareTo Overrides: Header#compareTo Source: header.js Returns: Returns a number less than 0 if this &lt; that greater than 0 if this &gt; that equal to to if this == that Type number getId() Returns a string identifier describing this Header instance.It contains at least: channel destination address source address protocol version Sub-classes can extend that information. The structure of thisidentifier is implementation specific, do not rely on it! Inherited From: Header#getId Overrides: Header#getId Source: header.js Returns: Identifier Type string getInfo() Returns an info number about this Header instance. It can be usedfor sorting purposes (to distinguish Header objects that wouldotherwise compare as equal). Inherited From: Header#getInfo Overrides: Header#getInfo Source: header.js Returns: Info value Type number &lt;abstract&gt; getProtocolVersion() Returns the protocol version of this Header instance as a 8-bitnumber. The high nibble is used for the major version, the lownibble for the minor version. For example: a header with protocolversion 2.0 would return 0x20. Must be implemented by sub-class. Inherited From: Header#getProtocolVersion Overrides: Header#getProtocolVersion Source: header.js Returns: Protocol version Type number &lt;abstract&gt; toLiveBuffer( [buffer] [, start] [, end]) Creates a representation of this Header instance that can betransmitted over a Connection. If no buffer is given as anarguments, it creates a new one that is big enough to holdthe representation. Must be implemented by sub-class. Parameters: Name Type Argument Description buffer Buffer &lt;optional&gt; Buffer object to store data in start number &lt;optional&gt; Start index in the buffer end number &lt;optional&gt; End index in the buffer Inherited From: Header#toLiveBuffer Overrides: Header#toLiveBuffer Source: header.js Returns: Buffer object containing the data Type Buffer × Search results Close "},"DLxJsonConverter.html":{"id":"DLxJsonConverter.html","title":"Class: DLxJsonConverter","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: DLxJsonConverter DLxJsonConverter The DLxJsonConverter class takes HeaderSet instances, converts them into JSONrepresentation and then publishes that on the readable stream sideof itself. The format of the JSON data is similar to the one that is generatedby the Dataloggers DL2 and DL3. It does not support parsing JSON content back into HeaderSet instances (thewritable stream side). new DLxJsonConverter(options) Creates a new DLxJsonConverter instance and optionally initializes its members with the given values. Parameters: Name Type Description options object Initialization values Properties Name Type Description specification object See DLxJsonConverter#specification Source: dlx-json-converter.js Extends Converter Members objectMode :boolean Specifies whether the underlying stream operates in object mode. Type: boolean Inherited From: Converter#objectMode Source: converter.js specification :Specification Reference to the Specification instance that is used for the binary -&gt; text conversion. Type: Specification Source: dlx-json-converter.js Methods convertHeader(header) This method queues a VBus Header model (Packet, Datagram or Telegram) for conversion.Not all Converter sub-classes support this method. Parameters: Name Type Description header Header The Header to queue for conversion. Inherited From: Converter#convertHeader Source: converter.js convertHeaderSet(headerSet) This method queues a VBus HeaderSet instance for conversion.Not all Converter sub-classes support this method. Parameters: Name Type Description headerSet HeaderSet The HeaderSet to queue for conversion. Inherited From: Converter#convertHeaderSet Overrides: Converter#convertHeaderSet Source: converter.js convertRawData(rawData) This method queues a VBus raw data chunk from conversion.Not all Converter sub-classes support this method. Parameters: Name Type Description rawData RawData The VBus raw data chunk to queue for conversion. Inherited From: Converter#convertRawData Source: converter.js finish() This method signals that no additional VBus Header or HeaderSet models willbe converted. It returns a promise that resolves when all data has beenconsumed. Inherited From: Converter#finish Overrides: Converter#finish Source: converter.js Returns: A Promise that resolves when all data has been consumed. Type Promise reset() This method resets the converter. It should be used e.g. if the converter output switches between files (allowssome Converter sub-classes to correctly write a header). Inherited From: Converter#reset Overrides: Converter#reset Source: converter.js × Search results Close "},"DLxRecorder.html":{"id":"DLxRecorder.html","title":"Class: DLxRecorder","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: DLxRecorder DLxRecorder DLxRecorder is a recorder that can play back data recorded by a Datalogger. new DLxRecorder() Creates a new DLxRecorder instance. Source: dlx-recorder.js Extends Recorder Members id :string Identifier for this recorder instance. It may be used to referencerecorders, for example in sync data storage. Type: string Inherited From: Recorder#id Source: recorder.js interval :number Interval to be used as a default during playback andsynchronization. Type: number Inherited From: Recorder#interval Default Value: 0 Source: recorder.js maxTimestamp :Date Maximum timestamp to use as a default during playback andsynchronization. Type: Date Inherited From: Recorder#maxTimestamp Default Value: '2038-01-01T00:00:00.000Z' Source: recorder.js minTimestamp :Date Minimum timestamp to use as a default during playback andsynchronization. Type: Date Inherited From: Recorder#minTimestamp Default Value: '2001-01-01T00:00:00.000Z' Source: recorder.js password :string The password to login to the web interface. Type: string Source: dlx-recorder.js urlPrefix :string The root URL to access the DLx. Type: string Source: dlx-recorder.js username :string The username to login to the web interface. Type: string Source: dlx-recorder.js Methods _playbackSyncJob(stream, syncJob) Plays back the requested synchronization job, piping the resulting data into theprovided stream. Returns a Promise that resolves to the played back ranges. Parameters: Name Type Description stream Stream The stream (in object mode) to pipe data into syncJob RecorderSyncJob The synchronization job to perform. Inherited From: Recorder#_playbackSyncJob Overrides: Recorder#_playbackSyncJob Source: recorder.js Returns: Promise resolving with a list of ranges that were synchronized. Type Promise _recordSyncJob(recorder, syncJob) Starts a playback of the provided recorder, recording its data and returning aPromise that resolves to the recorded ranges. Parameters: Name Type Description recorder Recorder The recorder to use for playback syncJob RecorderSyncJob The synchronization job to perform. Inherited From: Recorder#_recordSyncJob Source: recorder.js Returns: Promise resolving with a list of ranges that were synchronized. Type Promise playback(stream, options) Plays back a given range of HeaderSets. The stream must be in object mode. Parameters: Name Type Description stream Writable A writable stream options object Options to select and filter HeaderSets Properties Name Type Argument Default Description minTimestamp Date &lt;optional&gt; Recorder#minTimestamp maxTimestamp Date &lt;optional&gt; Recorder#maxTimestamp interval number &lt;optional&gt; Recorder#interval end boolean &lt;optional&gt; true Whether the stream should be end()ed when the playback is complete Inherited From: Recorder#playback Source: recorder.js record(stream, options) Records a given range of HeaderSet instances. The stream must be in object mode. Parameters: Name Type Description stream Readable A readable stream in object mode. options object Options to select and filter HeaderSet instances. Properties Name Type Argument Description minTimestamp Date &lt;optional&gt; See Recorder#minTimestamp maxTimestamp Date &lt;optional&gt; See Recorder#maxTimestamp interval number &lt;optional&gt; See Recorder#interval Inherited From: Recorder#record Source: recorder.js Returns: A Promise that resolves to the recorded ranges. Type Promise synchronizeTo(recorder, options) Synchronize this Recorder's HeaderSets to another Recorder. Parameters: Name Type Description recorder Recorder Destination Recorder options object Options to select and filter HeaderSets Properties Name Type Argument Description minTimestamp Date &lt;optional&gt; Recorder#minTimestamp maxTimestamp Date &lt;optional&gt; Recorder#maxTimestamp interval number &lt;optional&gt; Recorder#interval Inherited From: Recorder#synchronizeTo Source: recorder.js Returns: Promise resolving with a list of ranges that were synchronized. Type Promise × Search results Close "},"Header.html":{"id":"Header.html","title":"Class: Header","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Header Header All VBus models are sub-classes of this Header class. The Header class providesa generic interface and the common properties that all (currently three)different types of VBus models can use. Header instances can either be created by calling the constructor function orby passing a Buffer object containing the binary VBus data to the class methodHeaderSubClass.fromLiveBuffer. new Header( [options]) Creates a new Header instance and optionally initializes its memberswith the given values Parameters: Name Type Argument Description options object &lt;optional&gt; Initialization values for this instance's members Properties Name Type Argument Description timestamp Date &lt;optional&gt; Header#timestamp channel number &lt;optional&gt; Header#channel destinationAddress number &lt;optional&gt; Header#destinationAddress sourceAddress number &lt;optional&gt; Header#sourceAddress Source: header.js See: Packet Datagram Telegram Members channel :number VBus channel of this header Type: number Default Value: 0 Source: header.js destinationAddress :number VBus address of this header's destination Type: number Default Value: 0 Source: header.js sourceAddress :number VBus address of this header's source Type: number Source: header.js timestamp :Date Timestamp of this header Type: Date Default Value: now Source: header.js Methods &lt;static&gt; calcAndCompareChecksumV0(buffer, start, end) Calculates the VBus checksum (according to version x.0 specification)over a part of a Buffer instance and compares it the checksum bytestored at the end position. Parameters: Name Type Description buffer Buffer Buffer to calc and compare checksum for start number Start index in the buffer end number End index in the buffer Source: header.js Returns: Result whether calculated and stored checksum match Type boolean &lt;static&gt; calcAndSetChecksumV0(buffer, start, end) Calculates the VBus checksum (according to version x.0 specification)over a part of the Buffer instance and stores it at the end position. Parameters: Name Type Description buffer Buffer Buffer to calc and store checksum for start number Start index in the buffer end number End index in the buffer Source: header.js Returns: Calculated checksum Type number &lt;static&gt; calcChecksumV0(buffer, start, end) Calculates the VBus checksum (according to version x.0 specification)over a part of a Buffer instance. Parameters: Name Type Description buffer Buffer Buffer to calc checksum for start number Start index in the buffer end number End index in the buffer Source: header.js Returns: Calculated checksum Type number &lt;static&gt; extractSeptett(srcBuffer, srcStart, srcEnd, dstBuffer, dstStart) Copies a part of the source Buffer instance to the destination Bufferinstance, extracting the MSBs during the process and storing the septettbyte to the destination buffer's end position. Parameters: Name Type Description srcBuffer Buffer Buffer to copy from srcStart number Start index in the source buffer srcEnd number End index in the source buffer dstBuffer Buffer Buffer to copy to dstStart number Start index in the destination buffer Source: header.js &lt;abstract, static&gt; fromLiveBuffer(buffer, start, end) Creates a Header instance from a representation that wasreceived over a Connection. Must be implemented by sub-class. Parameters: Name Type Description buffer Buffer Buffer that contains the representation start number Start index in the buffer end number End index in the buffer Source: header.js Returns: Header instance created from the representation Type Header &lt;static&gt; injectSeptett(srcBuffer, srcStart, srcEnd, dstBuffer, dstStart) Copies a part of the source Buffer instance to the destination Bufferinstance, injecting the MSBs stored in the septett byte during the process. Parameters: Name Type Description srcBuffer Buffer Buffer to copy from srcStart number Start index in the source buffer srcEnd number End index in the source buffer dstBuffer Buffer Buffer to copy to dstStart number Start index in the destination buffer Source: header.js compareTo(that) Compares this Header instance to another one. Sub-classes can extend the comparison to include specificinformation. Parameters: Name Type Description that Header Another Header instance to compare to. Source: header.js Returns: Returns a number less than 0 if this &lt; that greater than 0 if this &gt; that equal to to if this == that Type number getId() Returns a string identifier describing this Header instance.It contains at least: channel destination address source address protocol version Sub-classes can extend that information. The structure of thisidentifier is implementation specific, do not rely on it! Source: header.js Returns: Identifier Type string getInfo() Returns an info number about this Header instance. It can be usedfor sorting purposes (to distinguish Header objects that wouldotherwise compare as equal). Source: header.js Returns: Info value Type number &lt;abstract&gt; getProtocolVersion() Returns the protocol version of this Header instance as a 8-bitnumber. The high nibble is used for the major version, the lownibble for the minor version. For example: a header with protocolversion 2.0 would return 0x20. Must be implemented by sub-class. Source: header.js Returns: Protocol version Type number &lt;abstract&gt; toLiveBuffer( [buffer] [, start] [, end]) Creates a representation of this Header instance that can betransmitted over a Connection. If no buffer is given as anarguments, it creates a new one that is big enough to holdthe representation. Must be implemented by sub-class. Parameters: Name Type Argument Description buffer Buffer &lt;optional&gt; Buffer object to store data in start number &lt;optional&gt; Start index in the buffer end number &lt;optional&gt; End index in the buffer Source: header.js Returns: Buffer object containing the data Type Buffer × Search results Close "},"HeaderSet.html":{"id":"HeaderSet.html","title":"Class: HeaderSet","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: HeaderSet HeaderSet new HeaderSet(options) Creates a new header set instance and optionally initializes its members with the given values. Parameters: Name Type Description options object Initialization values for this instance's members Properties Name Type Description timestamp Date HeaderSet#timestamp headers Array.&lt;Header&gt; Array of Headers to add to this instance Source: header-set.js Extends EventEmitter Members headerList :Array.&lt;Header&gt; Array of Header instances in this set. Type: Array.&lt;Header&gt; Source: header-set.js timestamp :Date Timestamp of the youngest Header instance added to this set. Type: Date Source: header-set.js Methods addHeader(header) Adds a Header instance to this set, replacing a previously added Header of same kind. Parameters: Name Type Description header Header The Header instance to add to this set. Source: header-set.js addHeaders(headers) Adds a list of Header instances to this set, replacing previously added Headers of same kind. Parameters: Name Type Description headers Array.&lt;Header&gt; The list of Header instances to add. Source: header-set.js containsHeader() Returns true if a Header of the same kind is already added to the HeaderSet. Source: header-set.js Returns: true if a Header of the same kind is already in the HeaderSet, false otherwise. Type boolean getHeaderCount() Returns the count of Header instances currently stored in this set. Source: header-set.js Returns: Number of Header instances in this set. Type number getHeaders() Returns an unsorted list of Header instances stored in this set. Source: header-set.js Returns: List of headers stored in this set. Type Array.&lt;Header&gt; getId() Returns an ID composed of the IDs of all headers stored in this set. Source: header-set.js Returns: ID of this HeaderSet. Type string getIdHash() Returns an ID hash for this HeaderSet instance. Source: header-set.js Returns: ID hash for this HeaderSet Type string getSortedHeaders() Returns a sorted list of Header instances stored in this set. Source: header-set.js Returns: List of headers stored in this set. Type Array.&lt;Header&gt; removeAllHeaders() Removes all Header instances from this set. Source: header-set.js removeHeadersOlderThan(timestamp) Removes all Header instances from this set which are older than the given timestamp. Parameters: Name Type Description timestamp number | Date Timestamp to compare Header instances against. Source: header-set.js Events addHeader This event is fired whenever a Header instance is added to this set. Type: Header Source: header-set.js removeHeader This event is fired whenever a Header is removed from this set. Type: Header Source: header-set.js × Search results Close "},"HeaderSetConsolidator.html":{"id":"HeaderSetConsolidator.html","title":"Class: HeaderSetConsolidator","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: HeaderSetConsolidator HeaderSetConsolidator The HeaderSetConsolidator extends the functionality of the HeaderSet classby allowing to filter and organize the Header instances added to it. There are two common use cases for this class: The first use case is in combination with a Connection. As live Header instancesare reported by their corresponding event they are aded to the HeaderSetConsolidatorinstance using addHeader or addHeaders methods. The startTimer methodis used to start a background timer that fires a headerSet event everytime the given interval has passed. The second use case is in combination with Recorders. In that case no timerhas to be started because the data is not received in real time. As recorded HeaderSetinstances are played back they are can be handed over to the processHeaderSetmethod. This method will fire a headerSet event every time the recorded databelong to a different interval. new HeaderSetConsolidator(options) Creates a new instances and optionally initializes its members to the given values. Parameters: Name Type Description options object Properties Name Type Description interval number See HeaderSetConsolidator#interval timeToLive number See HeaderSetConsolidator#timeToLive minTimestamp number See HeaderSetConsolidator#minTimestamp maxTimestamp number See HeaderSetConsolidator#maxTimestamp Source: header-set-consolidator.js Example // --- use case 1: live data --- var connection = createConnection(); // create a HeaderSetConsolidator that fires a headerSet event every minute var hsc = new HeaderSetConsolidator({ interval: 1 * 60 * 1000 }); // add an event handlers to the connection that adds incoming headers to the consolidator var onHeader = function(header) { hsc.addHeader(header); }; connection.on('packet', onHeader); connection.on('datagram', onHeader); connection.on('telegram', onHeader); // add an event handler to the consolidator hsc.on('headerSet', function(headerSet) { console.log(headerSet); }); // start the timer hsc.startTimer(); // --- use case 2: recorded data --- var stream = getRecordedDataStream(); var converter = new VBusRecordingConverter(); // create a HeaderSetConsolidator that sieves incoming headers var hsc = new HeaderSetConsolidator({ interval: 60 * 60 * 1000 }); // add an event handler to the converter that processes incoming header sets in the consolidator converter.on('headerSet', function(headerSet) { hsc.processHeaderSet(headerSet); }); // add an event handler to the consolidator hsc.on('headerSet', function(headerSet) { console.log(headerSet); }); // start the conversion stream.pipe(converter); Extends HeaderSet Members headerList :Array.&lt;Header&gt; Array of Header instances in this set. Type: Array.&lt;Header&gt; Inherited From: HeaderSet#headerList Source: header-set.js interval :number The interval in which the headerSet event should be emitted. Type: number Source: header-set-consolidator.js maxTimestamp :Date HeaderSet instances from a time after this Date are ignored. Type: Date Source: header-set-consolidator.js minTimestamp :Date HeaderSet instances from a time before this Date are ignored. Type: Date Source: header-set-consolidator.js timestamp :Date Timestamp of the youngest Header instance added to this set. Type: Date Inherited From: HeaderSet#timestamp Overrides: HeaderSet#timestamp Source: header-set.js timeToLive :number Header instances that are older then this duration are removed from the set. Type: number Source: header-set-consolidator.js Methods addHeader(header) Adds a Header instance to this set, replacing a previously added Header of same kind. Parameters: Name Type Description header Header The Header instance to add to this set. Inherited From: HeaderSet#addHeader Source: header-set.js addHeaders(headers) Adds a list of Header instances to this set, replacing previously added Headers of same kind. Parameters: Name Type Description headers Array.&lt;Header&gt; The list of Header instances to add. Inherited From: HeaderSet#addHeaders Source: header-set.js containsHeader() Returns true if a Header of the same kind is already added to the HeaderSet. Inherited From: HeaderSet#containsHeader Source: header-set.js Returns: true if a Header of the same kind is already in the HeaderSet, false otherwise. Type boolean getHeaderCount() Returns the count of Header instances currently stored in this set. Inherited From: HeaderSet#getHeaderCount Source: header-set.js Returns: Number of Header instances in this set. Type number getHeaders() Returns an unsorted list of Header instances stored in this set. Inherited From: HeaderSet#getHeaders Source: header-set.js Returns: List of headers stored in this set. Type Array.&lt;Header&gt; getId() Returns an ID composed of the IDs of all headers stored in this set. Inherited From: HeaderSet#getId Source: header-set.js Returns: ID of this HeaderSet. Type string getIdHash() Returns an ID hash for this HeaderSet instance. Inherited From: HeaderSet#getIdHash Source: header-set.js Returns: ID hash for this HeaderSet Type string getSortedHeaders() Returns a sorted list of Header instances stored in this set. Inherited From: HeaderSet#getSortedHeaders Source: header-set.js Returns: List of headers stored in this set. Type Array.&lt;Header&gt; processHeaderSet(headerSet) Process the given HeaderSet instance. The Header instances in it areadded to the HeaderSetConsolidator. Parameters: Name Type Description headerSet HeaderSet The HeaderSet instance to process. Source: header-set-consolidator.js removeAllHeaders() Removes all Header instances from this set. Inherited From: HeaderSet#removeAllHeaders Source: header-set.js removeHeadersOlderThan(timestamp) Removes all Header instances from this set which are older than the given timestamp. Parameters: Name Type Description timestamp number | Date Timestamp to compare Header instances against. Inherited From: HeaderSet#removeHeadersOlderThan Source: header-set.js startTimer() Starts a timer that processes live HeaderSets automatically. Source: header-set-consolidator.js stopTimer() Stops the timer that was started by startTimer. Source: header-set-consolidator.js Events addHeader This event is fired whenever a Header instance is added to this set. Type: Header Inherited From: HeaderSet#event:addHeader Source: header-set.js removeHeader This event is fired whenever a Header is removed from this set. Type: Header Inherited From: HeaderSet#event:removeHeader Source: header-set.js × Search results Close "},"I18N.html":{"id":"I18N.html","title":"Class: I18N","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: I18N I18N new I18N( [language]) Creates a new I18N instance for the given language code. Parameters: Name Type Argument Default Description language string &lt;optional&gt; 'en' Language code (ISO 639-1) Source: i18n.js Methods moment(args) Wrapper for a moment.js date object that is setup to use thisinstance's language code. Parameters: Name Type Argument Description args mixed &lt;repeatable&gt; Arguments to be passed to moment() function Source: i18n.js See: http://momentjs.com/docs/ Returns: Result of calling the moment() function Type mixed momentUtc(args) Wrapper for a moment.js UTC date object that is setup to use thisinstance's language code. Parameters: Name Type Argument Description args mixed &lt;repeatable&gt; Arguments to be passed to moment.utc() function Source: i18n.js See: http://momentjs.com/docs/ Returns: Result of calling the moment.utc() function Type mixed numeral(args) Wrapper for a numeral.js number object that is setup to use thisinstance's language code. Parameters: Name Type Argument Description args mixed &lt;repeatable&gt; Arguments to be passes to numeral() function Source: i18n.js See: http://numeraljs.com/ Returns: Result of calling the numeral() function Type mixes sprintf(fmt, args) Formats a string using a printf(3) compatible format string andvariadic arguments (comparable to sprintf(3)) and returns it. Parameters: Name Type Argument Description fmt string Format string args mixed &lt;repeatable&gt; Arguments to format Source: i18n.js See: http://linux.die.net/man/3/sprintf http://www.diveintojavascript.com/projects/javascript-sprintf Returns: Formatted string Type string Example // outputs: VBus #3: DeltaSol MX console.log(i18n.sprintf('VBus #%d: %s', 3, 'DeltaSol MX')); // outputs: DeltaSol MX console.log(i18n.sprintf('%2$s', 3, 'DeltaSol MX')); t(key, args) Get a translation for the given key. If more than one argument isgiven, the translation is then used as a format string for theI18N#sprintf method. Parameters: Name Type Argument Description key string Key for the translation args mixed &lt;repeatable&gt; Arguments to format Source: i18n.js Returns: Formatted string Type string Example var i18n = new I18N('de'); // outputs: Unbekanntes Gerät (0x%1$04X) console.log(i18n.t('specification.unknownDevice')); // outputs: Unbekanntes Gerät (0x7E11) console.log(i18n.t('specification.unknownDevice', 0x7e11)); vsprintf(fmt, argv) Formats a string using a printf(3) compatible format string anda arguments array (comparable to vsprintf(3)) and returns it. Parameters: Name Type Description fmt string Format string argv Array Arguments to format Source: i18n.js Returns: Formatted string Type string Example // outputs: VBus #3: DeltaSol MX console.log(i18n.vsprintf('VBus #%d: %s', [ 3, 'DeltaSol MX' ])); // outputs: DeltaSol MX console.log(i18n.vsprintf('%2$s', [ 3, 'DeltaSol MX' ])); × Search results Close "},"Packet.html":{"id":"Packet.html","title":"Class: Packet","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Packet Packet The Packet sub-class provides access to all properties and methods applicable for VBus version 1 packets.In addition to the packet header it may contain up to 508 bytes of payload data.The structure of the payload depends on the combination of destination and source addresses as well asthe command of the packet. The different payloads are described in further detailin Chapter H of the VBus Protocol Specification and can be decoded using a Specification instance. new Packet(options) Creates a new Packet instance and optionally initializes its members with the given values. Parameters: Name Type Description options object Initialization values for this instance's members Properties Name Type Description command number Packet#command frameCount number Packet#frameCount frameData Buffer Packet#frameData Source: packet.js See: Header#constructor Specification Extends Header Members channel :number VBus channel of this header Type: number Inherited From: Header#channel Default Value: 0 Source: header.js command :number The command field of this VBus packet. See the VBus Protocol specification for details. Type: number Source: packet.js destinationAddress :number VBus address of this header's destination Type: number Inherited From: Header#destinationAddress Default Value: 0 Source: header.js frameCount :number The number of frames of this VBus packet. Each frame can hold four bytes of payload. Type: number Source: packet.js frameData The buffer containing the frame data of this VBus packet. Source: packet.js sourceAddress :number VBus address of this header's source Type: number Inherited From: Header#sourceAddress Source: header.js timestamp :Date Timestamp of this header Type: Date Inherited From: Header#timestamp Default Value: now Source: header.js Methods compareTo(that) Compares this Header instance to another one. Sub-classes can extend the comparison to include specificinformation. Parameters: Name Type Description that Header Another Header instance to compare to. Inherited From: Header#compareTo Overrides: Header#compareTo Source: header.js Returns: Returns a number less than 0 if this &lt; that greater than 0 if this &gt; that equal to to if this == that Type number getId() Returns a string identifier describing this Header instance.It contains at least: channel destination address source address protocol version Sub-classes can extend that information. The structure of thisidentifier is implementation specific, do not rely on it! Inherited From: Header#getId Overrides: Header#getId Source: header.js Returns: Identifier Type string getInfo() Returns an info number about this Header instance. It can be usedfor sorting purposes (to distinguish Header objects that wouldotherwise compare as equal). Inherited From: Header#getInfo Source: header.js Returns: Info value Type number &lt;abstract&gt; getProtocolVersion() Returns the protocol version of this Header instance as a 8-bitnumber. The high nibble is used for the major version, the lownibble for the minor version. For example: a header with protocolversion 2.0 would return 0x20. Must be implemented by sub-class. Inherited From: Header#getProtocolVersion Overrides: Header#getProtocolVersion Source: header.js Returns: Protocol version Type number &lt;abstract&gt; toLiveBuffer( [buffer] [, start] [, end]) Creates a representation of this Header instance that can betransmitted over a Connection. If no buffer is given as anarguments, it creates a new one that is big enough to holdthe representation. Must be implemented by sub-class. Parameters: Name Type Argument Description buffer Buffer &lt;optional&gt; Buffer object to store data in start number &lt;optional&gt; Start index in the buffer end number &lt;optional&gt; End index in the buffer Inherited From: Header#toLiveBuffer Overrides: Header#toLiveBuffer Source: header.js Returns: Buffer object containing the data Type Buffer × Search results Close "},"Recorder.html":{"id":"Recorder.html","title":"Class: Recorder","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Recorder Recorder A Recorder provides access to HeaderSet stores (e.g. dataloggers) byallowing to either playback the HeaderSets in the store, recordHeaderSets to the store or synchronize two Recorders. The playback and record operation both use the VBusRecordingConverterto serialize the HeaderSets to and from Node.js streams. The synchronization operation builds on top of this two operationsand is able to find unsynced HeaderSets in the source Recorder.Thoses unsynced HeaderSets are then played back from the source Recorderand recorded in the destination Recorder. The storage mechanism and format of the Recorder sub-classes isimplementation-specific to this class. new Recorder(options) Creates a new Recorder instance and optionally initializesits members with the given values. Parameters: Name Type Description options object Initialization values for this instance's members Properties Name Type Description id string Recorder#id minTimestamp Date Recorder#minTimestamp maxTimestamp Date Recorder#maxTimestamp interval number Recorder#interval Source: recorder.js Members id :string Identifier for this recorder instance. It may be used to referencerecorders, for example in sync data storage. Type: string Source: recorder.js interval :number Interval to be used as a default during playback andsynchronization. Type: number Default Value: 0 Source: recorder.js maxTimestamp :Date Maximum timestamp to use as a default during playback andsynchronization. Type: Date Default Value: '2038-01-01T00:00:00.000Z' Source: recorder.js minTimestamp :Date Minimum timestamp to use as a default during playback andsynchronization. Type: Date Default Value: '2001-01-01T00:00:00.000Z' Source: recorder.js Methods &lt;static&gt; performRangeSetOperation(rangesA, rangesB, interval, operation) Performs operations on two sets of timestamp ranges. Timestamp ranges are objects with two properties: minTimestamp and maxTimestamp. The operations correspond to the operations in mathematic's set theory.Currently supported are union, difference and intersection. See http://en.wikipedia.org/wiki/Set_theory for details. Parameters: Name Type Description rangesA Array Set A containing timestamp ranges rangesB Array Set B containing timestamp ranges interval number Interval to allow between adjacent timestamp ranges operation string Operation to perform, can be 'union', 'difference' or 'intersection' Source: recorder.js Returns: Set containing timestamp ranges after the operation Type Array _playbackSyncJob(stream, syncJob) Plays back the requested synchronization job, piping the resulting data into theprovided stream. Returns a Promise that resolves to the played back ranges. Parameters: Name Type Description stream Stream The stream (in object mode) to pipe data into syncJob RecorderSyncJob The synchronization job to perform. Source: recorder.js Returns: Promise resolving with a list of ranges that were synchronized. Type Promise _recordSyncJob(recorder, syncJob) Starts a playback of the provided recorder, recording its data and returning aPromise that resolves to the recorded ranges. Parameters: Name Type Description recorder Recorder The recorder to use for playback syncJob RecorderSyncJob The synchronization job to perform. Source: recorder.js Returns: Promise resolving with a list of ranges that were synchronized. Type Promise playback(stream, options) Plays back a given range of HeaderSets. The stream must be in object mode. Parameters: Name Type Description stream Writable A writable stream options object Options to select and filter HeaderSets Properties Name Type Argument Default Description minTimestamp Date &lt;optional&gt; Recorder#minTimestamp maxTimestamp Date &lt;optional&gt; Recorder#maxTimestamp interval number &lt;optional&gt; Recorder#interval end boolean &lt;optional&gt; true Whether the stream should be end()ed when the playback is complete Source: recorder.js record(stream, options) Records a given range of HeaderSet instances. The stream must be in object mode. Parameters: Name Type Description stream Readable A readable stream in object mode. options object Options to select and filter HeaderSet instances. Properties Name Type Argument Description minTimestamp Date &lt;optional&gt; See Recorder#minTimestamp maxTimestamp Date &lt;optional&gt; See Recorder#maxTimestamp interval number &lt;optional&gt; See Recorder#interval Source: recorder.js Returns: A Promise that resolves to the recorded ranges. Type Promise synchronizeTo(recorder, options) Synchronize this Recorder's HeaderSets to another Recorder. Parameters: Name Type Description recorder Recorder Destination Recorder options object Options to select and filter HeaderSets Properties Name Type Argument Description minTimestamp Date &lt;optional&gt; Recorder#minTimestamp maxTimestamp Date &lt;optional&gt; Recorder#maxTimestamp interval number &lt;optional&gt; Recorder#interval Source: recorder.js Returns: Promise resolving with a list of ranges that were synchronized. Type Promise × Search results Close "},"SerialConnection.html":{"id":"SerialConnection.html","title":"Class: SerialConnection","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: SerialConnection SerialConnection The SerialConnection class provides asscess to a VBus live data stream using a serial port. new SerialConnection(options) Creates a new SerialConnection instance and optionally initialized its member with the given values. Parameters: Name Type Description options object Initialization values Properties Name Type Description path string See SerialConnection#path Source: serial-connection.js Extends Connection Members channel :number The VBus channel that this connection is established to.All Header instances created by this Connection instance will be assignedthis VBus channel. Type: number Inherited From: Connection#channel Source: connection.js connectionState :string The current connection state. Type: string Inherited From: Connection#connectionState Source: connection.js dataSource :DataSource Reference to this instance's DataSource. Type: DataSource Inherited From: Connection#dataSource Source: connection.js path :string The path to the serial port. Type: string Source: serial-connection.js reconnectTimeout :number Timeout in milliseconds to way between reconnection retries. Type: number Source: serial-connection.js reconnectTimeoutIncr :number Value to increment timeout after every unsuccessful reconnection retry. Type: number Source: serial-connection.js reconnectTimeoutMax :number Maximum timeout value between unsuccessful reconnection retry. Type: number Source: serial-connection.js rxBuffer :Buffer The internal receive buffer of this conneciton. Type: Buffer Inherited From: Connection#rxBuffer Source: connection.js selfAddress :number The VBus address used for sending information over this connection. Type: number Inherited From: Connection#selfAddress Source: connection.js Methods &lt;abstract&gt; connect() Establish underlying connection and start streaming data to the writable sideof this Connection instance's stream. Inherited From: Connection#connect Overrides: Connection#connect Source: connection.js Returns: A promise that resolves once the connection has been established. Type Promise createConnectedPromise() Creates a promise that resolves when this Connectioninstance is connected and rejects if it is disconnected.If it is neither connected nor disconnected the promisewill stay pending until one of the states is entered. Inherited From: Connection#createConnectedPromise Source: connection.js Returns: Type Promise &lt;abstract&gt; disconnect() Diconnect this instance. Inherited From: Connection#disconnect Overrides: Connection#disconnect Source: connection.js getValueById(address, valueId, options) Sends a Datagram to get a value from a device.Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to get the value from valueId number The ID of the value to read from the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to get the value. Inherited From: Connection#getValueById Source: connection.js Returns: A promise that resolves to the received Datagram or null on timeout. Type Promise getValueIdByIdHash(address, valueIdHash, options) Sends a Datagram to lookup a value ID in a device.Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to lookup the value in. valueIdHash number The ID hash of the value to lookup in the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#getValueIdByIdHash Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise getValueIdHashById(address, valueId, options) Sends a Datagram to lookup a value ID hash in a device.Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to lookup the value in. valueId number The ID of the value to lookup in the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#getValueIdHashById Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise releaseBus(address, options) Sends a VBus bus release datagram (Command 0x0600).Returns a Promise that resolves with the first VBus packet received after the release or null on timeout. Parameters: Name Type Description address number The VBus address of the master device to give the bus ownership back to. options object Properties Name Type Default Description tries number 2 Number of tries to give the bus ownership back. timeout number 1500 Time in milliseconds to wait between tries. Inherited From: Connection#releaseBus Source: connection.js send(data) Send raw data over this Connection instance. Parameters: Name Type Description data Header | Buffer The Header or Buffer instance to be sent. Inherited From: Connection#send Source: connection.js setValueById(address, valueId, value, options) Sends a Datagram to set a value in a device.Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to set the value in valueId number The ID of the value to write to the device. value number The value to write to the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to get the value. Inherited From: Connection#setValueById Source: connection.js Returns: A promise that resolves to the received Datagram or null on timeout. Type Promise transceive(txData, options) Sends and / or receives a VBus data. Parameters: Name Type Description txData Header | Buffer The Header or Buffer instance to be sent. options object Properties Name Type Argument Description timeout number Timeout in milliseconds after which the txData will be sent again timeoutIncr number After each timeout retransmission the timeout value for the next try is increment by this value. tries number After this number of tries the returned Promise will resolve with value null. filterPacket function &lt;nullable&gt; Will be called when a Packet has been received with the Packet and a callback as arguments. filterDatagram function &lt;nullable&gt; Will be called when a Datagram has been received with the Datagram and a callback as arguments. Inherited From: Connection#transceive Source: connection.js Returns: A Promise that either resolves to the VBus data selected by one of the filter callbacks or null on timeout. Type Promise waitForFreeBus(timeout) Waits for a VBus bus offering datagram (Command 0x0500). Returns a Promise that resolves with the Datagram or null if the method timed out. Parameters: Name Type Default Description timeout number 20000 Timeout in milliseconds Inherited From: Connection#waitForFreeBus Source: connection.js Returns: A Promise that resolves to the bus offering Datagram or null on timeout. Type Promise × Search results Close "},"SerialDataSource.html":{"id":"SerialDataSource.html","title":"Class: SerialDataSource","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: SerialDataSource SerialDataSource new SerialDataSource() Creates a new SerialDataSource. Source: serial-data-source.js Extends DataSource Members path The path to the serial port. Source: serial-data-source.js × Search results Close "},"Specification.html":{"id":"Specification.html","title":"Class: Specification","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Specification Specification new Specification(options) Creates a new Specification instance and optionally initializes its members with the given values. Parameters: Name Type Description options object Initialization values for this instance's members Properties Name Type Description language string Specification#language specificationData string Specification#specificationData Source: specification.js Members i18n :I18N I18N instance Type: I18N Source: specification.js language :string Language code (ISO 639-1) Type: string Source: specification.js specificationData :object Custom specification data to be mixed-in to built-in specification. Type: object Source: specification.js Methods convertRawValue(rawValue, sourceUnit, targetUnit) Converts a raw number value from one unit to another. The units must be in the same unit family. Parameters: Name Type Description rawValue number Raw number value to convert from sourceUnit Unit Unit to convert from targetUnit Unit Unit to convert to Source: specification.js Returns: Result containing a rawValue property with the conversion result and a unit property with the associated unit. Type object formatTextValueFromRawValue(packetField, rawValue [, unit]) Formats a raw value into its textual representation. Parameters: Name Type Argument Description packetField PacketFieldSpecification PacketFieldSpecification object rawValue number Raw value unit string | UnitSpecification | null &lt;optional&gt; Unit to format to Source: specification.js Returns: Textual representation of the raw value Type string Example &gt; var packetFieldSpec = spec.getPacketFieldSpecification('01_0010_7721_10_0100_000_2_0'); undefined &gt; var rawValue = 888.8000000000001; undefined &gt; console.log(spec.formatTextValueFromRawValue(packetFieldSpec, rawValue, 'DegreesCelsius')); 888.8 °C undefined &gt; getBlockTypeFieldsForSections(sections) Gets an array of PacketField objects for the provided BlockTypeSection objects. Parameters: Name Type Description sections Array.&lt;BlockTypeSection&gt; Array of BlockTypeSection objects. Source: specification.js Returns: Array of PacketField objects Type Array.&lt;PacketField&gt; getBlockTypePacketSpecificationsForSections(sections) Gets the PacketSpecification objects matching the given BlockTypeSection objects. Parameters: Name Type Description sections Array.&lt;BlockTypeSection&gt; Array of BlockTypeSection objects Source: specification.js Returns: Array of PacketSpecificationObjects Type Array.&lt;PacketSpecification&gt; getBlockTypeSectionsForHeaders(headers) Gets an array of BlockType sections from a collection of headers. Parameters: Name Type Description headers Array.&lt;Header&gt; Array of Header objects Source: specification.js Returns: Array of BlockTypeSection objects Type Array.&lt;BlockTypeSection&gt; getDeviceSpecification(header, which) Gets the DeviceSpecification object matching the given header and direction. Parameters: Name Type Description header Header Header instance which string Either 'source' or 'destination' Source: specification.js Returns: DeviceSpecification object Type DeviceSpecification getDeviceSpecification(selfAddress, peerAddress [, channel]) Gets the DeviceSpecification object matching the given arguments. Parameters: Name Type Argument Default Description selfAddress number VBus address of the device itself peerAddress number VBus address of the device's peer channel number &lt;optional&gt; 0 VBus channel of the device Source: specification.js Returns: DeviceSpecification object Type DeviceSpecification Example &gt; console.log(spec.getDeviceSpecification(0x7E11, 0x0000, 1)); { name: 'DeltaSol MX [Regler]', deviceId: '01_7E11_0000', channel: 1, selfAddress: 32273, peerAddress: 0, fullName: 'VBus #1: DeltaSol MX [Regler]' } undefined &gt; getPacketFieldsForHeaders(headers) Gets an array of PacketField objects for the provided Packet objects. Parameters: Name Type Description headers Array.&lt;Header&gt; Array of Header objects Source: specification.js Returns: Array of PacketField objects Type Array.&lt;PacketField&gt; getPacketFieldSpecification(packetFieldId) Gets the PacketFieldSpecification object matching the given arguments. Parameters: Name Type Description packetFieldId string Packet field identifier Source: specification.js Returns: PacketFieldSpecification object Type PacketFieldSpecification Example &gt; console.log(spec.getPacketFieldSpecification('01_0010_7E21_10_0100_000_2_0')); { fieldId: '000_2_0', name: { ref: 'Flow set temperature', en: 'Flow set temperature', de: 'Vorlauf-Soll-Temperatur', fr: 'Température nominale départ' }, type: { typeId: 'Number_0_1_DegreesCelsius', rootTypeId: 'Number', precision: 1, unit: { unitId: 'DegreesCelsius', unitCode: 'DegreesCelsius', unitText: ' °C' } }, getRawValue: [Function] } undefined &gt; getPacketFieldSpecification(packetSpec, fieldId) Gets the PacketFieldSpecification object matching the given arguments. Parameters: Name Type Description packetSpec PacketSpecification PacketSpecification object fieldId string Field identifier Source: specification.js Returns: PacketFieldSpecification object Type PacketFieldSpecification Example &gt; var packetSpec = spec.getPacketSpecification('01_0010_7E21_10_0100'); undefined &gt; console.log(spec.getPacketFieldSpecification(packetSpec, '000_2_0')); { fieldId: '000_2_0', name: { ref: 'Flow set temperature', en: 'Flow set temperature', de: 'Vorlauf-Soll-Temperatur', fr: 'Température nominale départ' }, type: { typeId: 'Number_0_1_DegreesCelsius', rootTypeId: 'Number', precision: 1, unit: { unitId: 'DegreesCelsius', unitCode: 'DegreesCelsius', unitText: ' °C' } }, getRawValue: [Function] } undefined &gt; getPacketSpecification(packetSpecId) Gets the PacketSpecification object matching the given arguments. Parameters: Name Type Description packetSpecId string PacketSpecification identifier Source: specification.js Returns: PacketSpecification object Type PacketSpecification Example &gt; console.log(spec.getPacketSpecification('01_0010_7E21_10_0100')); { packetId: '01_0010_7E21_10_0100', packetFields: [ { fieldId: '000_2_0', name: [Object], type: [Object], getRawValue: [Function] }, { fieldId: '002_1_0', name: [Object], type: [Object], getRawValue: [Function] } ], channel: 1, destinationAddress: 16, sourceAddress: 32289, protocolVersion: 16, command: 256, info: 0, destinationDevice: { name: 'DFA', deviceId: '01_0010_7E21', channel: 1, selfAddress: 16, peerAddress: 32289, fullName: 'VBus #1: DFA' }, sourceDevice: { name: 'DeltaSol MX [Heizkreis #1]', deviceId: '01_7E21_0010', channel: 1, selfAddress: 32289, peerAddress: 16, fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' }, fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' } undefined &gt; getPacketSpecification(packet) Gets the PacketSpecification object matching the given packet. Parameters: Name Type Description packet Packet VBus packet Source: specification.js Returns: PacketSpecification object Type PacketSpecification getPacketSpecification(channel, destinationAddress, sourceAddress, command) Gets the PacketSpecification object matching the given arguments. Parameters: Name Type Description channel number VBus channel destinationAddress number VBus address of destination device sourceAddress number VBus address of source device command number VBus command Source: specification.js Returns: PacketSpecification object Type PacketSpecification Example &gt; console.log(spec.getPacketSpecification(1, 0x0010, 0x7E21, 0x0100)); { packetId: '01_0010_7E21_10_0100', packetFields: [ { fieldId: '000_2_0', name: [Object], type: [Object], getRawValue: [Function] }, { fieldId: '002_1_0', name: [Object], type: [Object], getRawValue: [Function] } ], channel: 1, destinationAddress: 16, sourceAddress: 32289, protocolVersion: 16, command: 256, info: 0, destinationDevice: { name: 'DFA', deviceId: '01_0010_7E21', channel: 1, selfAddress: 16, peerAddress: 32289, fullName: 'VBus #1: DFA' }, sourceDevice: { name: 'DeltaSol MX [Heizkreis #1]', deviceId: '01_7E21_0010', channel: 1, selfAddress: 32289, peerAddress: 16, fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' }, fullName: 'VBus #1: DeltaSol MX [Heizkreis #1]' } undefined &gt; getRawValue(packetField, buffer [, start] [, end]) Gets the raw value of a packet field from a buffer. Parameters: Name Type Argument Default Description packetField PacketFieldSpecification PacketFieldSpecification object buffer Buffer Buffer object start number &lt;optional&gt; 0 Start index in the buffer end number &lt;optional&gt; buffer.length End index in the buffer Source: specification.js Returns: Raw value Type number Example &gt; var packetFieldSpec = spec.getPacketFieldSpecification('01_0010_7721_10_0100_000_2_0'); undefined &gt; var buffer = new Buffer('b822', 'hex'); undefined &gt; console.log(spec.getRawValue(packetFieldSpec, buffer)); 888.8000000000001 undefined &gt; getTypeById(id) Gets the TypeSpecification object matching the given identifier. Parameters: Name Type Description id string Type identifier Source: specification.js Returns: Type object Type TypeSpecification Example &gt; console.log(spec.getTypeById('Number_0_1_DegreesCelsius')); { typeId: 'Number_0_1_DegreesCelsius', rootTypeId: 'Number', precision: 1, unit: { unitId: 'DegreesCelsius', unitCode: 'DegreesCelsius', unitText: ' °C' } } undefined &gt; getUnitById(id) Gets the UnitSpecification object matching the given identifier. Parameters: Name Type Description id string Unit identifier Source: specification.js Returns: Unit object Type UnitSpecification Example &gt; console.log(spec.getUnitById('DegreesCelsius')); { unitId: 'DegreesCelsius', unitCode: 'DegreesCelsius', unitText: ' °C' } undefined &gt; × Search results Close "},"TcpConnection.html":{"id":"TcpConnection.html","title":"Class: TcpConnection","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: TcpConnection TcpConnection The TcpConnection class is primarily designed to provide access to VBus live datausing the VBus-over-TCP specification. That includes the VBus/LAN adapter, theDataloggers (DL2 and DL3) and VBus.net.In addition to that it can be used to connect to a raw VBus data stream using TCP(for example provided by a serial-to-LAN gateway). new TcpConnection(options) Creates a new TcpConnection instance and optionally initializes itsmembers to the given values. Parameters: Name Type Description options object Initialization values Properties Name Type Description host string See TcpConnection#host port number See TcpConnection#port viaTag string See TcpConnection#viaTag password string See TcpConnection#password rawVBusDataOnly boolean See TcpConnection#rawVBusDataOnly Source: tcp-connection.js Extends Connection Members channel :string|number Channel number to connect to. Type: string | number Overrides: Connection#channel Source: tcp-connection.js connectionState :string The current connection state. Type: string Inherited From: Connection#connectionState Source: connection.js dataSource :DataSource Reference to this instance's DataSource. Type: DataSource Inherited From: Connection#dataSource Source: connection.js host :string Host name or IP address of the connection target. Type: string Source: tcp-connection.js password :string Password needed to connect to target. Type: string Source: tcp-connection.js port :number Port number of the connection target. Type: number Source: tcp-connection.js rawVBusDataOnly :boolean Indicates that connection does not need to perform login handshake.Useful for serial-to-LAN converters. Type: boolean Source: tcp-connection.js reconnectTimeout :number Timeout in milliseconds to way between reconnection retries. Type: number Source: tcp-connection.js reconnectTimeoutIncr :number Value to increment timeout after every unsuccessful reconnection retry. Type: number Source: tcp-connection.js reconnectTimeoutMax :number Maximum timeout value between unsuccessful reconnection retry. Type: number Source: tcp-connection.js rxBuffer :Buffer The internal receive buffer of this conneciton. Type: Buffer Inherited From: Connection#rxBuffer Source: connection.js selfAddress :number The VBus address used for sending information over this connection. Type: number Inherited From: Connection#selfAddress Source: connection.js viaTag :string Via tag if connection target is accessed using the VBus.net service. Type: string Source: tcp-connection.js Methods &lt;abstract&gt; connect() Establish underlying connection and start streaming data to the writable sideof this Connection instance's stream. Inherited From: Connection#connect Overrides: Connection#connect Source: connection.js Returns: A promise that resolves once the connection has been established. Type Promise createConnectedPromise() Creates a promise that resolves when this Connectioninstance is connected and rejects if it is disconnected.If it is neither connected nor disconnected the promisewill stay pending until one of the states is entered. Inherited From: Connection#createConnectedPromise Source: connection.js Returns: Type Promise &lt;abstract&gt; disconnect() Diconnect this instance. Inherited From: Connection#disconnect Overrides: Connection#disconnect Source: connection.js getValueById(address, valueId, options) Sends a Datagram to get a value from a device.Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to get the value from valueId number The ID of the value to read from the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to get the value. Inherited From: Connection#getValueById Source: connection.js Returns: A promise that resolves to the received Datagram or null on timeout. Type Promise getValueIdByIdHash(address, valueIdHash, options) Sends a Datagram to lookup a value ID in a device.Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to lookup the value in. valueIdHash number The ID hash of the value to lookup in the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#getValueIdByIdHash Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise getValueIdHashById(address, valueId, options) Sends a Datagram to lookup a value ID hash in a device.Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to lookup the value in. valueId number The ID of the value to lookup in the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to lookup the value. Inherited From: Connection#getValueIdHashById Source: connection.js Returns: A Promise the resolves to the received Datagram or null on timeout. Type Promise releaseBus(address, options) Sends a VBus bus release datagram (Command 0x0600).Returns a Promise that resolves with the first VBus packet received after the release or null on timeout. Parameters: Name Type Description address number The VBus address of the master device to give the bus ownership back to. options object Properties Name Type Default Description tries number 2 Number of tries to give the bus ownership back. timeout number 1500 Time in milliseconds to wait between tries. Inherited From: Connection#releaseBus Source: connection.js send(data) Send raw data over this Connection instance. Parameters: Name Type Description data Header | Buffer The Header or Buffer instance to be sent. Inherited From: Connection#send Source: connection.js setValueById(address, valueId, value, options) Sends a Datagram to set a value in a device.Returns a Promise that resolves to the answer Datagram or null on timeout. Parameters: Name Type Description address number The VBus address of the device to set the value in valueId number The ID of the value to write to the device. value number The value to write to the device. options object Properties Name Type Default Description timeout number 500 Time in milliseconds between tries. timeoutIncr number 500 Additional time in milliseconds to increase the timeout per try. tries number 3 Number of tries to get the value. Inherited From: Connection#setValueById Source: connection.js Returns: A promise that resolves to the received Datagram or null on timeout. Type Promise transceive(txData, options) Sends and / or receives a VBus data. Parameters: Name Type Description txData Header | Buffer The Header or Buffer instance to be sent. options object Properties Name Type Argument Description timeout number Timeout in milliseconds after which the txData will be sent again timeoutIncr number After each timeout retransmission the timeout value for the next try is increment by this value. tries number After this number of tries the returned Promise will resolve with value null. filterPacket function &lt;nullable&gt; Will be called when a Packet has been received with the Packet and a callback as arguments. filterDatagram function &lt;nullable&gt; Will be called when a Datagram has been received with the Datagram and a callback as arguments. Inherited From: Connection#transceive Source: connection.js Returns: A Promise that either resolves to the VBus data selected by one of the filter callbacks or null on timeout. Type Promise waitForFreeBus(timeout) Waits for a VBus bus offering datagram (Command 0x0500). Returns a Promise that resolves with the Datagram or null if the method timed out. Parameters: Name Type Default Description timeout number 20000 Timeout in milliseconds Inherited From: Connection#waitForFreeBus Source: connection.js Returns: A Promise that resolves to the bus offering Datagram or null on timeout. Type Promise × Search results Close "},"TcpConnectionEndpoint.html":{"id":"TcpConnectionEndpoint.html","title":"Class: TcpConnectionEndpoint","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: TcpConnectionEndpoint TcpConnectionEndpoint The TcpConnectionEndpoint can act as the remote side for a TcpConnection.It supports all the commands that a DL3 connected via VBus.net wouldprovide as well. A connection event is emitted whenever an incoming connection passesthe VBus-over-TCP handshake. new TcpConnectionEndpoint(options) Creates a new instance and optionally initializes its members. Parameters: Name Type Description options object The initialization values for this instance. Properties Name Type Description port number See TcpConnectionEndpoint#port channels number See TcpConnectionEndpoint#channels Source: tcp-connection-endpoint.js Extends EventEmitter Members channels :Array.&lt;string&gt; The list of channels to return if the CHANNELLIST command is received. Type: Array.&lt;string&gt; Source: tcp-connection-endpoint.js port :number The port number to listen on for incoming connections. Type: number Source: tcp-connection-endpoint.js server :net.Server The Server instance used for listening for incoming connections. Type: net.Server Source: tcp-connection-endpoint.js Methods start() Starts the server to listen for incoming connections. Source: tcp-connection-endpoint.js Returns: A promise that resolves when the server is started. Type Promise × Search results Close "},"TcpDataSource.html":{"id":"TcpDataSource.html","title":"Class: TcpDataSource","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: TcpDataSource TcpDataSource new TcpDataSource() Creates a new TcpDataSource instance. Source: tcp-data-source.js Extends DataSource Members host :string The host to connect to. Type: string Source: tcp-data-source.js liveChannel :number The channel to connect to live. Type: number Source: tcp-data-source.js livePassword :string The password to connect live. Type: string Source: tcp-data-source.js port :number The port to connect to. Type: number Source: tcp-data-source.js × Search results Close "},"TcpDataSourceProvider.html":{"id":"TcpDataSourceProvider.html","title":"Class: TcpDataSourceProvider","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: TcpDataSourceProvider TcpDataSourceProvider new TcpDataSourceProvider() Creates a new TcpDataSourceProvider instance. Source: tcp-data-source-provider.js Extends DataSourceProvider Methods &lt;static&gt; discoverDevices() Discovers devices on the local network. Source: tcp-data-source-provider.js Returns: A Promise that resolves to an array of device information objects. Type Promise × Search results Close "},"Telegram.html":{"id":"Telegram.html","title":"Class: Telegram","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: Telegram Telegram new Telegram(options) Creates a new Telegram instance. Parameters: Name Type Description options object Initialization options. Source: telegram.js Extends Header Members channel :number VBus channel of this header Type: number Inherited From: Header#channel Default Value: 0 Source: header.js command :number The VBus command of this Telegram instance. Type: number Source: telegram.js destinationAddress :number VBus address of this header's destination Type: number Inherited From: Header#destinationAddress Default Value: 0 Source: header.js sourceAddress :number VBus address of this header's source Type: number Inherited From: Header#sourceAddress Source: header.js timestamp :Date Timestamp of this header Type: Date Inherited From: Header#timestamp Default Value: now Source: header.js Methods compareTo(that) Compares this Header instance to another one. Sub-classes can extend the comparison to include specificinformation. Parameters: Name Type Description that Header Another Header instance to compare to. Inherited From: Header#compareTo Overrides: Header#compareTo Source: header.js Returns: Returns a number less than 0 if this &lt; that greater than 0 if this &gt; that equal to to if this == that Type number getId() Returns a string identifier describing this Header instance.It contains at least: channel destination address source address protocol version Sub-classes can extend that information. The structure of thisidentifier is implementation specific, do not rely on it! Inherited From: Header#getId Overrides: Header#getId Source: header.js Returns: Identifier Type string getInfo() Returns an info number about this Header instance. It can be usedfor sorting purposes (to distinguish Header objects that wouldotherwise compare as equal). Inherited From: Header#getInfo Source: header.js Returns: Info value Type number &lt;abstract&gt; getProtocolVersion() Returns the protocol version of this Header instance as a 8-bitnumber. The high nibble is used for the major version, the lownibble for the minor version. For example: a header with protocolversion 2.0 would return 0x20. Must be implemented by sub-class. Inherited From: Header#getProtocolVersion Overrides: Header#getProtocolVersion Source: header.js Returns: Protocol version Type number &lt;abstract&gt; toLiveBuffer( [buffer] [, start] [, end]) Creates a representation of this Header instance that can betransmitted over a Connection. If no buffer is given as anarguments, it creates a new one that is big enough to holdthe representation. Must be implemented by sub-class. Parameters: Name Type Argument Description buffer Buffer &lt;optional&gt; Buffer object to store data in start number &lt;optional&gt; Start index in the buffer end number &lt;optional&gt; End index in the buffer Inherited From: Header#toLiveBuffer Overrides: Header#toLiveBuffer Source: header.js Returns: Buffer object containing the data Type Buffer × Search results Close "},"TextConverter.html":{"id":"TextConverter.html","title":"Class: TextConverter","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: TextConverter TextConverter The TextConverter class takes header sets, converts them into textrepresentation and then publishes that on the readable stream sideof itself. It does not support parsing text content back into header sets (thewritable stream side). new TextConverter() Create a new TextConverter instance given the set of options. Source: text-converter.js Extends Converter Members columnSeparator :string Column separator, defaults to tab Type: string Source: text-converter.js lastIdList :string List of packet IDs converted last time, enables decision whether anew header line pair must be output. Type: string Source: text-converter.js lineSeparator :string Line separator, defaults to CR+NL Type: string Source: text-converter.js objectMode :boolean Specifies whether the underlying stream operates in object mode. Type: boolean Inherited From: Converter#objectMode Source: converter.js separateDateAndTime :boolean Specifies whether date and time columns should be output separately Type: boolean Source: text-converter.js specification :Specification VBus specification Type: Specification Source: text-converter.js Methods convertHeader(header) This method queues a VBus Header model (Packet, Datagram or Telegram) for conversion.Not all Converter sub-classes support this method. Parameters: Name Type Description header Header The Header to queue for conversion. Inherited From: Converter#convertHeader Source: converter.js convertHeaderSet(headerSet) Converts a header set into text representation. Parameters: Name Type Description headerSet HeaderSet Overrides: Converter#convertHeaderSet Source: text-converter.js convertRawData(rawData) This method queues a VBus raw data chunk from conversion.Not all Converter sub-classes support this method. Parameters: Name Type Description rawData RawData The VBus raw data chunk to queue for conversion. Inherited From: Converter#convertRawData Source: converter.js finish() This method signals that no additional VBus Header or HeaderSet models willbe converted. It returns a promise that resolves when all data has beenconsumed. Inherited From: Converter#finish Source: converter.js Returns: A Promise that resolves when all data has been consumed. Type Promise reset() Resets the converter, resulting in a ne pair of header linesgenerated on next header set conversion. Overrides: Converter#reset Source: text-converter.js × Search results Close "},"VBusRecordingConverter.html":{"id":"VBusRecordingConverter.html","title":"Class: VBusRecordingConverter","body":" resol-vbus Classes ConnectionConnectionCustomizerConverterCustomizerDatagramDLxJsonConverterDLxRecorderHeaderHeaderSetHeaderSetConsolidatorI18NPacketRecorderSerialConnectionSerialDataSourceSpecificationTcpConnectionTcpConnectionEndpointTcpDataSourceTcpDataSourceProviderTelegramTextConverterVBusRecordingConverter Events HeaderSet#event:addHeaderHeaderSet#event:removeHeaderHeaderSetConsolidator#event:addHeaderHeaderSetConsolidator#event:removeHeader Global extendgetOptimizerOptionsmatchOptimizer Class: VBusRecordingConverter VBusRecordingConverter This Converter subclass converts Header and HeaderSet instances to and from a binary stream thatconforms to the VBus Recording File Format (the binary file format used e.g. to store data on theDatalogger devices). new VBusRecordingConverter() Creates a new VBusRecordingConverter instance. Source: vbus-recording-converter.js Extends Converter Members objectMode :boolean Specifies whether the underlying stream operates in object mode. Type: boolean Inherited From: Converter#objectMode Source: converter.js Methods convertHeader(header) This method queues a VBus Header model (Packet, Datagram or Telegram) for conversion.Not all Converter sub-classes support this method. Parameters: Name Type Description header Header The Header to queue for conversion. Inherited From: Converter#convertHeader Overrides: Converter#convertHeader Source: converter.js convertHeaderSet(headerSet) This method queues a VBus HeaderSet instance for conversion.Not all Converter sub-classes support this method. Parameters: Name Type Description headerSet HeaderSet The HeaderSet to queue for conversion. Inherited From: Converter#convertHeaderSet Overrides: Converter#convertHeaderSet Source: converter.js convertRawData(rawData) This method queues a VBus raw data chunk from conversion.Not all Converter sub-classes support this method. Parameters: Name Type Description rawData RawData The VBus raw data chunk to queue for conversion. Inherited From: Converter#convertRawData Overrides: Converter#convertRawData Source: converter.js finish() This method signals that no additional VBus Header or HeaderSet models willbe converted. It returns a promise that resolves when all data has beenconsumed. Inherited From: Converter#finish Source: converter.js Returns: A Promise that resolves when all data has been consumed. Type Promise reset() This method resets the converter. It should be used e.g. if the converter output switches between files (allowssome Converter sub-classes to correctly write a header). Inherited From: Converter#reset Overrides: Converter#reset Source: converter.js × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
